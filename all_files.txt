# app/build.gradle
plugins {
    id 'com.android.application'
    id 'org.jetbrains.kotlin.android'
}

android {
    namespace 'com.example.helloworld' // Added namespace
    compileSdk 34

    defaultConfig {
        applicationId "com.example.helloworld"
        minSdk 24
        targetSdk 34
        versionCode 1
        versionName "1.0"
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_17
        targetCompatibility JavaVersion.VERSION_17
    }
    kotlinOptions {
        jvmTarget = '17'
    }
}

dependencies {
    implementation 'androidx.core:core-ktx:1.12.0'
    implementation 'androidx.appcompat:appcompat:1.6.1'
    implementation 'com.google.android.material:material:1.10.0'
    implementation 'androidx.constraintlayout:constraintlayout:2.1.4'
}

# app/src/main/AndroidManifest.xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.helloworld">

    <uses-permission android:name="android.permission.CAMERA"/>
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
    <uses-permission android:name="android.permission.READ_MEDIA_IMAGES"/>

    <uses-feature android:name="android.hardware.camera" android:required="true"/>

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.HelloWorld">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:configChanges="orientation|screenSize">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>

# app/src/main/java/com/example/helloworld/LayerAdapter.java
package com.example.helloworld;

import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.CheckBox;
import android.widget.TextView;
import androidx.annotation.NonNull;
import androidx.recyclerview.widget.RecyclerView;

public class LayerAdapter extends RecyclerView.Adapter<LayerAdapter.ViewHolder> {

    private final String[] layers;
    private final boolean[] visibility;
    private final OnLayerVisibilityChangedListener listener;

    public interface OnLayerVisibilityChangedListener {
        void onLayerVisibilityChanged(int position, boolean isVisible);
    }

    public LayerAdapter(String[] layers, boolean[] visibility, OnLayerVisibilityChangedListener listener) {
        this.layers = layers;
        this.visibility = visibility;
        this.listener = listener;
    }

    @NonNull
    @Override
    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(parent.getContext())
                .inflate(android.R.layout.simple_list_item_2, parent, false);
        return new ViewHolder(view);
    }

    @Override
    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
        holder.text1.setText(layers[position]);
        holder.checkBox.setChecked(visibility[position]);
        holder.checkBox.setOnCheckedChangeListener((buttonView, isChecked) -> {
            visibility[position] = isChecked;
            if (listener != null) {
                listener.onLayerVisibilityChanged(position, isChecked);
            }
        });
    }

    @Override
    public int getItemCount() {
        return layers.length;
    }

    static class ViewHolder extends RecyclerView.ViewHolder {
        TextView text1;
        CheckBox checkBox;

        ViewHolder(View itemView) {
            super(itemView);
            text1 = itemView.findViewById(android.R.id.text1);
            checkBox = new CheckBox(itemView.getContext());
            ViewGroup parent = (ViewGroup) text1.getParent();
            parent.addView(checkBox);
        }
    }
}

# app/src/main/java/com/example/helloworld/MainActivity.java
package com.example.helloworld;

import android.Manifest;
import android.app.Dialog;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.res.Configuration;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.ColorMatrix;
import android.graphics.ColorMatrixColorFilter;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.hardware.camera2.CameraAccessException;
import android.hardware.camera2.CameraCaptureSession;
import android.hardware.camera2.CameraCharacteristics;
import android.hardware.camera2.CameraDevice;
import android.hardware.camera2.CameraManager;
import android.hardware.camera2.CaptureRequest;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.HandlerThread;
import android.provider.MediaStore;
import android.util.Log;
import android.util.Size;
import android.view.MotionEvent;
import android.view.ScaleGestureDetector;
import android.view.Surface;
import android.view.SurfaceHolder;
import android.view.SurfaceView;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.ImageView;
import android.widget.SeekBar;
import android.widget.Switch;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.app.ActivityCompat;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Arrays;
import java.util.concurrent.Semaphore;

public class MainActivity extends AppCompatActivity implements LayerAdapter.OnLayerVisibilityChangedListener {

    private static final String TAG = "MainActivity";
    private static final int REQUEST_CAMERA_PERMISSION = 100;
    private static final int REQUEST_STORAGE_PERMISSION = 101;
    private static final int PICK_IMAGE_REQUEST = 1;

    private SurfaceView cameraSurfaceView;
    private ImageView imageView;
    private SeekBar transparencySeekBar;
    private Button pickImageButton;
    private Switch pencilModeSwitch;
    private Button layerSelectButton;
    private CheckBox controlsVisibilityCheckbox;
    private CheckBox hideImageCheckbox;
    private Button saveParametersButton;
    private Button loadParametersButton;
    private Button switchCameraButton;

    private CameraDevice cameraDevice;
    private CameraCaptureSession cameraCaptureSession;
    private CaptureRequest.Builder previewRequestBuilder;
    private String cameraId;
    private Size previewSize;
    private HandlerThread backgroundThread;
    private Handler backgroundHandler;
    private final Semaphore cameraOpenCloseLock = new Semaphore(1);
    private volatile boolean isSurfaceAvailable = false;
    private volatile boolean isCameraPendingOpen = false;
    private volatile boolean isCameraOpen = false;

    private Bitmap originalBitmap;
    private Bitmap pencilBitmap;
    private Bitmap[] layerBitmaps;
    private boolean[] layerVisibility;
    private Matrix matrix = new Matrix();
    private float scaleFactor = 1.0f;
    private float rotationAngle = 0.0f;
    private boolean isPencilMode = false;
    private boolean isImageVisible = true;
    private ScaleGestureDetector scaleGestureDetector;
    private float lastTouchX, lastTouchY;
    private boolean isDragging = false;

    private String[] cameraIds;
    private int currentCameraIndex = 0;

    private static final String[] PENCIL_HARDNESS = {
            "9H", "8H", "7H", "6H", "5H", "4H", "3H", "2H", "H", "F",
            "HB", "B", "2B", "3B", "4B", "5B", "6B", "7B", "8B", "9B"
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        cameraSurfaceView = findViewById(R.id.cameraSurfaceView);
        imageView = findViewById(R.id.imageView);
        transparencySeekBar = findViewById(R.id.transparencySeekBar);
        pickImageButton = findViewById(R.id.pickImageButton);
        pencilModeSwitch = findViewById(R.id.pencilModeSwitch);
        layerSelectButton = findViewById(R.id.layerSelectButton);
        controlsVisibilityCheckbox = findViewById(R.id.controlsVisibilityCheckbox);
        hideImageCheckbox = findViewById(R.id.hideImageCheckbox);
        saveParametersButton = findViewById(R.id.saveParametersButton);
        loadParametersButton = findViewById(R.id.loadParametersButton);
        switchCameraButton = findViewById(R.id.switchCameraButton);

        scaleGestureDetector = new ScaleGestureDetector(this, new ScaleGestureDetector.SimpleOnScaleGestureListener() {
            @Override
            public boolean onScale(ScaleGestureDetector detector) {
                scaleFactor *= detector.getScaleFactor();
                scaleFactor = Math.max(0.1f, Math.min(scaleFactor, 5.0f));
                matrix.postScale(detector.getScaleFactor(), detector.getScaleFactor(), detector.getFocusX(), detector.getFocusY());
                applyTransformations();
                return true;
            }
        });

        imageView.setOnTouchListener((v, event) -> {
            scaleGestureDetector.onTouchEvent(event);
            switch (event.getAction()) {
                case MotionEvent.ACTION_DOWN:
                    lastTouchX = event.getX();
                    lastTouchY = event.getY();
                    isDragging = true;
                    break;
                case MotionEvent.ACTION_MOVE:
                    if (isDragging) {
                        float dx = event.getX() - lastTouchX;
                        float dy = event.getY() - lastTouchY;
                        matrix.postTranslate(dx, dy);
                        applyTransformations();
                        lastTouchX = event.getX();
                        lastTouchY = event.getY();
                    }
                    break;
                case MotionEvent.ACTION_UP:
                case MotionEvent.ACTION_CANCEL:
                    isDragging = false;
                    break;
            }
            return true;
        });

        cameraSurfaceView.getHolder().addCallback(new SurfaceHolder.Callback() {
            @Override
            public void surfaceCreated(SurfaceHolder holder) {
                Log.d(TAG, "Surface created");
                isSurfaceAvailable = true;
                if (isCameraPendingOpen && !isCameraOpen) {
                    openCamera();
                    isCameraPendingOpen = false;
                }
            }

            @Override
            public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
                Log.d(TAG, "Surface changed: " + width + "x" + height);
                adjustSurfaceViewAspectRatioWithCropping(width, height);
                if (cameraDevice != null && isSurfaceAvailable) {
                    closeCameraPreviewSession();
                    previewSize = chooseOptimalPreviewSize(getPreviewSizes(), width, height);
                    createCameraPreviewSession();
                }
            }

            @Override
            public void surfaceDestroyed(SurfaceHolder holder) {
                Log.d(TAG, "Surface destroyed");
                isSurfaceAvailable = false;
                closeCamera();
            }
        });

        transparencySeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
            @Override
            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
                setImageAlpha(progress);
            }

            @Override
            public void onStartTrackingTouch(SeekBar seekBar) {}

            @Override
            public void onStopTrackingTouch(SeekBar seekBar) {}
        });

        pickImageButton.setOnClickListener(v -> pickImage());

        pencilModeSwitch.setOnCheckedChangeListener((buttonView, isChecked) -> {
            isPencilMode = isChecked;
            layerSelectButton.setVisibility(isChecked ? View.VISIBLE : View.GONE);
            if (isPencilMode) {
                processPencilEffect();
            }
            updateImageDisplay();
        });

        layerSelectButton.setOnClickListener(v -> showLayerSelectionDialog());

        controlsVisibilityCheckbox.setOnCheckedChangeListener((buttonView, isChecked) -> {
            int visibility = isChecked ? View.VISIBLE : View.GONE;
            transparencySeekBar.setVisibility(visibility);
            pickImageButton.setVisibility(visibility);
            pencilModeSwitch.setVisibility(visibility);
            layerSelectButton.setVisibility(isPencilMode && isChecked ? View.VISIBLE : View.GONE);
            hideImageCheckbox.setVisibility(visibility);
            saveParametersButton.setVisibility(visibility);
            loadParametersButton.setVisibility(visibility);
            switchCameraButton.setVisibility(visibility);
        });

        hideImageCheckbox.setOnCheckedChangeListener((buttonView, isChecked) -> {
            isImageVisible = !isChecked;
            updateImageDisplay();
        });

        saveParametersButton.setOnClickListener(v -> saveParameters());

        loadParametersButton.setOnClickListener(v -> loadParameters());

        switchCameraButton.setOnClickListener(v -> switchCamera());

        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.CAMERA}, REQUEST_CAMERA_PERMISSION);
        } else {
            isCameraPendingOpen = true;
        }

        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED ||
                ActivityCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE}, REQUEST_STORAGE_PERMISSION);
        }

        // Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ ÑĞ¿Ğ¸ÑĞºĞ° ĞºĞ°Ğ¼ĞµÑ€
        CameraManager manager = (CameraManager) getSystemService(CAMERA_SERVICE);
        try {
            cameraIds = manager.getCameraIdList();
            if (cameraIds.length > 0) {
                cameraId = cameraIds[0];
            }
        } catch (CameraAccessException e) {
            Log.e(TAG, "Error accessing camera list", e);
            Toast.makeText(this, "Cannot access cameras", Toast.LENGTH_LONG).show();
        }

        // Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ layerVisibility
        layerVisibility = new boolean[20];
        Arrays.fill(layerVisibility, true);
    }

    private void adjustSurfaceViewAspectRatioWithCropping(int width, int height) {
        if (previewSize == null) {
            return;
        }

        float previewRatio = (float) previewSize.getWidth() / previewSize.getHeight();
        float viewRatio = (float) width / height;

        int newWidth, newHeight;
        if (previewRatio > viewRatio) {
            newWidth = width;
            newHeight = (int) (width / previewRatio);
        } else {
            newHeight = height;
            newWidth = (int) (height * previewRatio);
        }

        ViewGroup.LayoutParams params = cameraSurfaceView.getLayoutParams();
        params.width = width;
        params.height = height;
        cameraSurfaceView.setLayoutParams(params);

        float scaleX = (float) width / newWidth;
        float scaleY = (float) height / newHeight;
        float scale = Math.max(scaleX, scaleY);

        cameraSurfaceView.setScaleX(scale);
        cameraSurfaceView.setScaleY(scale);

        cameraSurfaceView.setPivotX(width / 2f);
        cameraSurfaceView.setPivotY(height / 2f);

        cameraSurfaceView.requestLayout();
        Log.d(TAG, "Adjusted SurfaceView with cropping to " + width + "x" + height + " (preview ratio: " + previewRatio + ")");
    }

    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
        if (requestCode == REQUEST_CAMERA_PERMISSION) {
            if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                if (isSurfaceAvailable && !isCameraOpen) {
                    openCamera();
                } else {
                    isCameraPendingOpen = true;
                }
            } else {
                Toast.makeText(this, "Camera permission is required", Toast.LENGTH_LONG).show();
                finish();
            }
        } else if (requestCode == REQUEST_STORAGE_PERMISSION) {
            if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                // Ğ Ğ°Ğ·Ñ€ĞµÑˆĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¾
            } else {
                Toast.makeText(this, "Storage permission is required", Toast.LENGTH_LONG).show();
            }
        }
    }

    private void startBackgroundThread() {
        if (backgroundThread == null) {
            backgroundThread = new HandlerThread("CameraBackground");
            backgroundThread.start();
            backgroundHandler = new Handler(backgroundThread.getLooper());
        }
    }

    private void stopBackgroundThread() {
        if (backgroundThread != null) {
            backgroundThread.quitSafely();
            try {
                backgroundThread.join();
                backgroundThread = null;
                backgroundHandler = null;
            } catch (InterruptedException e) {
                Log.e(TAG, "Error stopping background thread", e);
            }
        }
    }

    private void openCamera() {
        if (!isSurfaceAvailable || isCameraOpen) {
            Log.d(TAG, "Surface not available or camera already open, setting pending open");
            isCameraPendingOpen = true;
            return;
        }

        startBackgroundThread();
        CameraManager manager = (CameraManager) getSystemService(CAMERA_SERVICE);
        try {
            if (cameraId == null) {
                cameraId = manager.getCameraIdList()[0];
            }
            CameraCharacteristics characteristics = manager.getCameraCharacteristics(cameraId);
            Size[] previewSizes = characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP)
                    .getOutputSizes(SurfaceHolder.class);
            previewSize = chooseOptimalPreviewSize(previewSizes, cameraSurfaceView.getWidth(), cameraSurfaceView.getHeight());

            if (ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {
                return;
            }
            cameraOpenCloseLock.acquire();
            isCameraOpen = true;
            manager.openCamera(cameraId, new CameraDevice.StateCallback() {
                @Override
                public void onOpened(@NonNull CameraDevice camera) {
                    cameraDevice = camera;
                    if (isSurfaceAvailable) {
                        createCameraPreviewSession();
                    } else {
                        Log.d(TAG, "Surface not available after camera opened, closing camera");
                        closeCamera();
                    }
                    cameraOpenCloseLock.release();
                }

                @Override
                public void onDisconnected(@NonNull CameraDevice camera) {
                    cameraOpenCloseLock.release();
                    camera.close();
                    cameraDevice = null;
                    isCameraOpen = false;
                }

                @Override
                public void onError(@NonNull CameraDevice camera, int error) {
                    cameraOpenCloseLock.release();
                    camera.close();
                    cameraDevice = null;
                    isCameraOpen = false;
                    Toast.makeText(MainActivity.this, "Camera error: " + error, Toast.LENGTH_LONG).show();
                }
            }, backgroundHandler);
        } catch (CameraAccessException e) {
            Log.e(TAG, "Cannot access camera", e);
            Toast.makeText(this, "Cannot access camera", Toast.LENGTH_LONG).show();
            isCameraOpen = false;
        } catch (InterruptedException e) {
            Log.e(TAG, "Interrupted while opening camera", e);
            cameraOpenCloseLock.release();
            isCameraOpen = false;
        }
    }

    private Size[] getPreviewSizes() {
        try {
            CameraManager manager = (CameraManager) getSystemService(CAMERA_SERVICE);
            CameraCharacteristics characteristics = manager.getCameraCharacteristics(cameraId);
            return characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP)
                    .getOutputSizes(SurfaceHolder.class);
        } catch (CameraAccessException e) {
            Log.e(TAG, "Error getting preview sizes", e);
            return new Size[]{new Size(1280, 720)};
        }
    }

    private Size chooseOptimalPreviewSize(Size[] choices, int viewWidth, int viewHeight) {
        if (choices == null || choices.length == 0) {
            Log.e(TAG, "No preview sizes available, using default");
            return new Size(1280, 720);
        }

        double targetRatio;
        if (viewWidth > 0 && viewHeight > 0) {
            targetRatio = (double) viewWidth / viewHeight;
        } else {
            targetRatio = 4.0 / 3.0;
        }

        Size optimalSize = null;
        double minDiff = Double.MAX_VALUE;
        int maxArea = 0;

        for (Size size : choices) {
            double ratio = (double) size.getWidth() / size.getHeight();
            int area = size.getWidth() * size.getHeight();
            double ratioDiff = Math.abs(ratio - targetRatio);
            if (ratioDiff < minDiff || (ratioDiff == minDiff && area > maxArea)) {
                optimalSize = size;
                minDiff = ratioDiff;
                maxArea = area;
            }
        }

        if (optimalSize == null) {
            optimalSize = choices[0];
        }

        Log.d(TAG, "Chosen preview size: " + optimalSize.getWidth() + "x" + optimalSize.getHeight());
        return optimalSize;
    }

    private void createCameraPreviewSession() {
        if (!isSurfaceAvailable || cameraDevice == null || !isCameraOpen) {
            Log.d(TAG, "Cannot create preview session: Surface not available, cameraDevice is null, or camera is closed");
            return;
        }

        try {
            SurfaceHolder holder = cameraSurfaceView.getHolder();
            Surface surface = holder.getSurface();
            if (!surface.isValid()) {
                Log.d(TAG, "Surface is not valid, aborting preview session creation");
                return;
            }

            previewRequestBuilder = cameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
            previewRequestBuilder.addTarget(surface);

            cameraDevice.createCaptureSession(Arrays.asList(surface), new CameraCaptureSession.StateCallback() {
                @Override
                public void onConfigured(@NonNull CameraCaptureSession session) {
                    if (cameraDevice == null || !isSurfaceAvailable || !isCameraOpen) {
                        Log.d(TAG, "Camera device closed, surface not available, or camera not open during session configuration");
                        session.close();
                        return;
                    }
                    cameraCaptureSession = session;
                    try {
                        previewRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);
                        cameraCaptureSession.setRepeatingRequest(previewRequestBuilder.build(), null, backgroundHandler);
                        Log.d(TAG, "Camera preview session started");
                    } catch (CameraAccessException e) {
                        Log.e(TAG, "Error setting up camera preview", e);
                    } catch (IllegalStateException e) {
                        Log.e(TAG, "Session already closed during setRepeatingRequest", e);
                    }
                }

                @Override
                public void onConfigureFailed(@NonNull CameraCaptureSession session) {
                    Toast.makeText(MainActivity.this, "Failed to configure camera preview", Toast.LENGTH_LONG).show();
                }
            }, backgroundHandler);
        } catch (CameraAccessException e) {
            Log.e(TAG, "Error creating camera preview session", e);
        }
    }

    private void closeCameraPreviewSession() {
        if (cameraCaptureSession != null) {
            cameraCaptureSession.close();
            cameraCaptureSession = null;
        }
    }

    private void closeCamera() {
        try {
            cameraOpenCloseLock.acquire();
            closeCameraPreviewSession();
            if (cameraDevice != null) {
                cameraDevice.close();
                cameraDevice = null;
            }
            isCameraOpen = false;
        } catch (InterruptedException e) {
            Log.e(TAG, "Error closing camera", e);
        } finally {
            cameraOpenCloseLock.release();
        }
        stopBackgroundThread();
    }

    private void switchCamera() {
        CameraManager manager = (CameraManager) getSystemService(CAMERA_SERVICE);
        try {
            closeCamera();
            currentCameraIndex = (currentCameraIndex + 1) % cameraIds.length;
            cameraId = cameraIds[currentCameraIndex];
            if (isSurfaceAvailable && !isCameraOpen) {
                openCamera();
            } else {
                isCameraPendingOpen = true;
            }
        } catch (Exception e) {
            Log.e(TAG, "Error switching camera", e);
            Toast.makeText(this, "Error switching camera", Toast.LENGTH_LONG).show();
        }
    }

    private void pickImage() {
        Intent intent = new Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI);
        startActivityForResult(intent, PICK_IMAGE_REQUEST);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if (requestCode == PICK_IMAGE_REQUEST && resultCode == RESULT_OK && data != null) {
            Uri imageUri = data.getData();
            try {
                if (originalBitmap != null && !originalBitmap.isRecycled()) {
                    originalBitmap.recycle();
                }
                originalBitmap = MediaStore.Images.Media.getBitmap(getContentResolver(), imageUri);
                resetTransformationsAndFit();
                layerVisibility = new boolean[20];
                Arrays.fill(layerVisibility, true);
                if (isPencilMode) {
                    processPencilEffect();
                }
                updateImageDisplay();
            } catch (IOException e) {
                Log.e(TAG, "Error loading image", e);
                Toast.makeText(this, "Error loading image", Toast.LENGTH_LONG).show();
            }
        }
    }

    private void resetTransformationsAndFit() {
        if (originalBitmap == null || imageView.getWidth() == 0 || imageView.getHeight() == 0) {
            matrix.reset();
            scaleFactor = 1.0f;
            rotationAngle = 0.0f;
            imageView.setImageMatrix(matrix);
            return;
        }

        matrix.reset();

        float viewWidth = imageView.getWidth();
        float viewHeight = imageView.getHeight();
        float bmpWidth = originalBitmap.getWidth();
        float bmpHeight = originalBitmap.getHeight();

        float scaleX = viewWidth / bmpWidth;
        float scaleY = viewHeight / bmpHeight;
        float initialScale = Math.min(scaleX, scaleY);

        float scaledBmpWidth = bmpWidth * initialScale;
        float scaledBmpHeight = bmpHeight * initialScale;
        float initialTranslateX = (viewWidth - scaledBmpWidth) / 2f;
        float initialTranslateY = (viewHeight - scaledBmpHeight) / 2f;

        matrix.postScale(initialScale, initialScale);
        matrix.postTranslate(initialTranslateX, initialTranslateY);

        imageView.post(() -> {
            imageView.setImageMatrix(matrix);
            imageView.invalidate();
            scaleFactor = initialScale;
            rotationAngle = 0.0f;
        });
    }

    private void applyTransformations() {
        imageView.setImageMatrix(matrix);
        imageView.invalidate();
        Log.d(TAG, "Transformations applied: scale=" + scaleFactor);
    }

    private void setImageAlpha(int progress) {
        float alpha = progress / 100.0f;
        imageView.setAlpha(alpha);
        imageView.invalidate();
        Log.d(TAG, "Image alpha set to: " + alpha);
    }

    private void processPencilEffect() {
        Log.d(TAG, "Processing pencil effect");
        if (originalBitmap == null) {
            Log.d(TAG, "Original bitmap is null, cannot process pencil effect");
            return;
        }

        if (pencilBitmap != null && !pencilBitmap.isRecycled()) {
            pencilBitmap.recycle();
            pencilBitmap = null;
        }
        if (layerBitmaps != null) {
            for (Bitmap layer : layerBitmaps) {
                if (layer != null && !layer.isRecycled()) {
                    layer.recycle();
                }
            }
            layerBitmaps = null;
        }

        try {
            pencilBitmap = Bitmap.createBitmap(originalBitmap.getWidth(), originalBitmap.getHeight(), Bitmap.Config.ARGB_8888);
            if (pencilBitmap == null) {
                Log.e(TAG, "Failed to create pencilBitmap");
                return;
            }
            Canvas canvas = new Canvas(pencilBitmap);
            Paint paint = new Paint();
            ColorMatrix colorMatrix = new ColorMatrix();
            colorMatrix.setSaturation(0);
            ColorMatrixColorFilter filter = new ColorMatrixColorFilter(colorMatrix);
            paint.setColorFilter(filter);
            canvas.drawBitmap(originalBitmap, 0, 0, paint);

            layerBitmaps = new Bitmap[20];
            for (int i = 0; i < 20; i++) {
                layerBitmaps[i] = Bitmap.createBitmap(originalBitmap.getWidth(), originalBitmap.getHeight(), Bitmap.Config.ARGB_8888);
                if (layerBitmaps[i] == null) {
                    Log.e(TAG, "Failed to create layerBitmap[" + i + "]");
                    return;
                }
                layerBitmaps[i].eraseColor(Color.TRANSPARENT);
            }

            int[] pixels = new int[originalBitmap.getWidth() * originalBitmap.getHeight()];
            pencilBitmap.getPixels(pixels, 0, originalBitmap.getWidth(), 0, 0, originalBitmap.getWidth(), originalBitmap.getHeight());

            for (int i = 0; i < pixels.length; i++) {
                int gray = Color.red(pixels[i]);
                int layerIndex = getLayerIndex(gray);
                if (layerIndex >= 0 && layerIndex < 20 && layerBitmaps[layerIndex] != null) {
                    layerBitmaps[layerIndex].setPixel(i % originalBitmap.getWidth(), i / originalBitmap.getWidth(), pixels[i]);
                }
            }
            Log.d(TAG, "Pencil effect processed successfully");
        } catch (OutOfMemoryError e) {
            Log.e(TAG, "OutOfMemoryError in processPencilEffect", e);
            Toast.makeText(this, "Not enough memory for pencil effect", Toast.LENGTH_LONG).show();
            pencilBitmap = null;
            layerBitmaps = null;
        }
    }

    private int getLayerIndex(int grayValue) {
        return grayValue / (256 / 20);
    }

    private void updateImageDisplay() {
        Log.d(TAG, "updateImageDisplay: isPencilMode=" + isPencilMode + ", isImageVisible=" + isImageVisible);
        if (originalBitmap == null || !isImageVisible) {
            Log.d(TAG, "updateImageDisplay: originalBitmap is null or image is not visible");
            imageView.setImageBitmap(null);
            imageView.setVisibility(View.INVISIBLE);
            imageView.invalidate();
            return;
        }

        if (isPencilMode) {
            Log.d(TAG, "updateImageDisplay: Processing pencil mode");
            if (pencilBitmap == null || layerBitmaps == null) {
                processPencilEffect();
            }

            if (pencilBitmap == null || layerBitmaps == null) {
                Log.d(TAG, "updateImageDisplay: pencilBitmap or layerBitmaps is null");
                imageView.setImageBitmap(null);
                imageView.setVisibility(View.INVISIBLE);
                imageView.invalidate();
                return;
            }

            Bitmap resultBitmap = Bitmap.createBitmap(originalBitmap.getWidth(), originalBitmap.getHeight(), Bitmap.Config.ARGB_8888);
            if (resultBitmap == null) {
                Log.d(TAG, "updateImageDisplay: Failed to create resultBitmap");
                imageView.setImageBitmap(null);
                imageView.setVisibility(View.INVISIBLE);
                imageView.invalidate();
                return;
            }
            Canvas canvas = new Canvas(resultBitmap);
            canvas.drawColor(Color.TRANSPARENT);

            for (int i = 0; i < layerBitmaps.length; i++) {
                if (layerVisibility[i] && layerBitmaps[i] != null && !layerBitmaps[i].isRecycled()) {
                    canvas.drawBitmap(layerBitmaps[i], 0, 0, null);
                }
            }

            imageView.setImageBitmap(resultBitmap);
            setImageAlpha(transparencySeekBar.getProgress());
            imageView.setVisibility(View.VISIBLE);
            imageView.post(() -> {
                imageView.setImageMatrix(matrix);
                imageView.invalidate();
            });
            Log.d(TAG, "updateImageDisplay: Pencil mode applied");
        } else {
            Log.d(TAG, "updateImageDisplay: Displaying original bitmap");
            imageView.setImageBitmap(originalBitmap);
            setImageAlpha(transparencySeekBar.getProgress());
            imageView.setVisibility(View.VISIBLE);
            imageView.post(() -> {
                imageView.setImageMatrix(matrix);
                imageView.invalidate();
            });
            Log.d(TAG, "updateImageDisplay: Original bitmap displayed");
        }
    }

    private void showLayerSelectionDialog() {
        Dialog dialog = new Dialog(this);
        dialog.setContentView(R.layout.dialog_layer_selection);
        dialog.setTitle(R.string.layer_selection_title);

        RecyclerView recyclerView = dialog.findViewById(R.id.layerRecyclerView);
        recyclerView.setLayoutManager(new LinearLayoutManager(this));
        LayerAdapter adapter = new LayerAdapter(PENCIL_HARDNESS, layerVisibility, this);
        recyclerView.setAdapter(adapter);

        dialog.show();
    }

    @Override
    public void onLayerVisibilityChanged(int position, boolean isVisible) {
        layerVisibility[position] = isVisible;
        updateImageDisplay();
    }

    private void saveParameters() {
        try {
            File file = new File(getFilesDir(), "parameters.dat");
            FileOutputStream fos = new FileOutputStream(file);
            fos.write(Float.toString(scaleFactor).getBytes());
            fos.write("\n".getBytes());
            fos.write(Float.toString(rotationAngle).getBytes());
            fos.write("\n".getBytes());
            float[] matrixValues = new float[9];
            matrix.getValues(matrixValues);
            for (float value : matrixValues) {
                fos.write(Float.toString(value).getBytes());
                fos.write(" ".getBytes());
            }
            fos.write("\n".getBytes());
            fos.write(String.valueOf(isPencilMode).getBytes());
            fos.write("\n".getBytes());
            for (boolean visible : layerVisibility) {
                fos.write(String.valueOf(visible).getBytes());
                fos.write(" ".getBytes());
            }
            fos.close();
            Toast.makeText(this, "Parameters saved", Toast.LENGTH_SHORT).show();
        } catch (IOException e) {
            Log.e(TAG, "Error saving parameters", e);
            Toast.makeText(this, "Error saving parameters", Toast.LENGTH_LONG).show();
        }
    }

    private void loadParameters() {
        try {
            File file = new File(getFilesDir(), "parameters.dat");
            if (!file.exists()) {
                Toast.makeText(this, "No saved parameters found", Toast.LENGTH_SHORT).show();
                return;
            }
            FileInputStream fis = new FileInputStream(file);
            byte[] buffer = new byte[(int) file.length()];
            fis.read(buffer);
            fis.close();
            String[] lines = new String(buffer).split("\n");
            if (lines.length < 4) {
                Toast.makeText(this, "Invalid parameters file", Toast.LENGTH_LONG).show();
                return;
            }
            scaleFactor = Float.parseFloat(lines[0]);
            rotationAngle = Float.parseFloat(lines[1]);
            String[] matrixValues = lines[2].split(" ");
            float[] values = new float[9];
            for (int i = 0; i < 9; i++) {
                values[i] = Float.parseFloat(matrixValues[i]);
            }
            matrix.setValues(values);
            isPencilMode = Boolean.parseBoolean(lines[3]);
            pencilModeSwitch.setChecked(isPencilMode);
            String[] visibilityValues = lines[4].split(" ");
            for (int i = 0; i < layerVisibility.length; i++) {
                layerVisibility[i] = Boolean.parseBoolean(visibilityValues[i]);
            }
            applyTransformations();
            updateImageDisplay();
            Toast.makeText(this, "Parameters loaded", Toast.LENGTH_SHORT).show();
        } catch (IOException | NumberFormatException e) {
            Log.e(TAG, "Error loading parameters", e);
            Toast.makeText(this, "Error loading parameters", Toast.LENGTH_LONG).show();
        }
    }

    @Override
    protected void onResume() {
        super.onResume();
        if (isSurfaceAvailable && !isCameraOpen) {
            openCamera();
        } else {
            isCameraPendingOpen = true;
        }
    }

    @Override
    protected void onPause() {
        closeCamera();
        super.onPause();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        if (originalBitmap != null && !originalBitmap.isRecycled()) {
            originalBitmap.recycle();
            originalBitmap = null;
        }
        if (pencilBitmap != null && !pencilBitmap.isRecycled()) {
            pencilBitmap.recycle();
            pencilBitmap = null;
        }
        if (layerBitmaps != null) {
            for (Bitmap layer : layerBitmaps) {
                if (layer != null && !layer.isRecycled()) {
                    layer.recycle();
                }
            }
            layerBitmaps = null;
        }
    }

    @Override
    public void onConfigurationChanged(@NonNull Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        resetTransformationsAndFit();
        updateImageDisplay();
    }
}

# app/src/main/res/drawable/ic_open_arrow.png
‰PNG

   IHDR         \r¨f   sRGB ®Îé   gAMA  ±üa   	pHYs  Ã  ÃÇo¨d  xIDATx^í+”I…õË•HäJ$‰D"‘H$·‰D"‘HäJ$¹‰İÿŞîš9Ó=ÑÓUİõˆÌø¾sî™G¿ªnVfWD¾ş€t<–z'½—>Jß&ê“ä×Z7ï÷D€$üOº©è_¤Ÿ=úoIé3~I_%7/¤?% XgÒ[ÉßÎ?¢
º…t,?¥Ï’"7Hn˜ àJ|;ï
ÿOTñ2KÇü]ò]Â_ ŒÄ•şô-ªX-JçâÆÀ9€ ÇÑ¯¥/QêI:G7nàÜĞ”Åqò+ésTQ*HçîŞ7$¡®ø¾ş7ª%/~K$î
 [ü-ç,9ÿ„ät‡+¾³á¿¢‹İ—¼¢!€æ¡â_)yGC ÍAÅŸYò’† šÀ]yTü…$oİ8
3}.Z4¿äõ?ÒS°5şFú]¨hYÉ÷¿%æÀ&xŒ{scô{“Êà‡äIR «ào¾õ“Iåá’Œ(„Eñ7Mši¸èP*›%¯Q 0;ï£‹å“ÊÊwä`|[Ùı,½Ş¤2ó¬CÆÀUxşú÷èCù¥²sH@‚.ÂK[1¨§q©=xÈSFó6º˜P»R™z(1Àƒ8qTvŞ¥²õ$tBˆFìé\*c¯`ÌB¥p€E,ÔQD*kïmÀxØáQ}Åä2Ê
Cå/,—ıp@A¨üˆF (T~t+_Ã5 ò£{ò51\Ğ1T~tR¾6†k:„ÊÎÊ×Èp­@GPùÑhùZ®è ò¡ò£Iò5#Ñ4‡÷şŒ
¡sÒµãƒnOìal?ºJº†<w€	DÂ¬>4‹t-y!KŒ5Ä»¨ ºTº¦>î/-ÈÎ‹¨ ºVº¶Şî/1ÈŠ6,ã…“®/z’âD´¨tÑ3'h¾E–Y:forÙÜqW—ÊŒd|Œ
j+éx||‘¼…˜W¾‘—?‡Ç.Ü}ßã³ÄD‰¤ò g 	¯¢ZKú|¯=ÿUz/¹Â.ùÍàî¦QpCÈ³¡ä¿w'†ñ·åêI?}¦w¤u…Ïú®ÂÙiî6|gã‘ùÊÒgù¶ŞkË?õ'Å’&ƒ•d¯%BxÈœÒg8ã›½ÒŸÂoQYíxaÉc	­Œo{›á§÷vÅ÷7i™^;9D !XPò×¹X‰EºÎô¾=Uüch”|¥kp%fß·OïÙsÅ?††`!ÉÓO6–Ãqí¬·şz?ÇÉ[n7îNd±”%?*¼ ³Íï×{9{KÎ¾Qeİ„™$/=.ÄİÓ03ï#Ã§Jïã¥|»O×Í!˜H5ƒä£GnÂŒ¸îê[U½‡ÇŞg¼“s­6¶¢gÉÇW;Ga®ÊúëõşÖw¼ãx-q7p…äŸCî2gàedğXéõîiq ÏÖx¬Å÷ÈS4Nò/+qzñ°V½Ö·ü$d.Ç½#_"oÑyÉ;ßyrı]ÁÅ}şz­‡gr6³$`+JŞ1LøBÜr^4XE¯sFæÅI-Æ\ ùFz"3’^ã}ŒÉ^_È¬A0QòÌk7À&wûéùNöYq®Ãwf$'J½Ü¹£˜”xÒó©üëâä ÀÙ¯sp–IëúëùTşm ˜(ùEnj£/*=—Ê¿-4$¯t†7‘q‘ô\*h&H^y…)pË8ªÛOÏ£òç‚F`¤äƒƒN0j?=Ï]}Tş|¸ ‹p„ä“g£Âg¿Aô·ôóçÅ3-™DtFòˆ\À£&üèyoöO‡Ä°;óÉ'zîpvº¯Cò¤f_·±7É#ç±@<º+=Ç[oA[¤Ú¯1£ä£Åƒ£şô¸×îs‚	ÚÂ1.;? ùS~tàãÈ˜éq2şmCÏÀÉŸÒÓ>8ãO³Ärûøgñ	É›²3=âä…¡ÇØd¡XPäÉŸ’ë¼‹Ì°ô˜ûI‰ûûÁù F
¼)·jĞƒÃ~õƒ}úcö]z‘}‘J>9éG±†Z¿œ¼ë«.yã-êÊvéÿÁÉ¾a²@ò¥ÌÀ '‘–c¯¾şq·.¡@ ùR"ô3Âú©[ âŒ^÷¡’äK‰¯{}èÌª½G’'øÖu=xvâÄ™åWf’/]o*zo‚ˆşÇj©uaÛ±#É“n'¾…}ÿú}şualÀ‘ì‡Ôå˜€{‹~èì˜“w€ê]ò¤ËÅB>¤[:@mümwÑ½J~xWë®ğ¸şƒ[=ıÍ
?p+ItõåxĞï«¿İíÇÒÈpƒóC÷º‡+K~t5.æ`è¯şfYd8fÔ²ğU$?º|0ôW³1D„½D•%?ºè!;hÙõ7±?œ‚\ÀÉ.î”{èo2ÿpŠ{ÉâÊ’]’»İ)F¿Óïç`\ÀÉ¦WÆ:û¯¿K®}“p~ˆ»€Aò¢é¹·Sõ;cşa,Ì$/š"|Ûı§ßÙÆrv·¨*’ÍvŞ&tôÓ»û Láëqe¨*yÑdè|;ùG¿¿Ûÿ`4¯îV‚Ê’MNºÍæêw¶÷‚©x`É@I>4¹FÀnO8ıü¶ÿ`2Ÿ+CEÉmj©°Ûá¿úıõş_ “y~·"T–½Ø[Ò»á¿úé–‹-¾à˜ É‡¦fîúqõóóşO€‹ùû¸2T”|hjÍnø¯~Ò÷×Â˜€Aò¢‰»é]ü¯Ÿ¬õsÁ’|h"°ëÿ×O6ù„¹`SQI>41`³é'Ë}Ã\œÜO²’äC95Zh®ßÒ³WRYò ‰D cæıÃÜ°N€$R±>²Ë`Sîm,SQò!õú7	@–ı‚¹a¹0I¤ŞH×‹v³œ1¤ã`yùŠ’©{×û7½‚	¤æv…©ª’©N v½¿9lÊÁ“%ÜÃ–’› “`InW™®*yr… ûïnWSHGùCåAÊ)öN ²ë,MùİƒäAÊzæ ‹ÀÒ”_$D¤\"ÌÙI6ş€¥ù3ª•$RvµÓÿkñ#ª•4øO&kñ9ª•$Rm±ïe¿I ÂZL6'ÀsÿSQ†®xUŠJ’©Ü9ûOÖ‚D`²İ¶|0, kRzª›ÛX›Ò#}ş{rÀ X›Ò3uş©f2ÖæMT1ªHçÿkoC¸€µ¡' ÉÌ[; ÁÚ”ß1H¤XzÏA ¬]ºÚ[±->-(½8ˆÎ?Eïñ?lEéIA:¯Á±9©×)‡®ùUŒ*Òù§h Ø¶âST1ªÈç¿·a[<`ªb	~(Íë¨bT‘Î?Eja(Eõ Å| fÂV”¨óÿ¶· &¥WÖù§h ¸€­¨Ş ¤X‡“ ¶â¯¨bT‘ÎŸ•¸¡4O¢ŠQE: (@˜[QzF Î?íVá «UŒJl ¨IT)*i° &Q¥¨¤Á€šD•¢’ jUŠJl ¨IT)*i° &Q¥¨¤Á€šD•¢’ jUŠJl ¨IT)*i° &Q¥¨¤Á€šD•¢’ jUŠJl ¨IT)*i° &Q¥¨¤Á€šD•¢’ jUŠJl ¨IT)*i° &Q¥¨¤Á€šD•¢’ jUŠJl ¨IT)*i° &Q¥¨¤Á€Íx&=ßJQ¥¨¤È“•Åy]˜¨©ì?ì/¨Î—èAıJeî‰Ùvx{¸ŸÑ…‚ú“Êú—ôÄpƒs¿£õ%•óË]‰A> s©Œ‰ûáAÈt*•-q?œ…|@‡R™÷ÃhÈt&•'q?L‚|@'RY÷ÃEh\*Câ~¸òKeGÜWC> Q©ÜˆûaÈ4&•q?Ì
ù€F¤²"î‡Ù!Ğ€TFÄı°ä’KåCÜ‹B> ©T6Äı°
ä’IeBÜ«A> ‘TÄı°:ä’Hå@Ü›@>`c©ˆûaSÈl$yOÜ›C>`Ésâ~Hù€•%¿‰û!äV’¼&î‡”XXò˜¸ÒB>`AÉ[â~Hù€…$_‰û¡	ÈÌ,yJÜMA>`&ÉKâ~hò3H÷C³¸Rò¸š†|À…’wÄıĞä&J÷C7˜ yEÜİA>`¤äq?t	ù€3’GÄıĞ5äNHŞ÷C÷$Oˆû¡ä$?ˆû¡äÉâ~(Iù|€< î‡²”ÎèÜ‰û¡<eó:oâ~ Q. s&î¸C™|€Î•¸àˆù #q?À	ºÏèüˆû Û|€Î¸`İåtNÄı #é* s!î˜H7ù q?À4ŸĞ9÷\A³ù ;q?À•4™Ğ1÷ÌDsù /q?ÀŒ4“Ğ±÷,@ú|€‘¸`!RçtlÄı “6 ã"îXtù q?ÀŠ¤ÉèXˆûV&E>@Ç@Ü°›çôùÄı ²Y>@ŸMÜ€ÕóúLâ~€$¬šĞg÷$cµ|€>‡¸ !‹çôÄı ‰Y, ÷&îHÎ"ù ½'q?@#ÌĞû÷4Älù ½q?@ƒ\Ğ{÷4ÊUù ½–¸ q.ÎèuÄı 09 ×÷tÄè|€KÜĞ£òzq?@§œÍèqâ~€9™ĞcÄı ¸—ĞÿˆûŠpĞïÄı Å¸Íè'q?@AŞJ…ãş?şø?á¿läÙbĞ    IEND®B`‚
# app/src/main/res/layout/activity_main.xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <SurfaceView
        android:id="@+id/cameraSurfaceView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_centerInParent="true" />

    <ImageView
        android:id="@+id/imageView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_centerInParent="true" />

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_alignParentBottom="true"
        android:orientation="vertical"
        android:padding="10dp">

        <SeekBar
            android:id="@+id/transparencySeekBar"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:max="100"
            android:progress="100" />

        <Button
            android:id="@+id/pickImageButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/pick_image" />

        <Switch
            android:id="@+id/pencilModeSwitch"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/pencil_mode" />

        <Button
            android:id="@+id/layerSelectButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/select_layers"
            android:visibility="gone" />

        <CheckBox
            android:id="@+id/controlsVisibilityCheckbox"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/show_controls"
            android:checked="true" />

        <CheckBox
            android:id="@+id/hideImageCheckbox"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/hide_image" />

        <Button
            android:id="@+id/saveParametersButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/save_parameters" />

        <Button
            android:id="@+id/loadParametersButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/load_parameters" />

        <Button
            android:id="@+id/switchCameraButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/switch_camera" />
    </LinearLayout>

</RelativeLayout>

# app/src/main/res/layout/dialog_layer_selection.xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="wrap_content">
<!-- Ğ­Ñ‚Ğ¾ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ğ¾Ğµ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ -->
    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/recyclerView"
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />

</androidx.constraintlayout.widget.ConstraintLayout>

# app/src/main/res/layout/item_layer.xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:padding="8dp">

    <TextView
        android:id="@+id/layerText"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:textSize="16sp" />

    <CheckBox
        android:id="@+id/layerCheckBox"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" />
</LinearLayout>

# app/src/main/res/mipmap-hdpi/ic_launcher.png
‰PNG

   IHDR   H   H   o#!   gAMA  ±üa    cHRM  z&  €„  ú   €è  u0  ê`  :˜  pœºQ<   PLTE  ÿÿÿÿ{Ü™,   bKGDÿ-Ş   tIMEé(Ş`íí   IDAT(Ïc`£`ø  Ğ _ø   %tEXtdate:create 2025-04-27T16:18:40+00:00ìA[   %tEXtdate:modify 2025-04-27T16:18:40+00:00ã»    IEND®B`‚
# app/src/main/res/mipmap-hdpi/ic_launcher_round.png
‰PNG

   IHDR   H   H   o#!   gAMA  ±üa    cHRM  z&  €„  ú   €è  u0  ê`  :˜  pœºQ<   PLTE € ÿÿÿ?/O   bKGDÿ-Ş   tIMEé(Ş`íí   IDAT(Ïc`£`ø  Ğ _ø   %tEXtdate:create 2025-04-27T16:18:40+00:00ìA[   %tEXtdate:modify 2025-04-27T16:18:40+00:00ã»    IEND®B`‚
# app/src/main/res/mipmap-mdpi/ic_launcher.png
‰PNG

   IHDR   0   0   mÌkÄ   gAMA  ±üa    cHRM  z&  €„  ú   €è  u0  ê`  :˜  pœºQ<   PLTE  ÿÿÿÿ{Ü™,   bKGDÿ-Ş   tIMEé'Nßğ|   IDATÓc`Ô P §âÚ   %tEXtdate:create 2025-04-27T16:18:39+00:00sÍ   %tEXtdate:modify 2025-04-27T16:18:39+00:00A¯q    IEND®B`‚
# app/src/main/res/mipmap-mdpi/ic_launcher_round.png
‰PNG

   IHDR   0   0   mÌkÄ   gAMA  ±üa    cHRM  z&  €„  ú   €è  u0  ê`  :˜  pœºQ<   PLTE € ÿÿÿ?/O   bKGDÿ-Ş   tIMEé(Ş`íí   IDATÓc`Ô P §âÚ   %tEXtdate:create 2025-04-27T16:18:40+00:00ìA[   %tEXtdate:modify 2025-04-27T16:18:40+00:00ã»    IEND®B`‚
# app/src/main/res/mipmap-xhdpi/ic_launcher.png
‰PNG

   IHDR   `   `   ØVå{   gAMA  ±üa    cHRM  z&  €„  ú   €è  u0  ê`  :˜  pœºQ<   PLTE  ÿÿÿÿ{Ü™,   bKGDÿ-Ş   tIMEé(Ş`íí   IDAT8Ëc`£`Œ‚á	 à Ò÷ît   %tEXtdate:create 2025-04-27T16:18:40+00:00ìA[   %tEXtdate:modify 2025-04-27T16:18:40+00:00ã»    IEND®B`‚
# app/src/main/res/mipmap-xhdpi/ic_launcher_round.png
‰PNG

   IHDR   `   `   ØVå{   gAMA  ±üa    cHRM  z&  €„  ú   €è  u0  ê`  :˜  pœºQ<   PLTE € ÿÿÿ?/O   bKGDÿ-Ş   tIMEé(Ş`íí   IDAT8Ëc`£`Œ‚á	 à Ò÷ît   %tEXtdate:create 2025-04-27T16:18:40+00:00ìA[   %tEXtdate:modify 2025-04-27T16:18:40+00:00ã»    IEND®B`‚
# app/src/main/res/mipmap-xxhdpi/ic_launcher.png
‰PNG

   IHDR         İˆpû   gAMA  ±üa    cHRM  z&  €„  ú   €è  u0  ê`  :˜  pœºQ<   PLTE  ÿÿÿÿ{Ü™,   bKGDÿ-Ş   tIMEé(Ş`íí   IDATHÇíÁ1   Â õOm   à× 
° >4òŸ   %tEXtdate:create 2025-04-27T16:18:40+00:00ìA[   %tEXtdate:modify 2025-04-27T16:18:40+00:00ã»    IEND®B`‚
# app/src/main/res/mipmap-xxhdpi/ic_launcher_round.png
‰PNG

   IHDR         İˆpû   gAMA  ±üa    cHRM  z&  €„  ú   €è  u0  ê`  :˜  pœºQ<   PLTE € ÿÿÿ?/O   bKGDÿ-Ş   tIMEé(Ş`íí   IDATHÇíÁ1   Â õOm   à× 
° >4òŸ   %tEXtdate:create 2025-04-27T16:18:40+00:00ìA[   %tEXtdate:modify 2025-04-27T16:18:40+00:00ã»    IEND®B`‚
# app/src/main/res/mipmap-xxxhdpi/ic_launcher.png
‰PNG

   IHDR   À   À   hşD   gAMA  ±üa    cHRM  z&  €„  ú   €è  u0  ê`  :˜  pœºQ<   PLTE  ÿÿÿÿ{Ü™,   bKGDÿ-Ş   tIMEé(Ş`íí   IDATXÃíÁ1   Â õOm     à× À şŸR   %tEXtdate:create 2025-04-27T16:18:40+00:00ìA[   %tEXtdate:modify 2025-04-27T16:18:40+00:00ã»    IEND®B`‚
# app/src/main/res/mipmap-xxxhdpi/ic_launcher_round.png
‰PNG

   IHDR   À   À   hşD   gAMA  ±üa    cHRM  z&  €„  ú   €è  u0  ê`  :˜  pœºQ<   PLTE € ÿÿÿ?/O   bKGDÿ-Ş   tIMEé)©gİ{   IDATXÃíÁ1   Â õOm     à× À şŸR   %tEXtdate:create 2025-04-27T16:18:41+00:00J6P³   %tEXtdate:modify 2025-04-27T16:18:41+00:00;kè    IEND®B`‚
# app/src/main/res/values/strings.xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">HelloWorld</string>
    <string name="pick_image">Pick Image</string>
    <string name="show_controls">Show Controls</string>
    <string name="pencil_mode">Pencil Mode</string>
    <string name="select_layers">Select Layers</string>
    <string name="hide_image">Hide Image</string>
    <string name="save_parameters">Save Parameters</string>
    <string name="load_parameters">Load Parameters</string>
    <string name="switch_camera">Switch Camera</string>
    <string name="layer_selection_title">Select Pencil Layers</string>
</resources>

# app/src/main/res/values/themes.xml
<?xml version="1.0" encoding="utf-8"?>
<resources xmlns:tools="http://schemas.android.com/tools">
    <style name="Theme.HelloWorld" parent="Theme.AppCompat.Light.DarkActionBar">
        <item name="colorPrimary">@android:color/black</item>
        <item name="colorPrimaryDark">@android:color/black</item>
        <item name="colorAccent">@android:color/holo_blue_light</item>
    </style>
</resources>

# app/src/main/res/xml/backup_rules.xml
<?xml version="1.0" encoding="utf-8"?>
<full-backup-content>
    <include domain="file" path="." />
</full-backup-content>

# app/src/main/res/xml/data_extraction_rules.xml
<?xml version="1.0" encoding="utf-8"?>
<data-extraction-rules>
    <cloud-backup>
        <include domain="file" />
    </cloud-backup>
</data-extraction-rules>

# app/src/main/AndroidManifest.xml:
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">

    <!-- Ğ Ğ°Ğ·Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ -->
    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.READ_MEDIA_IMAGES" />

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.HelloWorld">
        <activity
            android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>

