===== File: ./.gitattributes =====
*.jpg filter=lfs diff=lfs merge=lfs -text
*.zip filter=lfs diff=lfs merge=lfs -text


===== File: ./.gitignore =====
# Gradle файлы
.gradle/
build/
*/build/

# Локальные настройки
local.properties

# Сгенерированные файлы
*.apk
*.ap_
*.aab

# Кэш и временные файлы
.idea/
*.iml

# Логи
*.log


===== File: ./README.md =====
# android-hello-world-app
File: app-debug.apk
# My Android App


===== File: ./.github/workflows/android-ci.yml =====
name: Android CI Build

on:
  push:
    branches: [ "main", "master" ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest # Важно: Запуск на x86-64 сервере GitHub

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
         # cache: gradle

      # Настройка Android SDK на сервере GitHub
      - name: Setup Android SDK
        run: |
          mkdir -p $HOME/android-sdk
          export ANDROID_HOME=$HOME/android-sdk
          # Скачиваем свежие Command-line tools
          wget https://dl.google.com/android/repository/commandlinetools-linux-11076708_latest.zip -O cmdline-tools.zip
          unzip cmdline-tools.zip -d $ANDROID_HOME/cmdline-tools
          mv $ANDROID_HOME/cmdline-tools/cmdline-tools $ANDROID_HOME/cmdline-tools/latest
          export PATH=$PATH:$ANDROID_HOME/cmdline-tools/latest/bin:$ANDROID_HOME/platform-tools
          echo "y" | sdkmanager --licenses > /dev/null || true # Принимаем лицензии
          # Устанавливаем платформу и Build Tools (версии, которые работают на x86-64)
          sdkmanager "platforms;android-34" "build-tools;34.0.0"
        shell: bash

      - name: Grant execute permission for gradlew
        run: chmod +x gradlew
        shell: bash

      # ДОБАВЛЕН НОВЫЙ ШАГ ОЧИСТКИ:
      - name: Clean Gradle project
        run: ./gradlew clean


      # Запуск сборки Debug APK
      - name: Build with Gradle
        run: ./gradlew assembleDebug
        shell: bash

      # Загрузка APK как артефакта
      - name: Upload Debug APK
        uses: actions/upload-artifact@v4
        with:
          name: app-debug-apk
          path: app/build/outputs/apk/debug/app-debug.apk


===== File: ./Build =====


===== File: ./app/build.gradle =====
// App-level build.gradle (app module)
plugins {
    id 'com.android.application'
}

android {
    namespace 'com.example.helloworld'
    compileSdk 33 // Изменяем на 33 для совместимости с AGP 8.1.0

    defaultConfig {
        applicationId "com.example.helloworld"
        minSdk 24
        targetSdk 28
        versionCode 1
        versionName "1.0"
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
}

dependencies {
    implementation 'androidx.appcompat:appcompat:1.6.1'
    implementation 'androidx.recyclerview:recyclerview:1.3.2'
    implementation 'androidx.constraintlayout:constraintlayout:2.1.4'
}


===== File: ./app/src/main/AndroidManifest.xml =====
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.AppCompat.Light.DarkActionBar">
        <activity
            android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>


===== File: ./app/src/main/java/com/example/helloworld/LayerAdapter.java =====
package com.example.helloworld;

import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.CheckBox; // Используем CheckBox
import android.widget.TextView;  // Используем TextView
import androidx.annotation.NonNull;
import androidx.recyclerview.widget.RecyclerView;

public class LayerAdapter extends RecyclerView.Adapter<LayerAdapter.ViewHolder> {

    private final String[] layers;
    private final boolean[] visibility;
    private final OnLayerVisibilityChangedListener listener;

    // Интерфейс для обратного вызова при изменении видимости слоя
    public interface OnLayerVisibilityChangedListener {
        void onLayerVisibilityChanged(int position, boolean isVisible);
    }

    // Конструктор адаптера
    public LayerAdapter(String[] layers, boolean[] visibility, OnLayerVisibilityChangedListener listener) {
        this.layers = layers;
        this.visibility = visibility;
        this.listener = listener;
    }

    // Создание нового ViewHolder (используем item_layer.xml)
    @NonNull
    @Override
    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        // Используем ваш кастомный макет item_layer.xml
        View view = LayoutInflater.from(parent.getContext())
                .inflate(R.layout.item_layer, parent, false); // *** ИЗМЕНЕНО ЗДЕСЬ ***
        return new ViewHolder(view);
    }

    // Привязка данных к ViewHolder
    @Override
    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
        // Устанавливаем текст слоя в TextView
        holder.layerText.setText(layers[position]); // *** ИЗМЕНЕНО ЗДЕСЬ ***

        // Сначала удаляем слушатель, чтобы он не сработал при установке состояния
        holder.layerCheckBox.setOnCheckedChangeListener(null);
        // Устанавливаем состояние CheckBox
        holder.layerCheckBox.setChecked(visibility[position]); // *** ИЗМЕНЕНО ЗДЕСЬ ***

        // Устанавливаем слушатель изменения состояния CheckBox
        holder.layerCheckBox.setOnCheckedChangeListener((buttonView, isChecked) -> { // *** ИЗМЕНЕНО ЗДЕСЬ ***
            // Обновляем массив видимости
            int currentPosition = holder.getAdapterPosition(); // Получаем актуальную позицию
             if (currentPosition != RecyclerView.NO_POSITION) { // Проверяем, что позиция валидна
                 visibility[currentPosition] = isChecked;
                 // Уведомляем MainActivity через интерфейс
                 if (listener != null) {
                     listener.onLayerVisibilityChanged(currentPosition, isChecked);
                 }
             }
        });
    }

    // Возвращаем общее количество элементов
    @Override
    public int getItemCount() {
        // Проверяем на null на всякий случай
        return (layers != null) ? layers.length : 0;
    }

    // Класс ViewHolder, хранящий ссылки на View одного элемента списка
    static class ViewHolder extends RecyclerView.ViewHolder {
        TextView layerText;     // *** ИЗМЕНЕНО ЗДЕСЬ *** Ссылка на TextView из item_layer.xml
        CheckBox layerCheckBox; // *** ИЗМЕНЕНО ЗДЕСЬ *** Ссылка на CheckBox из item_layer.xml

        ViewHolder(View itemView) {
            super(itemView);
            // Находим View по их ID из item_layer.xml
            layerText = itemView.findViewById(R.id.layerText);       // *** ИЗМЕНЕНО ЗДЕСЬ ***
            layerCheckBox = itemView.findViewById(R.id.layerCheckBox); // *** ИЗМЕНЕНО ЗДЕСЬ ***
        }
    }
}


===== File: ./app/src/main/java/com/example/helloworld/MainActivity.java =====
package com.example.helloworld;

import android.Manifest;
import android.app.Dialog;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.res.Configuration;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.ColorMatrix;
import android.graphics.ColorMatrixColorFilter;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.hardware.camera2.CameraAccessException;
import android.hardware.camera2.CameraCaptureSession;
import android.hardware.camera2.CameraCharacteristics;
import android.hardware.camera2.CameraDevice;
import android.hardware.camera2.CameraManager;
import android.hardware.camera2.CaptureRequest;
import android.hardware.camera2.TotalCaptureResult;
import android.media.Image;
import android.media.ImageReader;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.HandlerThread;
import android.provider.MediaStore;
import android.util.Log;
import android.util.Size;
import android.view.MotionEvent;
import android.view.ScaleGestureDetector;
import android.view.Surface;
import android.view.SurfaceHolder;
import android.view.SurfaceView;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.ImageView;
import android.widget.SeekBar;
import android.widget.Switch;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.app.ActivityCompat;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class MainActivity extends AppCompatActivity implements LayerAdapter.OnLayerVisibilityChangedListener {

    private static final String TAG = "MainActivity";
    private static final int REQUEST_CAMERA_PERMISSION = 100;
    private static final int REQUEST_STORAGE_PERMISSION = 101;
    private static final int PICK_IMAGE_REQUEST = 1;

    private SurfaceView cameraSurfaceView;
    private ImageView imageView;
    private SeekBar transparencySeekBar;
    private Button pickImageButton;
    private Switch pencilModeSwitch;
    private Button layerSelectButton;
    private CheckBox controlsVisibilityCheckbox;
    private CheckBox hideImageCheckbox;
    private Button saveParametersButton;
    private Button loadParametersButton;
    private Button switchCameraButton;
    private Button captureButton;

    private CameraDevice cameraDevice;
    private CameraCaptureSession cameraCaptureSession;
    private CaptureRequest.Builder previewRequestBuilder;
    private String cameraId;
    private Size previewSize;
    private HandlerThread backgroundThread;
    private Handler backgroundHandler;
    private final Object cameraOpenCloseLock = new Object();
    private volatile boolean isSurfaceAvailable = false;
    private volatile boolean isCameraPendingOpen = false;
    private volatile boolean isCameraOpen = false;

    private Bitmap originalBitmap;
    private Bitmap pencilBitmap;
    private Bitmap[] layerBitmaps;
    private boolean[] layerVisibility;
    private Matrix matrix = new Matrix();
    private float scaleFactor = 1.0f;
    private float rotationAngle = 0.0f;
    private boolean isPencilMode = false;
    private boolean isImageVisible = true;
    private ScaleGestureDetector scaleGestureDetector;
    private float lastTouchX, lastTouchY;
    private boolean isDragging = false;

    private String[] cameraIds;
    private int currentCameraIndex = 0;

    private ImageReader imageReader;
    private static final int CAPTURE_WIDTH = 1280;
    private static final int CAPTURE_HEIGHT = 720;

    private static final String[] PENCIL_HARDNESS = {
            "9H", "8H", "7H", "6H", "5H", "4H", "3H", "2H", "H", "F",
            "HB", "B", "2B", "3B", "4B", "5B", "6B", "7B", "8B", "9B"
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        cameraSurfaceView = findViewById(R.id.cameraSurfaceView);
        imageView = findViewById(R.id.imageView);
        transparencySeekBar = findViewById(R.id.transparencySeekBar);
        pickImageButton = findViewById(R.id.pickImageButton);
        pencilModeSwitch = findViewById(R.id.pencilModeSwitch);
        layerSelectButton = findViewById(R.id.layerSelectButton);
        controlsVisibilityCheckbox = findViewById(R.id.controlsVisibilityCheckbox);
        hideImageCheckbox = findViewById(R.id.hideImageCheckbox);
        saveParametersButton = findViewById(R.id.saveParametersButton);
        loadParametersButton = findViewById(R.id.loadParametersButton);
        switchCameraButton = findViewById(R.id.switchCameraButton);
        captureButton = findViewById(R.id.captureButton);

        scaleGestureDetector = new ScaleGestureDetector(this, new ScaleGestureDetector.SimpleOnScaleGestureListener() {
            @Override
            public boolean onScale(ScaleGestureDetector detector) {
                scaleFactor *= detector.getScaleFactor();
                scaleFactor = Math.max(0.1f, Math.min(scaleFactor, 5.0f));
                matrix.postScale(detector.getScaleFactor(), detector.getScaleFactor(), detector.getFocusX(), detector.getFocusY());
                applyTransformations();
                return true;
            }
        });

        imageView.setOnTouchListener((v, event) -> {
            scaleGestureDetector.onTouchEvent(event);
            switch (event.getAction()) {
                case MotionEvent.ACTION_DOWN:
                    lastTouchX = event.getX();
                    lastTouchY = event.getY();
                    isDragging = true;
                    break;
                case MotionEvent.ACTION_MOVE:
                    if (isDragging) {
                        float dx = event.getX() - lastTouchX;
                        float dy = event.getY() - lastTouchY;
                        matrix.postTranslate(dx, dy);
                        applyTransformations();
                        lastTouchX = event.getX();
                        lastTouchY = event.getY();
                    }
                    break;
                case MotionEvent.ACTION_UP:
                case MotionEvent.ACTION_CANCEL:
                    isDragging = false;
                    break;
            }
            return true;
        });

        cameraSurfaceView.getHolder().addCallback(new SurfaceHolder.Callback() {
            @Override
            public void surfaceCreated(SurfaceHolder holder) {
                Log.d(TAG, "Surface created");
                isSurfaceAvailable = true;
                if (isCameraPendingOpen && !isCameraOpen) {
                    openCamera();
                    isCameraPendingOpen = false;
                }
            }

            @Override
            public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
                Log.d(TAG, "Surface changed: " + width + "x" + height);
                adjustSurfaceViewAspectRatioWithCropping(width, height);
                if (cameraDevice != null && isSurfaceAvailable) {
                    closeCameraPreviewSession();
                    previewSize = chooseOptimalPreviewSize(getPreviewSizes(), width, height);
                    createCameraPreviewSession();
                }
            }

            @Override
            public void surfaceDestroyed(SurfaceHolder holder) {
                Log.d(TAG, "Surface destroyed");
                isSurfaceAvailable = false;
                closeCamera();
            }
        });

        transparencySeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
            @Override
            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
                setImageAlpha(progress);
            }

            @Override
            public void onStartTrackingTouch(SeekBar seekBar) {}

            @Override
            public void onStopTrackingTouch(SeekBar seekBar) {}
        });

        pickImageButton.setOnClickListener(v -> pickImage());

        pencilModeSwitch.setOnCheckedChangeListener((buttonView, isChecked) -> {
            isPencilMode = isChecked;
            layerSelectButton.setVisibility(isChecked ? View.VISIBLE : View.GONE);
            if (isPencilMode) {
                processPencilEffect();
            }
            updateImageDisplay();
        });

        layerSelectButton.setOnClickListener(v -> showLayerSelectionDialog());

        controlsVisibilityCheckbox.setOnCheckedChangeListener((buttonView, isChecked) -> {
            int visibility = isChecked ? View.VISIBLE : View.GONE;
            transparencySeekBar.setVisibility(visibility);
            pickImageButton.setVisibility(visibility);
            pencilModeSwitch.setVisibility(visibility);
            layerSelectButton.setVisibility(isPencilMode && isChecked ? View.VISIBLE : View.GONE);
            hideImageCheckbox.setVisibility(visibility);
            saveParametersButton.setVisibility(visibility);
            loadParametersButton.setVisibility(visibility);
            switchCameraButton.setVisibility(visibility);
            captureButton.setVisibility(visibility);
        });

        hideImageCheckbox.setOnCheckedChangeListener((buttonView, isChecked) -> {
            isImageVisible = !isChecked;
            updateImageDisplay();
        });

        saveParametersButton.setOnClickListener(v -> saveParameters());

        loadParametersButton.setOnClickListener(v -> loadParameters());

        switchCameraButton.setOnClickListener(v -> switchCamera());

        captureButton.setOnClickListener(v -> captureImage());

        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.CAMERA}, REQUEST_CAMERA_PERMISSION);
        } else {
            isCameraPendingOpen = true;
        }

        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED ||
                ActivityCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE}, REQUEST_STORAGE_PERMISSION);
        }

        CameraManager manager = (CameraManager) getSystemService(CAMERA_SERVICE);
        try {
            cameraIds = manager.getCameraIdList();
            if (cameraIds.length > 0) {
                cameraId = cameraIds[0];
            }
        } catch (CameraAccessException e) {
            Log.e(TAG, "Error accessing camera list", e);
            Toast.makeText(this, "Cannot access cameras", Toast.LENGTH_LONG).show();
        }

        layerVisibility = new boolean[20];
        Arrays.fill(layerVisibility, true);
    }

    private void adjustSurfaceViewAspectRatioWithCropping(int width, int height) {
        if (previewSize == null) {
            Log.e(TAG, "Preview size is null, cannot adjust aspect ratio");
            return;
        }

        float previewRatio = (float) previewSize.getWidth() / previewSize.getHeight();
        float viewRatio = (float) width / height;

        cameraSurfaceView.setScaleX(1.0f);
        cameraSurfaceView.setScaleY(1.0f);

        float scaleX, scaleY;
        if (previewRatio > viewRatio) {
            scaleY = 1.0f;
            scaleX = previewRatio / viewRatio;
        } else {
            scaleX = 1.0f;
            scaleY = viewRatio / previewRatio;
        }

        cameraSurfaceView.setScaleX(scaleX);
        cameraSurfaceView.setScaleY(scaleY);

        cameraSurfaceView.setPivotX(width / 2f);
        cameraSurfaceView.setPivotY(height / 2f);

        ViewGroup.LayoutParams params = cameraSurfaceView.getLayoutParams();
        params.width = width;
        params.height = height;
        cameraSurfaceView.setLayoutParams(params);

        cameraSurfaceView.requestLayout();
        Log.d(TAG, "Adjusted SurfaceView: width=" + width + ", height=" + height +
                ", previewRatio=" + previewRatio + ", scaleX=" + scaleX + ", scaleY=" + scaleY);
    }

    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
        if (requestCode == REQUEST_CAMERA_PERMISSION) {
            if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                if (isSurfaceAvailable && !isCameraOpen) {
                    openCamera();
                } else {
                    isCameraPendingOpen = true;
                }
            } else {
                Toast.makeText(this, "Camera permission is required", Toast.LENGTH_LONG).show();
                finish();
            }
        } else if (requestCode == REQUEST_STORAGE_PERMISSION) {
            if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                // Permission granted
            } else {
                Toast.makeText(this, "Storage permission is required", Toast.LENGTH_LONG).show();
            }
        }
    }

    private void startBackgroundThread() {
        if (backgroundThread == null) {
            backgroundThread = new HandlerThread("CameraBackground");
            backgroundThread.start();
            backgroundHandler = new Handler(backgroundThread.getLooper());
        }
    }

    private void stopBackgroundThread() {
        if (backgroundThread != null) {
            backgroundThread.quitSafely();
            try {
                backgroundThread.join();
                backgroundThread = null;
                backgroundHandler = null;
            } catch (InterruptedException e) {
                Log.e(TAG, "Error stopping background thread", e);
            }
        }
    }

    private void openCamera() {
        if (!isSurfaceAvailable || isCameraOpen) {
            Log.d(TAG, "Surface not available or camera already open, setting pending open");
            isCameraPendingOpen = true;
            return;
        }

        startBackgroundThread();
        CameraManager manager = (CameraManager) getSystemService(CAMERA_SERVICE);
        try {
            if (cameraId == null) {
                cameraId = manager.getCameraIdList()[0];
            }
            CameraCharacteristics characteristics = manager.getCameraCharacteristics(cameraId);
            Size[] previewSizes = characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP)
                    .getOutputSizes(SurfaceHolder.class);
            previewSize = chooseOptimalPreviewSize(previewSizes, cameraSurfaceView.getWidth(), cameraSurfaceView.getHeight());

            imageReader = ImageReader.newInstance(CAPTURE_WIDTH, CAPTURE_HEIGHT, android.graphics.ImageFormat.JPEG, 2);
            imageReader.setOnImageAvailableListener(reader -> {
                Image image = reader.acquireLatestImage();
                if (image != null) {
                    Bitmap bitmap = imageToBitmap(image);
                    image.close();
                    if (bitmap != null) {
                        processCapturedImage(bitmap);
                    }
                }
            }, backgroundHandler);

            if (ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {
                return;
            }
            synchronized (cameraOpenCloseLock) {
                isCameraOpen = true;
                manager.openCamera(cameraId, new CameraDevice.StateCallback() {
                    @Override
                    public void onOpened(@NonNull CameraDevice camera) {
                        cameraDevice = camera;
                        if (isSurfaceAvailable) {
                            createCameraPreviewSession();
                        } else {
                            Log.d(TAG, "Surface not available after camera opened, closing camera");
                            closeCamera();
                        }
                        synchronized (cameraOpenCloseLock) {
                            cameraOpenCloseLock.notify();
                        }
                    }

                    @Override
                    public void onDisconnected(@NonNull CameraDevice camera) {
                        synchronized (cameraOpenCloseLock) {
                            cameraOpenCloseLock.notify();
                        }
                        camera.close();
                        cameraDevice = null;
                        isCameraOpen = false;
                    }

                    @Override
                    public void onError(@NonNull CameraDevice camera, int error) {
                        synchronized (cameraOpenCloseLock) {
                            cameraOpenCloseLock.notify();
                        }
                        camera.close();
                        cameraDevice = null;
                        isCameraOpen = false;
                        Toast.makeText(MainActivity.this, "Camera error: " + error, Toast.LENGTH_LONG).show();
                    }
                }, backgroundHandler);
            }
        } catch (CameraAccessException e) {
            Log.e(TAG, "Cannot access camera", e);
            Toast.makeText(this, "Cannot access camera", Toast.LENGTH_LONG).show();
            isCameraOpen = false;
        }
    }

    private Size[] getPreviewSizes() {
        try {
            CameraManager manager = (CameraManager) getSystemService(CAMERA_SERVICE);
            CameraCharacteristics characteristics = manager.getCameraCharacteristics(cameraId);
            return characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP)
                    .getOutputSizes(SurfaceHolder.class);
        } catch (CameraAccessException e) {
            Log.e(TAG, "Error getting preview sizes", e);
            return new Size[]{new Size(1280, 720)};
        }
    }

    private Size chooseOptimalPreviewSize(Size[] choices, int viewWidth, int viewHeight) {
        if (choices == null || choices.length == 0) {
            Log.e(TAG, "No preview sizes available, using default");
            return new Size(1280, 720);
        }

        double targetRatio = (viewWidth > 0 && viewHeight > 0) ? (double) viewWidth / viewHeight : 4.0 / 3.0;

        Size optimalSize = null;
        double minDiff = Double.MAX_VALUE;
        int maxArea = 0;

        for (Size size : choices) {
            double ratio = (double) size.getWidth() / size.getHeight();
            int area = size.getWidth() * size.getHeight();
            double ratioDiff = Math.abs(ratio - targetRatio);
            if (ratioDiff < minDiff || (ratioDiff == minDiff && area > maxArea)) {
                optimalSize = size;
                minDiff = ratioDiff;
                maxArea = area;
            }
        }

        if (optimalSize == null) {
            optimalSize = choices[0];
        }

        Log.d(TAG, "Chosen preview size: " + optimalSize.getWidth() + "x" + optimalSize.getHeight() +
                ", targetRatio=" + targetRatio);
        return optimalSize;
    }

    private void createCameraPreviewSession() {
        if (!isSurfaceAvailable || cameraDevice == null || !isCameraOpen) {
            Log.d(TAG, "Cannot create preview session: Surface not available, cameraDevice is null, or camera is closed");
            return;
        }

        try {
            SurfaceHolder holder = cameraSurfaceView.getHolder();
            Surface surface = holder.getSurface();
            if (!surface.isValid()) {
                Log.d(TAG, "Surface is not valid, aborting preview session creation");
                return;
            }

            previewRequestBuilder = cameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
            previewRequestBuilder.addTarget(surface);

            List<Surface> surfaces = new ArrayList<>();
            surfaces.add(surface);
            surfaces.add(imageReader.getSurface());

            cameraDevice.createCaptureSession(surfaces, new CameraCaptureSession.StateCallback() {
                @Override
                public void onConfigured(@NonNull CameraCaptureSession session) {
                    if (cameraDevice == null || !isSurfaceAvailable || !isCameraOpen) {
                        Log.d(TAG, "Camera device closed, surface not available, or camera not open during session configuration");
                        session.close();
                        return;
                    }
                    cameraCaptureSession = session;
                    try {
                        previewRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);
                        cameraCaptureSession.setRepeatingRequest(previewRequestBuilder.build(), null, backgroundHandler);
                        Log.d(TAG, "Camera preview session started");
                    } catch (CameraAccessException e) {
                        Log.e(TAG, "Error setting up camera preview", e);
                    } catch (IllegalStateException e) {
                        Log.e(TAG, "Session already closed during setRepeatingRequest", e);
                    }
                }

                @Override
                public void onConfigureFailed(@NonNull CameraCaptureSession session) {
                    Toast.makeText(MainActivity.this, "Failed to configure camera preview", Toast.LENGTH_LONG).show();
                }
            }, backgroundHandler);
        } catch (CameraAccessException e) {
            Log.e(TAG, "Error creating camera preview session", e);
        }
    }

    private void closeCameraPreviewSession() {
        if (cameraCaptureSession != null) {
            cameraCaptureSession.close();
            cameraCaptureSession = null;
        }
    }

    private void closeCamera() {
        synchronized (cameraOpenCloseLock) {
            closeCameraPreviewSession();
            if (cameraDevice != null) {
                cameraDevice.close();
                cameraDevice = null;
            }
            if (imageReader != null) {
                imageReader.close();
                imageReader = null;
            }
            isCameraOpen = false;
        }
        stopBackgroundThread();
    }

    private void switchCamera() {
        CameraManager manager = (CameraManager) getSystemService(CAMERA_SERVICE);
        try {
            closeCamera();
            currentCameraIndex = (currentCameraIndex + 1) % cameraIds.length;
            cameraId = cameraIds[currentCameraIndex];
            if (isSurfaceAvailable && !isCameraOpen) {
                openCamera();
            } else {
                isCameraPendingOpen = true;
            }
        } catch (Exception e) {
            Log.e(TAG, "Error switching camera", e);
            Toast.makeText(this, "Error switching camera", Toast.LENGTH_LONG).show();
        }
    }

    private void captureImage() {
        if (cameraDevice == null || cameraCaptureSession == null) {
            Log.e(TAG, "Cannot capture image: camera not initialized");
            return;
        }

        try {
            CaptureRequest.Builder captureBuilder = cameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);
            captureBuilder.addTarget(imageReader.getSurface());
            captureBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);

            cameraCaptureSession.capture(captureBuilder.build(), new CameraCaptureSession.CaptureCallback() {
                @Override
                public void onCaptureCompleted(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull TotalCaptureResult result) {
                    Log.d(TAG, "Image captured successfully");
                }
            }, backgroundHandler);
        } catch (CameraAccessException e) {
            Log.e(TAG, "Error capturing image", e);
            Toast.makeText(this, "Error capturing image", Toast.LENGTH_LONG).show();
        }
    }

    private Bitmap imageToBitmap(Image image) {
        ByteBuffer buffer = image.getPlanes()[0].getBuffer();
        byte[] bytes = new byte[buffer.remaining()];
        buffer.get(bytes);
        return BitmapFactory.decodeByteArray(bytes, 0, bytes.length);
    }

    private void processCapturedImage(Bitmap bitmap) {
        // Упрощённая обработка без OpenCV: просто сохраняем изображение
        runOnUiThread(() -> {
            if (originalBitmap != null && !originalBitmap.isRecycled()) {
                originalBitmap.recycle();
            }
            originalBitmap = bitmap.copy(Bitmap.Config.ARGB_8888, true);
            resetTransformationsAndFit();
            updateImageDisplay();
        });
    }

    private void pickImage() {
        Intent intent = new Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI);
        startActivityForResult(intent, PICK_IMAGE_REQUEST);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if (requestCode == PICK_IMAGE_REQUEST && resultCode == RESULT_OK && data != null) {
            Uri imageUri = data.getData();
            try {
                if (originalBitmap != null && !originalBitmap.isRecycled()) {
                    originalBitmap.recycle();
                }
                originalBitmap = MediaStore.Images.Media.getBitmap(getContentResolver(), imageUri);
                resetTransformationsAndFit();
                layerVisibility = new boolean[20];
                Arrays.fill(layerVisibility, true);
                if (isPencilMode) {
                    processPencilEffect();
                }
                updateImageDisplay();
            } catch (IOException e) {
                Log.e(TAG, "Error loading image", e);
                Toast.makeText(this, "Error loading image", Toast.LENGTH_LONG).show();
            }
        }
    }

    private void resetTransformationsAndFit() {
        if (originalBitmap == null || imageView.getWidth() == 0 || imageView.getHeight() == 0) {
            matrix.reset();
            scaleFactor = 1.0f;
            rotationAngle = 0.0f;
            imageView.setImageMatrix(matrix);
            return;
        }

        matrix.reset();

        float viewWidth = imageView.getWidth();
        float viewHeight = imageView.getHeight();
        float bmpWidth = originalBitmap.getWidth();
        float bmpHeight = originalBitmap.getHeight();

        float scaleX = viewWidth / bmpWidth;
        float scaleY = viewHeight / bmpHeight;
        float initialScale = Math.min(scaleX, scaleY);

        float scaledBmpWidth = bmpWidth * initialScale;
        float scaledBmpHeight = bmpHeight * initialScale;
        float initialTranslateX = (viewWidth - scaledBmpWidth) / 2f;
        float initialTranslateY = (viewHeight - scaledBmpHeight) / 2f;

        matrix.postScale(initialScale, initialScale);
        matrix.postTranslate(initialTranslateX, initialTranslateY);

        imageView.post(() -> {
            imageView.setImageMatrix(matrix);
            imageView.invalidate();
            scaleFactor = initialScale;
            rotationAngle = 0.0f;
        });
    }

    private void applyTransformations() {
        imageView.setImageMatrix(matrix);
        imageView.invalidate();
        Log.d(TAG, "Transformations applied: scale=" + scaleFactor);
    }

    private void setImageAlpha(int progress) {
        float alpha = progress / 100.0f;
        imageView.setAlpha(alpha);
        imageView.invalidate();
        Log.d(TAG, "Image alpha set to: " + alpha);
    }

    private void processPencilEffect() {
        Log.d(TAG, "Processing pencil effect");
        if (originalBitmap == null) {
            Log.d(TAG, "Original bitmap is null, cannot process pencil effect");
            return;
        }

        if (pencilBitmap != null && !pencilBitmap.isRecycled()) {
            pencilBitmap.recycle();
            pencilBitmap = null;
        }
        if (layerBitmaps != null) {
            for (Bitmap layer : layerBitmaps) {
                if (layer != null && !layer.isRecycled()) {
                    layer.recycle();
                }
            }
            layerBitmaps = null;
        }

        try {
            pencilBitmap = Bitmap.createBitmap(originalBitmap.getWidth(), originalBitmap.getHeight(), Bitmap.Config.ARGB_8888);
            if (pencilBitmap == null) {
                Log.e(TAG, "Failed to create pencilBitmap");
                return;
            }
            Canvas canvas = new Canvas(pencilBitmap);
            Paint paint = new Paint();
            ColorMatrix colorMatrix = new ColorMatrix();
            colorMatrix.setSaturation(0); // Преобразование в чёрно-белое
            ColorMatrixColorFilter filter = new ColorMatrixColorFilter(colorMatrix);
            paint.setColorFilter(filter);
            canvas.drawBitmap(originalBitmap, 0, 0, paint);

            layerBitmaps = new Bitmap[20];
            for (int i = 0; i < 20; i++) {
                layerBitmaps[i] = Bitmap.createBitmap(originalBitmap.getWidth(), originalBitmap.getHeight(), Bitmap.Config.ARGB_8888);
                if (layerBitmaps[i] == null) {
                    Log.e(TAG, "Failed to create layerBitmap[" + i + "]");
                    return;
                }
                layerBitmaps[i].eraseColor(Color.TRANSPARENT);
            }

            int[] pixels = new int[originalBitmap.getWidth() * originalBitmap.getHeight()];
            pencilBitmap.getPixels(pixels, 0, originalBitmap.getWidth(), 0, 0, originalBitmap.getWidth(), originalBitmap.getHeight());

            for (int i = 0; i < pixels.length; i++) {
                int gray = Color.red(pixels[i]); // Простое преобразование в градации серого
                int layerIndex = getLayerIndex(gray);
                if (layerIndex >= 0 && layerIndex < 20 && layerBitmaps[layerIndex] != null) {
                    layerBitmaps[layerIndex].setPixel(i % originalBitmap.getWidth(), i / originalBitmap.getWidth(), pixels[i]);
                }
            }
            Log.d(TAG, "Pencil effect processed successfully");
        } catch (OutOfMemoryError e) {
            Log.e(TAG, "OutOfMemoryError in processPencilEffect", e);
            Toast.makeText(this, "Not enough memory for pencil effect", Toast.LENGTH_LONG).show();
            pencilBitmap = null;
            layerBitmaps = null;
        }
    }

    private int getLayerIndex(int grayValue) {
        return grayValue / (256 / 20);
    }

    private void updateImageDisplay() {
        Log.d(TAG, "updateImageDisplay: isPencilMode=" + isPencilMode + ", isImageVisible=" + isImageVisible);
        if (originalBitmap == null || !isImageVisible) {
            Log.d(TAG, "updateImageDisplay: originalBitmap is null or image is not visible");
            imageView.setImageBitmap(null);
            imageView.setVisibility(View.INVISIBLE);
            imageView.invalidate();
            return;
        }

        if (isPencilMode) {
            Log.d(TAG, "updateImageDisplay: Processing pencil mode");
            if (pencilBitmap == null || layerBitmaps == null) {
                processPencilEffect();
            }

            if (pencilBitmap == null || layerBitmaps == null) {
                Log.d(TAG, "updateImageDisplay: pencilBitmap or layerBitmaps is null");
                imageView.setImageBitmap(null);
                imageView.setVisibility(View.INVISIBLE);
                imageView.invalidate();
                return;
            }

            Bitmap resultBitmap = Bitmap.createBitmap(originalBitmap.getWidth(), originalBitmap.getHeight(), Bitmap.Config.ARGB_8888);
            if (resultBitmap == null) {
                Log.d(TAG, "updateImageDisplay: Failed to create resultBitmap");
                imageView.setImageBitmap(null);
                imageView.setVisibility(View.INVISIBLE);
                imageView.invalidate();
                return;
            }
            Canvas canvas = new Canvas(resultBitmap);
            canvas.drawColor(Color.TRANSPARENT);

            for (int i = 0; i < layerBitmaps.length; i++) {
                if (layerVisibility[i] && layerBitmaps[i] != null && !layerBitmaps[i].isRecycled()) {
                    canvas.drawBitmap(layerBitmaps[i], 0, 0, null);
                }
            }

            imageView.setImageBitmap(resultBitmap);
            setImageAlpha(transparencySeekBar.getProgress());
            imageView.setVisibility(View.VISIBLE);
            imageView.post(() -> {
                imageView.setImageMatrix(matrix);
                imageView.invalidate();
            });
            Log.d(TAG, "updateImageDisplay: Pencil mode applied");
        } else {
            Log.d(TAG, "updateImageDisplay: Displaying original bitmap");
            imageView.setImageBitmap(originalBitmap);
            setImageAlpha(transparencySeekBar.getProgress());
            imageView.setVisibility(View.VISIBLE);
            imageView.post(() -> {
                imageView.setImageMatrix(matrix);
                imageView.invalidate();
            });
            Log.d(TAG, "updateImageDisplay: Original bitmap displayed");
        }
    }

    private void showLayerSelectionDialog() {
        Dialog dialog = new Dialog(this);
        dialog.setContentView(R.layout.dialog_layer_selection);
        dialog.setTitle(R.string.layer_selection_title);

        RecyclerView recyclerView = dialog.findViewById(R.id.layerRecyclerView);
        recyclerView.setLayoutManager(new LinearLayoutManager(this));
        LayerAdapter adapter = new LayerAdapter(PENCIL_HARDNESS, layerVisibility, this);
        recyclerView.setAdapter(adapter);

        dialog.show();
    }

    @Override
    public void onLayerVisibilityChanged(int position, boolean isVisible) {
        layerVisibility[position] = isVisible;
        updateImageDisplay();
    }

    private void saveParameters() {
        try {
            File file = new File(getFilesDir(), "parameters.dat");
            FileOutputStream fos = new FileOutputStream(file);
            fos.write(Float.toString(scaleFactor).getBytes());
            fos.write("\n".getBytes());
            fos.write(Float.toString(rotationAngle).getBytes());
            fos.write("\n".getBytes());
            float[] matrixValues = new float[9];
            matrix.getValues(matrixValues);
            for (float value : matrixValues) {
                fos.write(Float.toString(value).getBytes());
                fos.write(" ".getBytes());
            }
            fos.write("\n".getBytes());
            fos.write(String.valueOf(isPencilMode).getBytes());
            fos.write("\n".getBytes());
            for (boolean visible : layerVisibility) {
                fos.write(String.valueOf(visible).getBytes());
                fos.write(" ".getBytes());
            }
            fos.close();
            Toast.makeText(this, "Parameters saved", Toast.LENGTH_SHORT).show();
        } catch (IOException e) {
            Log.e(TAG, "Error saving parameters", e);
            Toast.makeText(this, "Error saving parameters", Toast.LENGTH_LONG).show();
        }
    }

    private void loadParameters() {
        try {
            File file = new File(getFilesDir(), "parameters.dat");
            if (!file.exists()) {
                Toast.makeText(this, "No saved parameters found", Toast.LENGTH_SHORT).show();
                return;
            }
            FileInputStream fis = new FileInputStream(file);
            byte[] buffer = new byte[(int) file.length()];
            fis.read(buffer);
            fis.close();
            String[] lines = new String(buffer).split("\n");
            if (lines.length < 4) {
                Toast.makeText(this, "Invalid parameters file", Toast.LENGTH_LONG).show();
                return;
            }
            scaleFactor = Float.parseFloat(lines[0]);
            rotationAngle = Float.parseFloat(lines[1]);
            String[] matrixValues = lines[2].split(" ");
            float[] values = new float[9];
            for (int i = 0; i < 9; i++) {
                values[i] = Float.parseFloat(matrixValues[i]);
            }
            matrix.setValues(values);
            isPencilMode = Boolean.parseBoolean(lines[3]);
            pencilModeSwitch.setChecked(isPencilMode);
            String[] visibilityValues = lines[4].split(" ");
            for (int i = 0; i < layerVisibility.length; i++) {
                layerVisibility[i] = Boolean.parseBoolean(visibilityValues[i]);
            }
            applyTransformations();
            updateImageDisplay();
            Toast.makeText(this, "Parameters loaded", Toast.LENGTH_SHORT).show();
        } catch (IOException | NumberFormatException e) {
            Log.e(TAG, "Error loading parameters", e);
            Toast.makeText(this, "Error loading parameters", Toast.LENGTH_LONG).show();
        }
    }

    @Override
    protected void onResume() {
        super.onResume();
        if (isSurfaceAvailable && !isCameraOpen) {
            openCamera();
        } else {
            isCameraPendingOpen = true;
        }
    }

    @Override
    protected void onPause() {
        closeCamera();
        super.onPause();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        if (originalBitmap != null && !originalBitmap.isRecycled()) {
            originalBitmap.recycle();
            originalBitmap = null;
        }
        if (pencilBitmap != null && !pencilBitmap.isRecycled()) {
            pencilBitmap.recycle();
            pencilBitmap = null;
        }
        if (layerBitmaps != null) {
            for (Bitmap layer : layerBitmaps) {
                if (layer != null && !layer.isRecycled()) {
                    layer.recycle();
                }
            }
            layerBitmaps = null;
        }
    }

    @Override
    public void onConfigurationChanged(@NonNull Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        resetTransformationsAndFit();
        updateImageDisplay();
    }
}


===== File: ./app/src/main/res/layout/activity_main.xml =====
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <SurfaceView
        android:id="@+id/cameraSurfaceView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_centerInParent="true" />

    <ImageView
        android:id="@+id/imageView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_centerInParent="true"
        android:scaleType="matrix" />

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_alignParentBottom="true"
        android:orientation="vertical"
        android:padding="10dp">

        <SeekBar
            android:id="@+id/transparencySeekBar"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:max="100"
            android:progress="100" />

        <Button
            android:id="@+id/pickImageButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/pick_image" />

        <Switch
            android:id="@+id/pencilModeSwitch"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/pencil_mode" />

        <Button
            android:id="@+id/layerSelectButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/select_layers"
            android:visibility="gone" />

        <CheckBox
            android:id="@+id/controlsVisibilityCheckbox"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/show_controls"
            android:checked="true" />

        <CheckBox
            android:id="@+id/hideImageCheckbox"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/hide_image" />

        <Button
            android:id="@+id/saveParametersButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/save_parameters" />

        <Button
            android:id="@+id/loadParametersButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/load_parameters" />

        <Button
            android:id="@+id/switchCameraButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/switch_camera" />

        <Button
            android:id="@+id/captureButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/capture_image" />
    </LinearLayout>

</RelativeLayout>


===== File: ./app/src/main/res/layout/dialog_layer_selection.xml =====
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="16dp">

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/layerRecyclerView"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

</LinearLayout>


===== File: ./app/src/main/res/layout/item_layer.xml =====
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:padding="8dp">

    <TextView
        android:id="@+id/layerText"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:textSize="16sp" />

    <CheckBox
        android:id="@+id/layerCheckBox"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" />
</LinearLayout>


===== File: ./app/src/main/res/values/strings.xml =====
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">HelloWorld</string>
    <string name="layer_selection_title">Select Pencil Layers</string>
    <string name="pick_image">Pick Image</string>
    <string name="pencil_mode">Pencil Mode</string>
    <string name="select_layers">Select Layers</string>
    <string name="show_controls">Show Controls</string>
    <string name="hide_image">Hide Image</string>
    <string name="save_parameters">Save Parameters</string>
    <string name="load_parameters">Load Parameters</string>
    <string name="switch_camera">Switch Camera</string>
    <string name="capture_image">Capture Image</string>
</resources>


===== File: ./app/src/main/res/values/themes.xml =====
<?xml version="1.0" encoding="utf-8"?>
<resources xmlns:tools="http://schemas.android.com/tools">
    <style name="Theme.HelloWorld" parent="Theme.AppCompat.Light.DarkActionBar">
        <item name="colorPrimary">@android:color/black</item>
        <item name="colorPrimaryDark">@android:color/black</item>
        <item name="colorAccent">@android:color/holo_blue_light</item>
    </style>
</resources>


===== File: ./app/src/main/res/xml/data_extraction_rules.xml =====
<?xml version="1.0" encoding="utf-8"?>
<data-extraction-rules>
    <cloud-backup>
        <include domain="file" />
    </cloud-backup>
</data-extraction-rules>


===== File: ./app/src/main/res/mipmap-hdpi/ic_launcher.png =====
PNG

   IHDR   H   H   o#!   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  {ܙ,   bKGD-   tIME(`   IDAT(c``   _   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`

===== File: ./app/src/main/res/mipmap-hdpi/ic_launcher_round.png =====
PNG

   IHDR   H   H   o#!   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  ?/O   bKGD-   tIME(`   IDAT(c``   _   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`

===== File: ./app/src/main/res/mipmap-mdpi/ic_launcher.png =====
PNG

   IHDR   0   0   mk   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  {ܙ,   bKGD-   tIME'N|   IDATc` P    %tEXtdate:create 2025-04-27T16:18:39+00:00s   %tEXtdate:modify 2025-04-27T16:18:39+00:00Aq    IENDB`

===== File: ./app/src/main/res/mipmap-mdpi/ic_launcher_round.png =====
PNG

   IHDR   0   0   mk   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  ?/O   bKGD-   tIME(`   IDATc` P    %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`

===== File: ./app/src/main/res/mipmap-xhdpi/ic_launcher.png =====
PNG

   IHDR   `   `   V{   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  {ܙ,   bKGD-   tIME(`   IDAT8c``	  t   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`

===== File: ./app/src/main/res/mipmap-xhdpi/ic_launcher_round.png =====
PNG

   IHDR   `   `   V{   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  ?/O   bKGD-   tIME(`   IDAT8c``	  t   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`

===== File: ./app/src/main/res/mipmap-xxhdpi/ic_launcher.png =====
PNG

   IHDR         ݈p   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  {ܙ,   bKGD-   tIME(`   IDATH1    Om   
 >4   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`

===== File: ./app/src/main/res/mipmap-xxhdpi/ic_launcher_round.png =====
PNG

   IHDR         ݈p   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  ?/O   bKGD-   tIME(`   IDATH1    Om   
 >4   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`

===== File: ./app/src/main/res/mipmap-xxxhdpi/ic_launcher.png =====
PNG

   IHDR         hD   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  {ܙ,   bKGD-   tIME(`   IDATX1    Om      R   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`

===== File: ./app/src/main/res/mipmap-xxxhdpi/ic_launcher_round.png =====
PNG

   IHDR         hD   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  ?/O   bKGD-   tIME)g{   IDATX1    Om      R   %tEXtdate:create 2025-04-27T16:18:41+00:00J6P   %tEXtdate:modify 2025-04-27T16:18:41+00:00;k    IENDB`

===== File: ./build.gradle =====
// Top-level build.gradle (project-level)
buildscript {
    repositories {
        google()
        mavenCentral()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:8.1.0'
    }
}

plugins {
    id 'org.jetbrains.kotlin.android' version '1.9.0' apply false
}

allprojects {
    // Repositories are managed in settings.gradle
}


===== File: ./file_list.txt =====
.
./.git
./.git/branches
./.git/description
./.git/hooks
./.git/hooks/commit-msg.sample
./.git/hooks/fsmonitor-watchman.sample
./.git/hooks/post-update.sample
./.git/hooks/pre-applypatch.sample
./.git/hooks/pre-commit.sample
./.git/hooks/pre-merge-commit.sample
./.git/hooks/pre-push.sample
./.git/hooks/pre-rebase.sample
./.git/hooks/pre-receive.sample
./.git/hooks/prepare-commit-msg.sample
./.git/hooks/push-to-checkout.sample
./.git/hooks/sendemail-validate.sample
./.git/hooks/update.sample
./.git/hooks/applypatch-msg.sample
./.git/info
./.git/info/exclude
./.git/refs
./.git/refs/heads
./.git/refs/heads/main
./.git/refs/tags
./.git/refs/remotes
./.git/refs/remotes/origin
./.git/refs/remotes/origin/HEAD
./.git/refs/remotes/origin/main
./.git/objects
./.git/objects/pack
./.git/objects/pack/pack-b552bc965c86426d18d4468a03710aeff01fcf1a.pack
./.git/objects/pack/pack-b552bc965c86426d18d4468a03710aeff01fcf1a.rev
./.git/objects/pack/pack-b552bc965c86426d18d4468a03710aeff01fcf1a.idx
./.git/objects/info
./.git/objects/74
./.git/objects/74/a2ab7af7428e5deea0a85178d42a2d60794416
./.git/objects/74/0428f4cbce811196316bf50ad1ae3e283ce12d
./.git/objects/35
./.git/objects/35/02acbb0ab2e6421b43ba33229b439deff64b38
./.git/objects/ec
./.git/objects/ec/9edd32fa19d464c076824fa3c35d12ce211106
./.git/objects/1b
./.git/objects/1b/c5213578f9f2c8f83657e564aac7dcff2a0e6e
./.git/objects/03
./.git/objects/03/e3e480dca3ccf31c8a998de46596663939a832
./.git/objects/7e
./.git/objects/7e/b421ea459868ebdf7457b7ace9d60ba4ec9ede
./.git/objects/c9
./.git/objects/c9/0c4e6d5c1e1ce6b60b040a90680b01417d0211
./.git/objects/52
./.git/objects/52/59c60c92b83aa9771befe444e3af8cfb2b53ac
./.git/objects/6b
./.git/objects/6b/7f28f2986f6ef83610cbfcfa04683a82db5dd9
./.git/objects/a4
./.git/objects/a4/b14ebddf30a160864b33e61ecdef91e84eb8e3
./.git/objects/81
./.git/objects/81/4fa7f53d565dfa1cc749e8c0215c2f9f8f50ab
./.git/objects/82
./.git/objects/82/aba5822afc8d8387671a2a68499bd9c6e77eec
./.git/objects/5b
./.git/objects/5b/367b361ebfb9f5992f352cdfabd3c10543ca81
./.git/objects/f5
./.git/objects/f5/41c5fc813146c5bc873f8c21ef9e055f2879a2
./.git/objects/9a
./.git/objects/9a/76d09f344b7bffd9bd29a470304d70c4afd2ec
./.git/objects/59
./.git/objects/59/4f0361409cd436f1d6616655598d7cc9927bab
./.git/objects/eb
./.git/objects/eb/a614126fe8020ce1efdbe2bb66d128d092ef6e
./.git/objects/4a
./.git/objects/4a/3f40cf097f92b721acf19d8196b3904a720da6
./.git/objects/40
./.git/objects/40/60d1f47604213d418cee20702d4abffe117776
./.git/objects/a6
./.git/objects/a6/facec96c60177e105db6b8dc91247b00bb9f7a
./.git/objects/1c
./.git/objects/1c/8d4dcf27b709ea4ec9922ff3b8d79fc2d18d24
./.git/objects/72
./.git/objects/72/644063f1f8a71a684348070e4d11afcf2ab5a5
./.git/objects/1a
./.git/objects/1a/50e1788f303d699b05d149cbc1577e66a51e2a
./.git/objects/54
./.git/objects/54/3d293536ee1d97d99b4570e51e4d6c6acac8bf
./.git/objects/29
./.git/objects/29/6a993966ef8c742cb13d58691f75ff27f93f0e
./.git/objects/9d
./.git/objects/9d/984c92e3b46e21d503d59a00478c4b881cff79
./.git/objects/df
./.git/objects/df/f8304194fb003e43921513400f31ecd0140769
./.git/objects/46
./.git/objects/46/a5e41cfcfc6c99d731f66a826a32f7761179e0
./.git/objects/51
./.git/objects/51/f4b9b339a1f95da6e432a3c2d2511cf0519833
./.git/objects/e1
./.git/objects/e1/2eadc21abc0118ad984c2c5dbf71b4c605504b
./.git/objects/d2
./.git/objects/d2/c4ffea4bc68ce92529746e99a43d94a916e9de
./.git/objects/7c
./.git/objects/7c/2833b690c5f28cad9c5e2349ffd40f034e2c0c
./.git/objects/0a
./.git/objects/0a/e372fe4763b5c8e5ef7e49e09a598f5a0683fa
./.git/objects/69
./.git/objects/69/bae2761a75fe49bb72c9516f08da20b35556b4
./.git/objects/69/5bf2f8857ea2d8b0119a4d67ca0b431ef02f76
./.git/objects/cc
./.git/objects/cc/6b9072d302f5d2aefb57cadaca39e14ba87c51
./.git/objects/cc/fdf386ce489ceb06794a7204640cb524bf0795
./.git/objects/f0
./.git/objects/f0/7197757bd4d1e4cc4f290cb93201ffd12ffc02
./.git/objects/77
./.git/objects/77/5695b7848b3d81b1ae23918ebe8878598c3abd
./.git/objects/ea
./.git/objects/ea/3b0e300f7e357d0c8b098736d6f8d4a921d25a
./.git/objects/00
./.git/objects/00/ed411e6dcb11f7b703ea1c0aba1296e29ebf2a
./.git/objects/67
./.git/objects/67/ab55493ae8b034cabaa155b01b5ea8e43df768
./.git/objects/73
./.git/objects/73/e1d591ae3a6e46f7fd41d5689e7eabc5b4638a
./.git/objects/ce
./.git/objects/ce/5daa66d01161efdbce56e74b0fb6f9821334cf
./.git/objects/0c
./.git/objects/0c/24de2d04f748a3a1a86f7a6af5e7fc07b78186
./.git/objects/48
./.git/objects/48/d9f527e34e975d411cfa4ed290720bb9082002
./.git/objects/c0
./.git/objects/c0/f6d94e0b8b25d62f02d7d1cbb9b4f90452cc35
./.git/HEAD
./.git/config
./.git/logs
./.git/logs/refs
./.git/logs/refs/remotes
./.git/logs/refs/remotes/origin
./.git/logs/refs/remotes/origin/HEAD
./.git/logs/refs/remotes/origin/main
./.git/logs/refs/heads
./.git/logs/refs/heads/main
./.git/logs/HEAD
./.git/COMMIT_EDITMSG
./.git/packed-refs
./.git/index
./.gitattributes
./.gitignore
./README.md
./android-hello-world-app
./android-hello-world-app/.git
./android-hello-world-app/.git/branches
./android-hello-world-app/.git/description
./android-hello-world-app/.git/hooks
./android-hello-world-app/.git/hooks/commit-msg.sample
./android-hello-world-app/.git/hooks/fsmonitor-watchman.sample
./android-hello-world-app/.git/hooks/post-update.sample
./android-hello-world-app/.git/hooks/pre-applypatch.sample
./android-hello-world-app/.git/hooks/pre-commit.sample
./android-hello-world-app/.git/hooks/pre-merge-commit.sample
./android-hello-world-app/.git/hooks/pre-push.sample
./android-hello-world-app/.git/hooks/pre-rebase.sample
./android-hello-world-app/.git/hooks/pre-receive.sample
./android-hello-world-app/.git/hooks/prepare-commit-msg.sample
./android-hello-world-app/.git/hooks/push-to-checkout.sample
./android-hello-world-app/.git/hooks/sendemail-validate.sample
./android-hello-world-app/.git/hooks/update.sample
./android-hello-world-app/.git/hooks/applypatch-msg.sample
./android-hello-world-app/.git/info
./android-hello-world-app/.git/info/exclude
./android-hello-world-app/.git/refs
./android-hello-world-app/.git/refs/heads
./android-hello-world-app/.git/refs/heads/main
./android-hello-world-app/.git/refs/tags
./android-hello-world-app/.git/refs/remotes
./android-hello-world-app/.git/refs/remotes/origin
./android-hello-world-app/.git/refs/remotes/origin/HEAD
./android-hello-world-app/.git/objects
./android-hello-world-app/.git/objects/pack
./android-hello-world-app/.git/objects/pack/pack-8216547e807188c1428d6867229615c8cb953984.pack
./android-hello-world-app/.git/objects/pack/pack-8216547e807188c1428d6867229615c8cb953984.rev
./android-hello-world-app/.git/objects/pack/pack-8216547e807188c1428d6867229615c8cb953984.idx
./android-hello-world-app/.git/objects/info
./android-hello-world-app/.git/HEAD
./android-hello-world-app/.git/config
./android-hello-world-app/.git/logs
./android-hello-world-app/.git/logs/refs
./android-hello-world-app/.git/logs/refs/remotes
./android-hello-world-app/.git/logs/refs/remotes/origin
./android-hello-world-app/.git/logs/refs/remotes/origin/HEAD
./android-hello-world-app/.git/logs/refs/heads
./android-hello-world-app/.git/logs/refs/heads/main
./android-hello-world-app/.git/logs/HEAD
./android-hello-world-app/.git/packed-refs
./android-hello-world-app/.git/index
./android-hello-world-app/.gitattributes
./android-hello-world-app/.github
./android-hello-world-app/.github/workflows
./android-hello-world-app/.github/workflows/android-ci.yml
./android-hello-world-app/.gitignore
./android-hello-world-app/Build
./android-hello-world-app/Could
./android-hello-world-app/Get
./android-hello-world-app/Namespace
./android-hello-world-app/README.md
./android-hello-world-app/Run
./android-hello-world-app/all_files.txt
./android-hello-world-app/app-debug.apk
./android-hello-world-app/app
./android-hello-world-app/app/build.gradle
./android-hello-world-app/app/src
./android-hello-world-app/app/src/main
./android-hello-world-app/app/src/main/AndroidManifest.xml
./android-hello-world-app/app/src/main/java
./android-hello-world-app/app/src/main/java/com
./android-hello-world-app/app/src/main/java/com/example
./android-hello-world-app/app/src/main/java/com/example/helloworld
./android-hello-world-app/app/src/main/java/com/example/helloworld/LayerAdapter.java
./android-hello-world-app/app/src/main/java/com/example/helloworld/MainActivity.java
./android-hello-world-app/app/src/main/res
./android-hello-world-app/app/src/main/res/drawable
./android-hello-world-app/app/src/main/res/drawable/ic_open_arrow.png
./android-hello-world-app/app/src/main/res/layout
./android-hello-world-app/app/src/main/res/layout/activity_main.xml
./android-hello-world-app/app/src/main/res/layout/dialog_layer_selection.xml
./android-hello-world-app/app/src/main/res/layout/item_layer.xml
./android-hello-world-app/app/src/main/res/mipmap-hdpi
./android-hello-world-app/app/src/main/res/mipmap-hdpi/ic_launcher.png
./android-hello-world-app/app/src/main/res/mipmap-hdpi/ic_launcher_round.png
./android-hello-world-app/app/src/main/res/mipmap-mdpi
./android-hello-world-app/app/src/main/res/mipmap-mdpi/ic_launcher.png
./android-hello-world-app/app/src/main/res/mipmap-mdpi/ic_launcher_round.png
./android-hello-world-app/app/src/main/res/mipmap-xhdpi
./android-hello-world-app/app/src/main/res/mipmap-xhdpi/ic_launcher.png
./android-hello-world-app/app/src/main/res/mipmap-xhdpi/ic_launcher_round.png
./android-hello-world-app/app/src/main/res/mipmap-xxhdpi
./android-hello-world-app/app/src/main/res/mipmap-xxhdpi/ic_launcher.png
./android-hello-world-app/app/src/main/res/mipmap-xxhdpi/ic_launcher_round.png
./android-hello-world-app/app/src/main/res/mipmap-xxxhdpi
./android-hello-world-app/app/src/main/res/mipmap-xxxhdpi/ic_launcher.png
./android-hello-world-app/app/src/main/res/mipmap-xxxhdpi/ic_launcher_round.png
./android-hello-world-app/app/src/main/res/values
./android-hello-world-app/app/src/main/res/values/strings.xml
./android-hello-world-app/app/src/main/res/values/themes.xml
./android-hello-world-app/app/src/main/res/xml
./android-hello-world-app/app/src/main/res/xml/backup_rules.xml
./android-hello-world-app/app/src/main/res/xml/data_extraction_rules.xml
./android-hello-world-app/build.gradle
./android-hello-world-app/gradle-wrapper.properties
./android-hello-world-app/gradle.properties
./android-hello-world-app/gradle
./android-hello-world-app/gradle/wrapper
./android-hello-world-app/gradle/wrapper/gradle-wrapper.jar
./android-hello-world-app/gradle/wrapper/gradle-wrapper.properties
./android-hello-world-app/gradlew
./android-hello-world-app/gradlew.bat
./android-hello-world-app/ic_launcher.png
./android-hello-world-app/ic_open_arrow.png
./android-hello-world-app/settings.gradle
./android-hello-world-app/file_list.txt
./app
./app/build.gradle
./app/src
./app/src/main
./app/src/main/AndroidManifest.xml
./app/src/main/java
./app/src/main/java/com
./app/src/main/java/com/example
./app/src/main/java/com/example/helloworld
./app/src/main/java/com/example/helloworld/LayerAdapter.java
./app/src/main/java/com/example/helloworld/MainActivity.java
./app/src/main/res
./app/src/main/res/layout
./app/src/main/res/layout/activity_main.xml
./app/src/main/res/layout/dialog_layer_selection.xml
./app/src/main/res/layout/item_layer.xml
./app/src/main/res/mipmap
./app/src/main/res/mipmap/ic_launcher.png
./app/src/main/res/mipmap/ic_launcher_round.png
./app/src/main/res/values
./app/src/main/res/values/strings.xml
./app/src/main/res/values/themes.xml
./app/src/main/res/xml
./app/src/main/res/xml/data_extraction_rules.xml
./build.gradle
./commandlinetools-linux-13114758_latest.zip
./gradle
./gradle/wrapper
./gradle/wrapper/gradle-wrapper.properties
./settings.gradle
./file_list.txt


===== File: ./gradlew =====
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/subprojects/plugins/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd "${APP_HOME:-./}" > /dev/null && pwd -P ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"


===== File: ./gradle/wrapper/gradle-wrapper.properties =====
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.7-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists


===== File: ./gradle/wrapper/gradle-wrapper.jar =====
PK    !              	 META-INF/LICENSEUT     Z[s6~ϯhfgFI}RcU73>B$(aC,@Z=(Nu=֢swJ|gr]ΩW//e6vn(}g퇡͛0ݛro^X݈wwnas[;|\[7z>!ōuP_ymfD3iDd'8l*QU6VNªޚj,qEổvD[JlbJȷfA{[z{Xiջ ̡SVJPG!ao\Z1 `ӝKj'qKϔ;< i,IJ z1^
jxk0`MSiUА]JӶ⠇=⽱G?@$Fͼŉ+}KAgKBFy)'Np_7{X!{EӾd9h&rAr%պkʖ(pU.H[ՁJHL.Ì3qk7;ν&Qy|x	[<',6[	)՞FZoUך,hMh*8Xwe3) 	EgVGghCpJG~_hFeq7¹;3pP~ִr/;:$DEM4c-`bz@/䘐6Ƅ2?" 'NPn*-pc2(!iL8R@w1tX Hn	RhXJJ2B@70-/k2-dqPOagXaE+	1de#XQ	4F q^ (Q*VF?DcnE\8u 5@̴Q+14>O><0rA%lfJ
Xw]}~I|zw$WZc~^ZUV5Gȃ3nтqV]k "[˒Dh3:}).Ҩ
bL$H2lZN"KQMm7n;<xAEz>h#3ZLjDe}5yu^f^˰H5 腭l(uD>[_`FWPhd!R+% u -+Y
Tr;*,!%H+ȵrL 68n9:cKxi'BTS0!(hFJ&v(rzC(Ȱ#j{K|v':;d)On@dSe
	("$}R:ඥ{sFѷs*]<~`Vb3rqz,GeURd!38@z5eB5A#L<5e3_V'єga`Xq|t	qk}#!ЙK'X}[N#Y>B9'la5sG+XZ!P$PqCt-z>k= l/ѦAP/؁qe
	f죰MӁʈ]^f+ܺ7;^Ք	ҡ审6IdtA8wڂL-PbYc/ 0ScN	|~
V8(͈?hz6jE ,O_8	vS&ñ?Zb 4e
ͨϔh%/*+V|Ѻ Ċ໹X|24[yLvB:p	%Ha@Ċ<m?dEj )Z˵i'Pg5tHۡVGDʩo젒i'Ѱ6ۓ7Jc;u,8e#ŐFغLw. pqfXaRțLP)xqASHş=R2Dh1ќqvHOr^F}㇮ng|O;'Ϯ.dʙe_zJ𡬨LA.AI7ABG(ƮhW
6(鰝ʧ~IV FAMtLND{Qr0Yu,T[[YM|opJImyp>3%	sunDC>!Re-Bd6ˆ*bGd&%-5P8"?S8ި*Uch$bpyid0 3\L&VA<ǆy⢉RWAL N_+P?G24	˽hL}A"MMV$T"yu6K
VMpd8K&*q4N8{jvM x蠊:rzJ/I.H|x"aV6zvt>x:aͧKki`ZG^2.7T_2LwXFH57B9pR|io`?L=2xhviPCXxte9ٍ_1}	ŹYd48Rg#c_A4T='XɥPMӨXxG	MNj!|5PRuKZ|	v9$nR-V"5/i
V$wI+-j6/'νƹ@lL,7=܋Oz_n:{/??;op:I4JISќT:BKȞC,~y ^/W/߮ݯB}`e|\akansՖoY {TӭpW85H5DB79Dx ;S&3{V,?9}r<_b@`a'v6j	7Y@C>2ԮJu]b2ʍ/7zK<"[-9)8	.k4m'ZtWҗ\n=}bW	H`xr^h@h8|gU<j5>mtɚcĘ;3|bpx
؝1A73e	FT-W#c[ r8HOq^FQ%is0kZ! /H:KO{t=,|-roOAi9l+Z ԑ+1G#ŝj;jIY0OAAW-p_造V2	NotMv9!@`%nQIQ~&=196uMjhWx0\ږ(hŔΣO+fx{d#H6dEcF.PK  '  PK    !              	 META-INF/MANIFEST.MFUT     MLK-.K-*ϳR03-IM+I,
dZ)%*%rr PKm>=@   ?   PK    !             1 	 org/gradle/cli/CommandLineArgumentException.classUT     MOJ1^/sRRa"HSO-xO46.n>oIP,(:}~ 3xng_F1K26Йl"$D
:6R}Ȋ<\\y}ۿ,!"D4,NiSnE|2(ncЙgx2e^ʋ`,'¥StUi4=p*M+tqxgY']hnZaИ0U0JRv	@y{GjPK`zX!  p  PK    !             & 	 org/gradle/cli/CommandLineOption.classUT     eR]OA=
(~ʇZB X2fwK4F_ՈMzw3w=ΙϷ ~oyVp-mI3fztx(=Wox/Auf];AhK[	DQkz7uqU'_joAĵ+/]Hn] C|S<`|۰}n90ixw21UQ
|wmRfAbD0ZP:cԫ"$#TۭpõMʔ;,+-yF0zAﵚ23ߓ`K,p9Л˯B&#x+c)d1b $pa#IK$CbmN.HE>\R1xT8Ev
WC#h2:0w5z_VqӸm
r.S*BEiQ8=bn#7,ltmۑAwhLlV='Vh1K~(4	d"_i"Lda%:Uя^/0c3.Cd(OBgxf~bLƇ?T	b_`k+PK×n    PK    !             3 	 org/gradle/cli/CommandLineParser$AfterOptions.classUT     SmOP~.ʺ1@|+6(ILL0ܶw]]n;!?hhGO,=<9O= <Dj5cà<Bi#ȯ/x$(Xiׅ5Xq?F50$V92aU_k>9:7t=)K"EbtāqA<_0rK/J6 ҩP\EBͬbHC?BOJl<2\HЂ;Ҭ1>?av;Y0i`a4 9*nDx-mI
áׅyQ喴kJOk/wY覭gzK=/)FPi_z^5bȉmB_t3ҺREZwp7ۘf`0\-kO1@3qh61$"6%+nK4TudhO{Z5f	r03F(G6>wbډQّ1:x_Z5ʹة+Vq{1挣StiPKd Z    PK    !             < 	 org/gradle/cli/CommandLineParser$BeforeFirstSubCommand.classUT     UkOP~ Zx	S-8%&UzY4F~hb$^oA-k<{rQ`xS%a	U_TSXUؚ0-V/y5S'鉔Z-kjFCϔ5$pm$e52h/³ÙV609\]\3L0t%SuHO;y]OSbqz~VlKha8i{;/$2?͠DaEuWІv삢@n0t86)tP7#&6HĺPL]$t3wg>i2ĢpaS˛z:a	|L^eWs
p;Cצe	gX/V}J&H	dG߶:<H8Ii:+%YCc`
Na PgL9İ[ߢ=7w$RAتBh}MHO߶nf	ۿX2t]	g95Lr"?Ň0w_fx҈8}|o
	d<C^ /NFxup+OO%1+-4乚U]^4Fh~Ia]8M`85z:fJ|dj{"t~!ZB5wxP0D|5$
4|Xț5d
-qpYwK|ąU\:kFK%wM:@JED*u}ItR<c@Vބ_PK1,  ]  PK    !             = 	 org/gradle/cli/CommandLineParser$KnownOptionParserState.classUT     Viwe~^ҡN$aH:iYԐ DD;A:؀KMN
.θ勉(3Lq8~_=s<O}nKW}s7 /wphPMjBPtCuuˌf-WNêMa'uBCH(f\T>තҵۊCy 3F7	3ۺ!m[Zۢ	c&wgٲ3j=me^v}5{s/I%6j\n>ly+2W7`;`oCua
ĐLuvh%	d#Ò!uD]݈uڶ:W(lMpia-~@~X%*%aCUr*5oN)2d\#B2Zv=Uevڙ|.CWϠX湦C3	MTj־%nCuaԢ3Ih%R{wʸA(Űa%lԣGn7 fjLiĽxh/cAA6oh#2n Q}+C˕-)y$u^MB7NSٜ;)TFUGֈqMl}Q|+~*;[k8!JV!*R%cLbxe'.t_YQLU\0WTs:&BCn?G{<ݍ}"OIfKBw!y+?Dpi=5;Ug=Ȑ2ÊƝ{vO\.+%}XAcĐR*j@h[2D+.#oƵeqS2.t-s1kfP)rD:]cETJVeg8T_v,aɰp(8 F̆8ܡEN9$ΏQ1*Bx2fgfƄ%<%iT2B+vhgls4H!.Ob2.8UőY%4
QFͯzBV]fXZ9E^Pޠ
.?1A_ob&8}uxP&	.?0fl+67
do)Q.^Tgp6!qo5BtC,S'1鋴b>8OK]Q= Acm>pQ/9Ջ]=i{OޓIa~}K$6SVMa,OVL`MdkXza!<mƂ1GqG<6֖I@}85NN&}`i/nOūɆ;ZYo3荸%TQ\²;
X$c\_e)Y=/?B\XvB%r\k=Bc_u΄EY>v$z}c-I3Yj70Eo8O:HKp8ҩQhDf%V4&q8Y)"|V{ZƑLp4ӿǣxsq_>)5|bMZ̉xxQ{5F_akI֌̈́q]OtNh$DW]4Rt "ΏN\*ϑ,XYV9ډ]$1(MR=S<MSF&$jO',XVUECկPK  b  PK    !             < 	 org/gradle/cli/CommandLineParser$MissingOptionArgState.classUT     mOP"cOh!:hhb28ww]Kۑ#Mt&3hHڤ~s"/67wh5  \CAwxh;{^tֵw'feDڠ1\7b)DH{")K{CS<q\ppuuqi5f9aHn\nE<
j4"ː
r؃ߑN~@yaXZRQZ198CoۂA97=^w(jyAecYW`$hOCS(p|~	O׬œG)LKv]|#*b+".MF}oՓIʤiyBF*nb.y6#~XZ=u:5{E]|.D<u2";Zy3կ(~F|M]JE3$EJt	F,Yxc/(qZƧ9T62ڇ>Q#٩H*c	~PKC'|L    PK    !             = 	 org/gradle/cli/CommandLineParser$OptionAwareParserState.classUT     TkOP~!PA72nʸ	D_Y{(#BpI4o(%k}罜/ c||'\CRm5Eg߲o])p)l=AiSDZ75kV!
Fa2{]m״\!嚄Q,³CcCYz0Z$uڲDQSrݶ2E᮱DJ+\zB/9>py
7<uݸ&3PX^pp{r-M:zh 9
	L?**T1'v53k~p.JbKjCz']DqO QtZWtEJU%_?jVo29iV]-;-Y?'AS7[Y.
ݧĐ@2gٝJ)r~+{[__X3t]KO
SR]/K)!/g`=5Hx^0hUۦdd剋a*I	Sgh
LSrlSSx0@s<SBB`Hϗփ0!dL)t)ھ!hG%1iЪZ:mfYGkpHe
` u	cd?19Hs|MZo#)Qr^]PK[  J  PK    !             8 	 org/gradle/cli/CommandLineParser$OptionParserState.classUT     PMO1绁PJ9q誇bY =Z$D(ʡ7dlo_TqDo>ߛy~bsyt*hxQBr+2Yk8Ə]"5K;^)}<0|.{BJ"̔.E%B!jbE|c{`	2 "8Ҕx@N\o.rru0h$g:ԎAB5MΧ	U2E>~	Nw6if)*cgȺ=ٱ=ѕF*sU93Xs&"QkԀޤ:!#+ߝvR&,-NfjA1-kX699||x*]=PKu[z?  }  PK    !             3 	 org/gradle/cli/CommandLineParser$OptionString.classUT     uR]OA=Ck[ji+J[4D3;Wf}1?	D?x-59sϙ{?~wɭnn^(]7+
	Ȱ::^o:CC&|67(W5/uPw	[76֚-zC~?*K`04mW4,W6㾽CJ{\EB-IqEax5gaHq0v~_)[` A39Je<olz*u9LO
f4Q!C\:)__6tbP	U4,`1[PEWPY}<pLaHsAOJF[`9xaI*Cz&W]7]u2(Ks9bEķ¨&U:-"E(ZVQc0{=)3K>|7,joKgQO(ڟg2iwRrR PK  C  PK    !             2 	 org/gradle/cli/CommandLineParser$ParserState.classUT     QJ1jW.\q\(
BQ]fv$%3-~%ssɹɽo/ kwσTM:nS)oP"OOܠM҉geU1oz5͎HZ]	h(EP-V7Vkn]~BCwLGB"6J)\ur:&A	,5rOry5irrBtA\-@
em\deӶrǯTps>=jV'Z}tZ%9T!u`&N:KԜ</v9M2g{|}zpO-`A1j&70r83=wboOϝC PKɉ    PK    !             ? 	 org/gradle/cli/CommandLineParser$UnknownOptionParserState.classUT     SNQ=
oWԶt|X ؀@LeY؏5Fg& >qn) Iß{g93 a'ʭ=nmE
mA~)<#A֎܋DQ9k8Du]\Y>o=7fUJกQ-Ka}s7Cf=KK<q=Jt$=aZkBL/z`c4s.1"ud(U:A\:]M)kbM ?b;\L|~!{Ї+ՐAoRԠ:kF:29"~ʣe}~.E0 JL.AfRj	g⍦srBƘN-Q+Kc3+n/i]sȩĶ]ZuWXR~KCQe;bW"V~UW	(Ȫ])Դ%)bӷDI'6&~``CC4qWqGJ~mŮc˶bn~k'q-u6<+hasRwG040 fSBڡΉm	J(AHPKKϖs    PK    !             & 	 org/gradle/cli/CommandLineParser.classUT     U[wU	Lp3XiE酋!mjh̜&C'3afҋ,]G*آ,g_|'?}&<d}/ EañfL3՚arϰTa

ڬp7U6֫noʩ*Czn:=kgISg$*a:'"{OWwWOJs!0p;fArpi4YZ>LF
GA]>&|<G\fd`z43>>0cgiGBz{p~:qS^5\^2n3kbvܭMӞiZoawC ~+8fm>
0#&QJFYUc8pYqݎ]q'"ctВT~ƴd{1ۅ&3(v!5oߕN0N-d0DO\ɝmyܰ!pdsPL%MSMS!O4nSMz	ëlq牌*h:l;q.,M@HQҋ>II\\ƍ,%|߸n4E\
XЄO+YnYr]Wdm6*,\Z梺ʥZSWjFpLm61U*P|;5C5"O%w!ݟbf$1~9y*aho:d!\_Tu1C}(Fɯ{ce/P.1r:{!	oV Ilm^c$F&,[E )i"|IbPgSMlepNNJ nW0Cag!'*hُ2EÉ9G0S⪤L:zv7ʺ+59,}nHeUrjI8RqE^15@4Km'{VI&+
$± !m{(w'A_ 1:й
KϕWN|'X,p#]F?")yo?_"[
8с`-.X8`9!;~]'8i8Rp&{1Ô~g PK  c  PK    !             & 	 org/gradle/cli/ParsedCommandLine.classUT     UvUvvXhP@$DJ{ "ФE@=Lfvi'3qf%ŵjf\yE"?߷w~ǟLdxWᜪqKχ|8b0Uϰx9nrƵϫcR!^TKqC๹Y=7CX'ϗM`X;U>w\Ed209c0LB਺i$UXT-=E$jTBb35OB1$qWe<ѕD,{;i0Xr-oe'`/\=G]v
"eS`%oqG)}exNw<q7>qO1ɐdSI*8݁b8+P2MJ{2"
َxe[Q\K`H5tD+"6~>٬BUN$:	f.D+2Õ5m69QĜY̷#	SL+$;7t]BcP,_۶a1Ld94o6Mʣ۪"gll:'&ޗ&Fhʙtw>MaO,mRZ*ѣٸфI!-l0 <yynSpʤ<3+;ucU_B<o;E2D@\}ŮGHj.*骉/
M-llC7M<[Fݱe{!i }2wk͎*՘ӗ!7$UU=[%M4nWplS0RY#|L2|%r^btb :HX`?v孧G~/Ԙ,KȦ#Ue+_|[XԹXZ	Hp[GCDG->==r	6,~	;Z?%2\ 	Rv{X&?ǧBF+TDK:_yVEu_4,D(_j%XmPK2w:    PK    !             , 	 org/gradle/cli/ParsedCommandLineOption.classUT     mJ@mmmu"Q1 74MN2DA|"( >8)ssoΝ/ {Xexy~Ɣޑ/ӉyyLFW$k2k?Q4e!vI|*`߰*;?,4q[!Y"2"%ĨSR2z1M:s*s!a#WI(K
")+4Ž<MyM夺y=@,	.6j)%i/!3C_ '")u.CƲ&\u4X
|ϼ]3V*oֱ*Ԏaho߽cͻw~fe_PKZvmT    PK    !             3 	 org/gradle/internal/file/PathTraversalChecker.classUT     uSksF=H1n-(DhG`<ǗzuLhve QWb {=w웷pMoNOEq9A(KkIK{\ՂA.sa-Zs©N{reC}wS0JQ*^׽y^Uw2X02XQLyw)wGǍ\;U<'"wE^s'{tҹCTH$}P}XE_U_30NBi.ޭQyzlbaL|`Yy*6z\ĳHQ0|9q^Ҧ}OQ!#BJY(S^JKcاC+-57eRWc?dt,0pfbǖ8ǏĨf&dl'go'UԱϵHע)f8!pT~nmg#jڎfvnˠ
庝IOVaɄk-Qsm<D>kܫ".Up:M;txwx;)lbI7U1zo#"p]#k+>nַ#b/L!]pλq]k@\Ik9NFX~.bܿ_K%e;+B5zNrYupeVJ PK$O    PK    !             A 	 org/gradle/internal/file/locking/ExclusiveFileAccessManager.classUT     ePMO@}[LBRHi"!TBDUH^O%ukG9rȁUulzf4y3;b]0jJ6B5BU3mdEJ;2$=19>RRS_><Ki+eQ.g=(y&{uqe~"Zb3msrg1>E)KݳrN!eqdj(ֶ$gLŦPS?^*Sy=o>(EVfV/\FsrA(x.,llN\^%tl
O_*MX8mLt7Ln?8KVY
kuiV_9@Oyz^@p|ՀbtC~D+_h}aŢ>^3_l|PKywʇ    PK    !             > 	 org/gradle/util/internal/WrapperDistributionUrlConverter.classUT     Q]o0=f2 c᥃CX/CHHCUInSo9N_!=uxEG!u4dY{2|?zH%ކY!$7"W~'dqMxIrK?QWVYm,u=Mu~XIir5EBiRIaw	O`~^^	Ia <TF@(CZq|м(H"w̕l)|Uv)6V)錔Q{X vmM=wom
)2g0\(a^0пwBp>%ӷ٠.q&_9u:5%qm\L5W?@כhìmn3A]tiY8́y٪faa0x&X#:\;	tN5f~PKb    PK    !             / 	 org/gradle/wrapper/BootstrapMainStarter$1.classUT     mQnA!5@$^p0	!Hqiήfȇ\āLi{zCSpyr.Pv6l*km(&eg)'ٌ(}|<%ERR&'#Ѻota~FɰB[fm!쒝^GQ2~߂Rh6Ы\r[Gu.=\@.{05%l96W&Rd'BKa:*u{:hF:R,:(?9cל^+\ZXYKosr-l3֕%BTRW/;kc
OebCS.yMPܶ[+5WPKEҚ    PK    !             A 	 org/gradle/wrapper/Download$DefaultDownloadProgressListener.classUT     SQoV.isKJ(Tգ,	MC)++CJ	ԠH؍}uN썇=3Z*&6iO50:ls{s_/^8ݻVc)|\29kZAz<rlAq)<CA6øKmb9.\CΝ[۱Q Ҽ!]ߡh_Ȑ(^[l71 zHHn{%y'dJ{_m{2púFR CfyS^mm+00#$Td0dQ!>PC=)n`5GFw}7X#RºQdth30a1n@'00CY[#Q.whfHWV
냗HwcΣDV+cVq7)y5`܋j
1Uyt|"Y,MGE|*T~OjF6-QKp9A'de%"GPj;ZGnW|}=u/4|0l%)^rV"*$t80qrmuO:{`
:]onK*Fʤ0$&oL	hEݧT~^UƋmLmLmcY"O~{~~0͟Rvab&{:CT7M?AM?M33_Qʦwp&>ȵ_,>ǹW1Ț~p17Ϩ)@=]ZbU2=J39JA>4RPK%)    PK    !             4 	 org/gradle/wrapper/Download$ProxyAuthenticator.classUT     TRP] Pҋ\RA/Te&m4MI
2|:ZFq|?qVf$'k>+7 X`xK
x!ShFQk[Z6-IT\SP\
[pOP̽QVL۞kR«	+!
Sfa2[_62Od9BH)QtEH(NN$	Sho`C&1oق!R$iԪժ9wձ]n,IL/Ƿ2|ZroE*o	oq_-;uW:Z_g[rev=B atu =oՕf5maX.յ7#!'^քGUizcaӆF*b0tad?!f8{$p~$GqGpI,"R'q*uAm̄p;t}pmb;C?p
5ƈfgkm
:
tqLoIA8/Yl2$Cw*.Jt14"	\~NH%\$ZU0л-c)a;jNF!ܠn匔|C>ͪ4=4[
nb^E?CY1F&OQ<OOm{6DmtWb~F?贃YG.cu}ĉw(u>!	=?l:)Zt#SVOt\_<Q	w}lwoia[mhPKw&    PK    !             ! 	 org/gradle/wrapper/Download.classUT     W	|Ud7nKmKiCBs5MФWA&KufwfAQKU6B7ZZQ<QQTߛM7ox>`=29x@ŀZ":XQ_Փ)5Xz	3a34++R`RIU!l@{`: 9׉-Z\87T-Nn荡`Tc;gX񆸡aPR)n4lG$J+#JCBQKB	CIBǹAt؋Ĝ2MC5-	+14VnJ:a9B9NIZ!FK&iKM4t*)ڴT֨nI-paT+Vx<	kȻs^6(O.BTkCquM˱e(gX^H<\0'˪هҋ .aX2kIjU-n(N.-ۖ /\?]B%D,}k
.&/ \:a,Wn'"Ĺ}X+6`laK\nF/$\N{_I/r4)&ͧ	"*W0^ sĽ_XV}ajah?Z6/c^,Z|XW;%ۃj<mp>65mQnQ)э.
>C5ڧRii+2q	=(&aSI
JT}$taC{C'Gͮ(֐/qvsb}],C`XLOA|9tXs>}\(bzOǢ<%,a?UjLt9&u$jwGӼN5?qRHnȲRzYnNiB\4
N2b`zo+8Z(&47Sӥ܋xa}]X&5DKY[mƭ^܂א@%kQL5:j}>Ѫk6829d({Hou):p;[1Mb.-i5f/D`b2Yf)XoۄSn]x;rĉڴA݇w:.r&iEV/ދ{cu֞rIJ]ݲyv d`YdU3y(X6dbwc)u -n{jlJ3
!>ThvsZ0(>Be$&n#8'"w<F5rNPk.T]È'0[<^܏L6BHBo	2 'gD96R)<4"+kQ')O:ӱ). m<i>H68HgYqS=W,n#1iX|	_ڈ>L<ݗ_W(zw=s)[b>,/=-><,6ƒЀBKSՙ99ES^x--|'jAK-_!7H]yy݁"~pCCj)PX<ZCjʚnf:.9SB
GY6!1"$izppI*;%F䝟eP/I#&iJ{J`Bf,*Ftȃ?Y>'ZLGPeUf__)u#Xs2@Ȩ9oHJ-(6J'+yyL'eb21ِJ|GVK	caPL<@v"퓸0USn
5wa3}N!z6uMa3xXQ,1"w3rѳjAl-YekIPVYٻwWhH{$v5#k'lEuY[GjሐA;nؒK\D6կ
@$cH=bYLo<RfC?VذGjʸԆUPx߬A;w`]h[S<Rfc/(L'	#ӯE5:J.f9;"]6: Ӹ37dp)C:
O]
kٗG?GkOLbOD\!ܟMnEx0nFROU7_+h	op-xeY-6Ǫѳ3g-)nރl8A~QjE^(SxچY:/**9X1Sl0v.M99C`amυMAݥlK\a){jå%uR>.PrUU1PKe	  *  PK    !             - 	 org/gradle/wrapper/GradleUserHomeLookup.classUT     R]OA=C+~XQPTdU(	ۍCEbRZv~ev!cF?xh/3sϜsw_Ǌvޗֈ[ԭ[L00&y$cˡkH(NXH/u=r_FvK?H=x({%p܀HT̵o7æV(uTYz$*t=2_+E̽I؍I>pFfXHVRNswzkoﴚn<k
T[$sH@۲<7pKIOR׳IPޚp+8r	3 PLZ}4\U(N/@١
H`vY˸Rp60K3kEԬV*0Wg%ʔh(qO	wʼhS|`GVp՛@;,r? PKAs	    PK    !             * 	 org/gradle/wrapper/GradleWrapperMain.classUT     Y	|o4Ҍa+N"B$D-C_INr4FG.]z=aD6J!@K/BMOztl˖C{߻oÏ)t7toxCM=lb5h_M}MLz6nI3f`=m$=c`s@Fp&ԄDƨ&`\0z7^"~_.Bf@ x0T?V6cƑ7LZKG-L7Xh<tVu֩S
LsՏ	=߸Z#U$'4??<ߓLlijkBdҘFvŴXl3m5ZFƈPTM,*h6Ӓ*4ijlΟv.WWJǴp&(3Ul،ZƄbDSFqOwOtgB39ih@[Bhh
0qf|$	1Q'kCiFBXU)Pb5NUL.|:jM<TOA9f.=; #^ C@E&Ã5tFi-S}ցi{^ "V6Vz
RQR&Ex2[Ax*lx^fjѨZmF*vADm:p^8@`DpdFFN6tZP23N%4s#b#m;-Pbg/RGqt2ba dB5`ۯ>: 뉄ytOp<9(^0_^&́VpL]%f\٧A#}/86Bz?
v*SRH&(:FV4VT	+2C
CtiE&'1cd6C~ϟ0ۯ-9$vCGDΨmPz32trFzb[7b_]=#xaZQb KY-:]&iTAy;mfZlV(RN}JNa[ BRm5	;.ng>nnZu}ϴaygpik,Nkco
1M~Ťhٮ#k^>Ĥ[L&+|GTJ8ڋ.X
o0[AONzR}pf]}ُ_Ptvg&cYzPsLR0IH 4`pMT<^z5G7ut
!ܻ:Q6[_D5S%;'>IʞbZ+Y]iHxQx)F_ZLmAMTTOŌc;eP^A	]}SrL yMj.qrrzQp][.rwjgD<C<(~R-~j3Q:+f*F4/DCu;iTQZrDL_  ~K5q;,+d ??F%3i^uq0ad;bIEv0?2.xZthO<,vVTY\ƛabgV5v[(\cZ6h/؃.<7 !B+<s)4T^0CN 1Ve$hq;cWN
cpDdr
1كi#Qp=Z7qC-iOf<jL!g^xiZ×L*hǢFZ٬Q\"֣AE]PFƟ2 ?bԐ
&t3{ܠDoi}hkws[ОCvv{oƹA4VmY\R STy;lFꈇ6 fFɴ,P:0z0iU=fH	:m_Lݟ~jm95lCҳ|!ሇDkb/5eH.?ڏќh/ʲZ3QcKҔZ-\Zpt3 aKzLDy,GUa%15ӇwǓ)
wxxsh3#be3ZBYidMk夶mnc^T&T71}q rr7!˚mɬoPue7Kx)to䷠Eٛ[Sf~0aFoAR*.	Ӕ=8ӒeI
P5+k6vt~um>x`mXF[%,-ꙓUy|w1f!Z@?,")7CrǼ"GcŲ6~%ߑVR:ß '>lqEuhs'EϠ*=(2ɘS];VH&GlQ@^5{Qxq,eGkhSbi_!Y:'별=6ψ>_pg:`ZZ'gR/*jef:
5~o]Ҡ>~_s4$UJaPu8d}|F񜽎	ݹT9pRmLAf.4mm?V3~v0_ތe۲/Z׆]SȸV?#'?sZ6;XqQ)ͤmI뮓8}T_hsQo5=2P&]FՌeTk~IiYA4
CJJf"-AG/3mM*[ք1rnmjH/b ̆řIƠ"?M嫌EC=|OJT)ex$S08^URPxzifAĚ1V$&i"ymiĥPNVS.%4n%.N
VpQFi3=W|X&C3=%=ǛI;mZ[eӤyj/d_)dl+%T)]
 ̶({.j`@iɈ:pcv|BPGb7R4v/JB,d|rT'=`VFÜštsQ|V6FX
imɝD)"+02C̗%cAڨI+*b#]*R`>:ۘa݂j폧˓KUocQɧZF?ex-NBRԂAB(f^g2OO$P~,?^Y*!P#(wG|J]8zBKF~uCyD(1RS}'8B	N0]֊\&t22Qn(`d߮}i3鏚1-WҜ`m_},t=C~lJr-]mF3wjf27Y|E4]d-x$*9R^"HV94'OyZpVVb(]mb
S1jtiՇW߷pUWGhOh_:($E"h\e)^UwuX͈սŕVH pn푐<FD'<9BcH#cL!=Χ}N3LtHӉqRbRWy<S<}5>sn7My:Xlj|<}O ,$@'@}kl׃h!vS,2B?? C*yq'hECn嶠sKPoGwyz9O{OC<8yl/ujꃺ^絓>g*_#$V-QCEV-!k3j >5gNNz)S3U hyf{OS,5Fy	y^^EuT)yyq>ŧ8U!"_S09	#WVEx\'SrVE	,V7	_z0&c7Fi/=eL|[z};pi ?cf؝c8AEf0"^뼼k{F9ĂY#]:DSQ:hw<1H~EF86'p'?XbND κ~sp
H	~Oomu±g\ն΅|{qOL0Պe`dF<7zH_{1N$맪U0[
^?Gˇl)x	>*Ы43`J{BO t%BB5	|$}ΰQ+[YsM"tPk	?	 O>V
t ;|-_v+߸V1i߲C^;^C$ӛN)>)SX|ݴmWyEt=EK
V7kä)]<=avhAr:0ۢy%U$HTQD:OGVX9LN?MǤȁ0 Ru-8{FEyiWZ[	;E=^i5/U=M{ezw8 yը&T6y:U1㕶Xi^J;%*_,jkͧJvNJ;'`3 ^U#S8W9"UuO<Utr
Hʳ._/ҵЕ#rt5Xϵsz<;\ayk<2uNT.W[NeVbֳ_Q<D_$.r>@'ϻC'C,fh=GsYJ*y)ŴᧅsyuJ;vb -q[x-u|je
ЅrV^KT'7S| GQ.?FaZ#O/Zt
_Υ6:rnM0]꼖y.w6;fW%RNjs]*6+ԡHە+ЗDPK  )  PK    !             " 	 org/gradle/wrapper/Install$1.classUT     W|[eI{{m}ҽnmڽZ0[R(e%ۤ&ݒrsnDDDQP]Z(0@`<|I|oXqk]V٩pe2UY[fDwL+Zam#bq6{?cxeKčnT\4ܹ2]H=u1ðX7n58ɢeuK+TJ!L3b̰n[G>[5X#y	mַ=]^f#()WYP¶SDdzgPV=2/b7%mb$3zO(3a36mf	z;2J3k.;aK
,haH{
6e%|ǌ[H"J[V19Uw.,ޱX.%5oL^LBpW1])fkPP!G'MZ2>d7&tVQ0c'DQ%006snU[AV=j uQXX_u#iӢ",fiK:kձR8`ܜ#E.
q^qHreo)8wO#u8sbeji$2veg܊$cx:eGO	BF2r!dw13Yqyią|׌5sN<N"璶gYQryX3Lm;FTZaӽ.U{i鐮%a}p.݌$l\M)S+a.DmJMtP+(Cq11L!+:SaQP"z<N"$\$t\YIdW}qCc["h3j]e	ΙV`qz
c{a &+4&q	#lo!
qBy>lӰZaıj2\DCrYiۺd:qH!UWS|ʁ(a:Ѣ$2F:q>[z2}jlsN-"ǘ\	syfc6H\wEn[pk9djNJpTT*.;;|Gv>5|<JHǥ NA&|6LUOgPUwmM͙]K{Q̮XMD!9}9ml5.&aiIZb۠*JD{Ex FCdmFDWaᵆ.#IkY4Gdx\cWMz'`/%/Upd^<PĊSܦiJ&+	W,ekOʦR:ȡL<K]z̬qb7~4h3ל:/qdr܊Hd*\c[}!-']Խx2^%x]fSP9F RQ}*~[md۵$_!:NayTwgV_\?S4:2:=۶n3.IPz1kf,sL;LEaatS^*RE9Fo2b&+/pɁDn< $<+hP׷.٦(ݑ#es&nb	=sictN9QBm4ڡI3k %&29THʦi(1m"kbT1:AX#7ތeLU9[TecrToY9JNU8A,&AMU^+jj@"7
cJ8|+ZE8\T:K蓓X(&b52z(#hb)7
d+[QEq#	dfǚn T,#C:6}%#0dmȚڠ'ڬ3SL:DӰױyh#ST̯-7%!$w]t=j'8:i/o7ƴ(g7fabTbnγdw#lĴ$&X1Z.LbiI#KbV<PDS?f
ʃI9ใ8?غkvlLBO"^ntbZ f,Ĭ` 6ADQo,KjK'	g
qi@@3W>u:m|-ޅ>̻8 .i>t5^1pUP}@F~,/	<J.	hW!>)_$a|}Г_ )ø$3R{YASZy*P$;{ǇꈔS}?
¬r71c~<}II<S ZO>^StƯxQk2jGik["5eweꎃg"OάSE` Za$&~z%5u?wA#.9ԖW*D1?);چ*IQ܏-l|(ha('G3u{Q/jPOi#$\
܁ѯỴ)aQDaQ*eAmuMR,n%LV}#bi3H4TKIR<HBz*.'~;ie8$|$O×M	ƻ~ C걚T		+r	Ok%^<a$^ 6	o>$	8 gĳ? ^guq\H!㷺%ΐ]H!;]J!\%ΐ!דgӮ$ΐ]/K!㯺ސ8Cr'qt%ΐpMT7<CյnlD=DǵTaob~h
jxE7&(&0u\PڀE(u9>e1ŽS1}!|MR[Vq PK"    PK    !             - 	 org/gradle/wrapper/Install$InstallCheck.classUT     eJ1XZjm܍V;^AAApΜNɴ.Dķp!TED;B`s;%JBwn8SZ*M8uC%H
nl7N[jK7Xf*<65͟vWklGzD*!2*X푱|͵͵RϽ\]С$ȏ5Ff8z;+cP`Zegk
2k(ٯzgT,]Cd:uȋ25,,5/JK1`BAcE5-0xun3W,8:<J&W1xGK}'PKJj    PK    !               	 org/gradle/wrapper/Install.classUT     X|Su?I|"bp%06$1bU !ҵ}A׽
pn#nڦhl-SZثɖuudֽH|lˤӹ|;_Χ&1]8{'ZIʶtd[[2v~i[ɼ509Cw,n23jdN=\el$ǒ0ߝ^g[ep!Ä;'7
5bZfO0csǶd8dINƸL+mgsѳ9󴣏Ngzz.$?)3[#N/HuLu9{dpVjOL}ziM-]e4dr<dݫ[:ͦ:ؙ3'qn{Lv2=԰q]#?|´jԤ2jSS)Du[4Z(_+N]Za,;tGJ9Ӵ;Hvhue'0ߎ^_Nw]X[,5#Lb(S !\eôZ5ZKw15+ւg:\x Ř7>ʉSp`Q;XspBC{:<ث馔ѕ mho2(a;aRr+ֳts,5;8vmvʹxA)h"aI^ɣY09PA.]ꮏfmÍZؖVTV4܎3c٨gGM+5/787\wa\@qù\aMk`Z="(HLkcoHN57hô 5_j.cGWđ@xmEt* rP&8m5kBAOwmQ	f<I05ptiϛ#H45v:rsxʵiK{lJFx^/d]!A2Z782`Nh4J'VTko<0|f*_Ec쀵PBĎ
=*h)DSa,{9~wEٮғ`*}!Y7Lw
Wqoe*F(79QZT!γ4ΔAtKwK)GGiaJb~c}swO.cJyv~@v>2]j!~DtA2.=~aZvRHXK?<̨6,j
$dlZ4:<y}<:2CaE==F9mzVmN>~̓:a_sllƣq9,dQ^GJ5]#	 +[a
ۣÎG{N,窾C.U}N;Zx쒍Jyңv1ўYO̓3cLgf	B{QkjkLH2L?G?]`=n"Y{nvt>l]4,OSdF;*G:LҔ4C^Kx cwC* Yi>CЖq+/
+s5ǃ%L/KH|^AۢJrtyH襢-)7Ϲ
-tPJ-'˟D]_B©80<,UecM3W__"7=[PheCfL2uRMW:1OZ (O0_Hs<)5E	\~~IWB.jbo$"RCwL:ϙ }K{$Lߖx'gdۃxpJT_+MШcև`rA
T
?zH<(/3:_`Yy`
E yJoХYǀ/\ 14J! |]&nnr=`/x=Lfi3sXEJڼoUI%p/<w2=TEK)5n3| /*=PgI+y^Io)-+O"o;x5BmapzF 1-@2T!n$9B\;*@0oK90p5qӶs]@^0':uVc7͐ѳe0o)-!5MxÙ#NZ(ށ
xk!N ͪ45;fɷpq/6vSC.dJ[J#8Vya֜?̎ua*~#v Eͫ&xxo5Tgxc?xl8Q;B<t"D2F0eչA5?!>ԕ[Wru4GWGcxn[3L[Cu:jЛCbF`feME2\2-c_!?d8DmDU>jAhŴ9F]Oƫ,=0I+"q"Wh%zZMkJl]#EZ)JL}"mLBu7JөINVs&ߔ<i>v9%/[SY
|탍)zp*I8>I{'簍}/ёub~m:7'a({b	utL|ҩiIYO6M_>bh $>1o<|t
z/f'`oÜ7WOʖZu_!)JV۟7,τXtzk3Ԙ|uEzb֦4-(fZ2/" Izʷ5H^{:́t'ݍ?.n(@<>x\ R9WJt.ϥbn/>O뒃?,|J@3-jgm2m^^wetb5q:߽jl<z;E.Pup^|\4Keo-GsWJ:jiu9|2K0}H1E_PyZ"#78AGۓWxf	Lk,}Tčo&e'79I_o/_^Pګ,LUZVENEwES_уtLct%iXQ-{_{?}Dђ_4oTlSח%7~s?T)&7b8:doVA r{<By Qd_D`Ȱ$JAǛ8xq*:'FbP,+ xW?-qwy]uyCV]E4Ew+TߥE
aD7}E=\[j?u+wS2~ _)\k?Z\.FW20\+HDB@$ L&>4ɇ'"H yj!b8y%d-M6#(74q|&8[t|GWK~B|+ǯSFmΨP'xBWcz^'Dej,ToP2VTܥBe᧕h
>J8E>`*K- wPK?>g    PK    !              	 org/gradle/wrapper/Logger.classUT     kOAB)B	[[XVĄQcFM^^0Wњ2EHچ9?	SM^!}[5
	|\dSF$0JHޗnDkz6<2O7[K~Pv|mSK[%AQt-HB^8.	,mڡld~eEYlBSXmUXCJ`"	!.i9JĞ@;3^aW`(_ ih 1 3n`ykZGYqj}b41$3A|)^9X<f4
~˘Mc	dyGk4eX|ʅjŗ̫"W+߻ٝWC},(ˇ|e`s}UUjwd7īSVj'b3y\HTB]Y`u5>Enq\;]a+vw/X1oHa*f:؄Cg`a_^wPK]o;    PK    !             & 	 org/gradle/wrapper/PathAssembler.classUT     UJ@gMZE@S+MC 'AQ}&n6a7[x< >8=8Y N`fs=X%OE^*-*U /$nQpHpP.*w|:ဗi2P'I<+	L:bRe2)5ZGoa$>0be%^+
ъDމ*tXmCBEIxjCA\U]08T[ϺCmaи/dbt|ئK#mA7P-PK)>$  j  PK    !             0 	 org/gradle/wrapper/SystemPropertiesHandler.classUT     T[wUM;qB	knE-xP/x29INfLZX]W^y,Z}Rڦf}oW `|dpkUtʪ)klM*$lp߰ZM?5]/Vha+rr2Ec_k;~[]!	]ҧX'&FU~1e--qvC֓B]#
뒷ZBʏ@4oK-9Xj0?kp^X<Vaa.V=m+`3c;5pAgjv1@:s/8xOäjŐ8F08N0s:ƕ~O%ʁ4u0^oHm*é=>;8$-E)UB)U,'.&{4dv $<prmNrǐ0rXţ }\\e;^FL>/!exT%q6JE\ѡa!rb2س&b=c>T?g:>uvXtdcViߤ^;1JJ%jفy,,!xtu_)./3$m7b%Zpg}]oNU=ZY)=\o7HdkZ_KK{tcPDh?ڱ/*;|\<PxH}ȝyew*:¢cw꧅ܠ.r'#J:Il1s7Cmb0q\T	s1o΄8BL2ʾSLGbk!n<ˠX/H[?o;Dg[?C/kvbf|<A%'eAwOnaPK%  N  PK    !             - 	 org/gradle/wrapper/WrapperConfiguration.classUT     }mOAgR*r}RA'Ŵm\kI4A~ ?qw=lٝovwf?`	|f>yZ`jQ\%qF,hPSdE+2י¨0XFPfV1ĕU6#VdV2|zK5E	Ls\Jʘ.֙nZ8MfEV?級^`ejtZTXR*S,%Y={C xN4PUJYB/(.k\G TLfVjo	eʙ|7,nʕRV!}/WLܳ\R/LdH*rl%ѡ`@:XH!nV^d7wwsٳv}0*nAwJg /@0`y Aq a#3w.^;)q}t]o`(w+&ujGfG۴"@u4Dx?q7ZVZƎXF^{Oljڏ4^1?O섧lk9<_8 M+ض߶ߴzAwGiJFǧa$|so{hSD q;AЛn$AqǮϹ>/8;K?q'<O:;>+O}k`w|6\?M7n,KvAPK  P  PK    !             ( 	 org/gradle/wrapper/WrapperExecutor.classUT     VwU]BX6MvJ7S:M^ҡ83i
JQTPV*f&iS{~w{0vtoj"-OBȊdʚNk	N:WdpZp|ǇllKJCL*2aY[7%6ޜ'BƠ^/TԔrjfn/onN)7'e8#+!HJ
R&!G.T2,<&KERSc<nPM2F%N֔Hv-|GS"bLqMM)iu͡ Ȫl>PW_j|*z1=pͅEԢ/Ax抯8\XEAQ0uVO((E <d!y:kt@:#\5~yFh@P8ndh.HVM,dE䟈D*.qg8Ma]"GIf@o;:aK,2ԗjm&Q͔`Hΐ0,JZ^l4b\Aq~f]|vi-2fdX\ƴHqNKG253''fzsObAi-lڍeLOzfzO>I/2fu	 r&Jͅ;;D"3NbNL}4mM?';	O%!.nh~9͵iv/R:2Ce}hȌx1$*40 %ENH&vJ!p}! +ΘhQ](AoV5)ݣqq6-$fE纛ЊI]KuMn.NQ]xWRӒY~o~+?//^«aumD=87hT<˰紫IFvBɷ$;U.GdhEm+CGJU\*hb~&.Oq\n|ΰ\(.d٥%%#9*I'ZA_&v
vH-n|=t'E3k/%\Ex.]WŏTsHG*~'B.ݸ&{%&B$VMgm%r3ApXJFO+*U錺WqWmIO.X@ sa*i`c07XkobM,<`86GPi!D,l5`{c|idnIPix8x,Q1iY0-X8y:'q*VyXWEcBxquJ-V\hC-{pĖG1dK'lyglyQȓQRAr$:Cq𱅱$\^'E5#%x},|uޠlia*~w!Ziq!YŶk<gߟM&$5n"m/	\	~Zi%O2넽ޚ"lݗqF"!.W^EU1TltR5m2Bp}PKYaS    PK     !   '   	               META-INF/LICENSEUT     PK     ! m>=@   ?    	           0  META-INF/MANIFEST.MFUT     PK     ! `zX!  p  1 	             org/gradle/cli/CommandLineArgumentException.classUT     PK     ! ×n    & 	           D  org/gradle/cli/CommandLineOption.classUT     PK     ! d Z    3 	             org/gradle/cli/CommandLineParser$AfterOptions.classUT     PK     ! 1,  ]  < 	             org/gradle/cli/CommandLineParser$BeforeFirstSubCommand.classUT     PK     !   b  = 	           r  org/gradle/cli/CommandLineParser$KnownOptionParserState.classUT     PK     ! C'|L    < 	              org/gradle/cli/CommandLineParser$MissingOptionArgState.classUT     PK     ! [  J  = 	           #  org/gradle/cli/CommandLineParser$OptionAwareParserState.classUT     PK     ! u[z?  }  8 	           &  org/gradle/cli/CommandLineParser$OptionParserState.classUT     PK     !   C  3 	           (  org/gradle/cli/CommandLineParser$OptionString.classUT     PK     ! ɉ    2 	           W+  org/gradle/cli/CommandLineParser$ParserState.classUT     PK     ! Kϖs    ? 	           g-  org/gradle/cli/CommandLineParser$UnknownOptionParserState.classUT     PK     !   c  & 	           P0  org/gradle/cli/CommandLineParser.classUT     PK     ! 2w:    & 	           \5  org/gradle/cli/ParsedCommandLine.classUT     PK     ! ZvmT    , 	           9  org/gradle/cli/ParsedCommandLineOption.classUT     PK     ! $O    3 	           ;  org/gradle/internal/file/PathTraversalChecker.classUT     PK     ! ywʇ    A 	           ?  org/gradle/internal/file/locking/ExclusiveFileAccessManager.classUT     PK     ! b    > 	           A  org/gradle/util/internal/WrapperDistributionUrlConverter.classUT     PK     ! EҚ    / 	           HC  org/gradle/wrapper/BootstrapMainStarter$1.classUT     PK     ! %)    A 	           <E  org/gradle/wrapper/Download$DefaultDownloadProgressListener.classUT     PK     ! w&    4 	           H  org/gradle/wrapper/Download$ProxyAuthenticator.classUT     PK     ! e	  *  ! 	           -L  org/gradle/wrapper/Download.classUT     PK     ! As	    - 	           U  org/gradle/wrapper/GradleUserHomeLookup.classUT     PK     !   )  * 	           'X  org/gradle/wrapper/GradleWrapperMain.classUT     PK     ! "    " 	           m  org/gradle/wrapper/Install$1.classUT     PK     ! Jj    - 	           y  org/gradle/wrapper/Install$InstallCheck.classUT     PK     ! ?>g      	           {  org/gradle/wrapper/Install.classUT     PK     ! ]o;     	           ~  org/gradle/wrapper/Logger.classUT     PK     ! )>$  j  & 	             org/gradle/wrapper/PathAssembler.classUT     PK     ! %  N  0 	             org/gradle/wrapper/SystemPropertiesHandler.classUT     PK     !   P  - 	             org/gradle/wrapper/WrapperConfiguration.classUT     PK     ! YaS    ( 	             org/gradle/wrapper/WrapperExecutor.classUT     PK    ! !       

===== File: ./settings.gradle =====
// settings.gradle
pluginManagement {
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
        // ВОТ ЭТА СТРОКА КРИТИЧНА:
        maven { url 'https://jitpack.io' }
    }
}
rootProject.name = "android-hello-world-app" // Убедитесь, что остальное тоже на месте
include ':app' // Убедитесь, что остальное тоже на месте


===== File: ./gradlew.bat =====
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega


===== File: ./all_files.txt =====
# app/build.gradle
plugins {
    id 'com.android.application'
    id 'org.jetbrains.kotlin.android'
}

android {
    namespace 'com.example.helloworld' // Added namespace
    compileSdk 34

    defaultConfig {
        applicationId "com.example.helloworld"
        minSdk 24
        targetSdk 34
        versionCode 1
        versionName "1.0"
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_17
        targetCompatibility JavaVersion.VERSION_17
    }
    kotlinOptions {
        jvmTarget = '17'
    }
}

dependencies {
    implementation 'androidx.core:core-ktx:1.12.0'
    implementation 'androidx.appcompat:appcompat:1.6.1'
    implementation 'com.google.android.material:material:1.10.0'
    implementation 'androidx.constraintlayout:constraintlayout:2.1.4'
}

# app/src/main/AndroidManifest.xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.helloworld">

    <uses-permission android:name="android.permission.CAMERA"/>
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
    <uses-permission android:name="android.permission.READ_MEDIA_IMAGES"/>

    <uses-feature android:name="android.hardware.camera" android:required="true"/>

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.HelloWorld">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:configChanges="orientation|screenSize">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>

# app/src/main/java/com/example/helloworld/LayerAdapter.java
package com.example.helloworld;

import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.CheckBox;
import android.widget.TextView;
import androidx.annotation.NonNull;
import androidx.recyclerview.widget.RecyclerView;

public class LayerAdapter extends RecyclerView.Adapter<LayerAdapter.ViewHolder> {

    private final String[] layers;
    private final boolean[] visibility;
    private final OnLayerVisibilityChangedListener listener;

    public interface OnLayerVisibilityChangedListener {
        void onLayerVisibilityChanged(int position, boolean isVisible);
    }

    public LayerAdapter(String[] layers, boolean[] visibility, OnLayerVisibilityChangedListener listener) {
        this.layers = layers;
        this.visibility = visibility;
        this.listener = listener;
    }

    @NonNull
    @Override
    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(parent.getContext())
                .inflate(android.R.layout.simple_list_item_2, parent, false);
        return new ViewHolder(view);
    }

    @Override
    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
        holder.text1.setText(layers[position]);
        holder.checkBox.setChecked(visibility[position]);
        holder.checkBox.setOnCheckedChangeListener((buttonView, isChecked) -> {
            visibility[position] = isChecked;
            if (listener != null) {
                listener.onLayerVisibilityChanged(position, isChecked);
            }
        });
    }

    @Override
    public int getItemCount() {
        return layers.length;
    }

    static class ViewHolder extends RecyclerView.ViewHolder {
        TextView text1;
        CheckBox checkBox;

        ViewHolder(View itemView) {
            super(itemView);
            text1 = itemView.findViewById(android.R.id.text1);
            checkBox = new CheckBox(itemView.getContext());
            ViewGroup parent = (ViewGroup) text1.getParent();
            parent.addView(checkBox);
        }
    }
}

# app/src/main/java/com/example/helloworld/MainActivity.java
package com.example.helloworld;

import android.Manifest;
import android.app.Dialog;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.res.Configuration;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.ColorMatrix;
import android.graphics.ColorMatrixColorFilter;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.hardware.camera2.CameraAccessException;
import android.hardware.camera2.CameraCaptureSession;
import android.hardware.camera2.CameraCharacteristics;
import android.hardware.camera2.CameraDevice;
import android.hardware.camera2.CameraManager;
import android.hardware.camera2.CaptureRequest;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.HandlerThread;
import android.provider.MediaStore;
import android.util.Log;
import android.util.Size;
import android.view.MotionEvent;
import android.view.ScaleGestureDetector;
import android.view.Surface;
import android.view.SurfaceHolder;
import android.view.SurfaceView;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.ImageView;
import android.widget.SeekBar;
import android.widget.Switch;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.app.ActivityCompat;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Arrays;
import java.util.concurrent.Semaphore;

public class MainActivity extends AppCompatActivity implements LayerAdapter.OnLayerVisibilityChangedListener {

    private static final String TAG = "MainActivity";
    private static final int REQUEST_CAMERA_PERMISSION = 100;
    private static final int REQUEST_STORAGE_PERMISSION = 101;
    private static final int PICK_IMAGE_REQUEST = 1;

    private SurfaceView cameraSurfaceView;
    private ImageView imageView;
    private SeekBar transparencySeekBar;
    private Button pickImageButton;
    private Switch pencilModeSwitch;
    private Button layerSelectButton;
    private CheckBox controlsVisibilityCheckbox;
    private CheckBox hideImageCheckbox;
    private Button saveParametersButton;
    private Button loadParametersButton;
    private Button switchCameraButton;

    private CameraDevice cameraDevice;
    private CameraCaptureSession cameraCaptureSession;
    private CaptureRequest.Builder previewRequestBuilder;
    private String cameraId;
    private Size previewSize;
    private HandlerThread backgroundThread;
    private Handler backgroundHandler;
    private final Semaphore cameraOpenCloseLock = new Semaphore(1);
    private volatile boolean isSurfaceAvailable = false;
    private volatile boolean isCameraPendingOpen = false;
    private volatile boolean isCameraOpen = false;

    private Bitmap originalBitmap;
    private Bitmap pencilBitmap;
    private Bitmap[] layerBitmaps;
    private boolean[] layerVisibility;
    private Matrix matrix = new Matrix();
    private float scaleFactor = 1.0f;
    private float rotationAngle = 0.0f;
    private boolean isPencilMode = false;
    private boolean isImageVisible = true;
    private ScaleGestureDetector scaleGestureDetector;
    private float lastTouchX, lastTouchY;
    private boolean isDragging = false;

    private String[] cameraIds;
    private int currentCameraIndex = 0;

    private static final String[] PENCIL_HARDNESS = {
            "9H", "8H", "7H", "6H", "5H", "4H", "3H", "2H", "H", "F",
            "HB", "B", "2B", "3B", "4B", "5B", "6B", "7B", "8B", "9B"
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        cameraSurfaceView = findViewById(R.id.cameraSurfaceView);
        imageView = findViewById(R.id.imageView);
        transparencySeekBar = findViewById(R.id.transparencySeekBar);
        pickImageButton = findViewById(R.id.pickImageButton);
        pencilModeSwitch = findViewById(R.id.pencilModeSwitch);
        layerSelectButton = findViewById(R.id.layerSelectButton);
        controlsVisibilityCheckbox = findViewById(R.id.controlsVisibilityCheckbox);
        hideImageCheckbox = findViewById(R.id.hideImageCheckbox);
        saveParametersButton = findViewById(R.id.saveParametersButton);
        loadParametersButton = findViewById(R.id.loadParametersButton);
        switchCameraButton = findViewById(R.id.switchCameraButton);

        scaleGestureDetector = new ScaleGestureDetector(this, new ScaleGestureDetector.SimpleOnScaleGestureListener() {
            @Override
            public boolean onScale(ScaleGestureDetector detector) {
                scaleFactor *= detector.getScaleFactor();
                scaleFactor = Math.max(0.1f, Math.min(scaleFactor, 5.0f));
                matrix.postScale(detector.getScaleFactor(), detector.getScaleFactor(), detector.getFocusX(), detector.getFocusY());
                applyTransformations();
                return true;
            }
        });

        imageView.setOnTouchListener((v, event) -> {
            scaleGestureDetector.onTouchEvent(event);
            switch (event.getAction()) {
                case MotionEvent.ACTION_DOWN:
                    lastTouchX = event.getX();
                    lastTouchY = event.getY();
                    isDragging = true;
                    break;
                case MotionEvent.ACTION_MOVE:
                    if (isDragging) {
                        float dx = event.getX() - lastTouchX;
                        float dy = event.getY() - lastTouchY;
                        matrix.postTranslate(dx, dy);
                        applyTransformations();
                        lastTouchX = event.getX();
                        lastTouchY = event.getY();
                    }
                    break;
                case MotionEvent.ACTION_UP:
                case MotionEvent.ACTION_CANCEL:
                    isDragging = false;
                    break;
            }
            return true;
        });

        cameraSurfaceView.getHolder().addCallback(new SurfaceHolder.Callback() {
            @Override
            public void surfaceCreated(SurfaceHolder holder) {
                Log.d(TAG, "Surface created");
                isSurfaceAvailable = true;
                if (isCameraPendingOpen && !isCameraOpen) {
                    openCamera();
                    isCameraPendingOpen = false;
                }
            }

            @Override
            public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
                Log.d(TAG, "Surface changed: " + width + "x" + height);
                adjustSurfaceViewAspectRatioWithCropping(width, height);
                if (cameraDevice != null && isSurfaceAvailable) {
                    closeCameraPreviewSession();
                    previewSize = chooseOptimalPreviewSize(getPreviewSizes(), width, height);
                    createCameraPreviewSession();
                }
            }

            @Override
            public void surfaceDestroyed(SurfaceHolder holder) {
                Log.d(TAG, "Surface destroyed");
                isSurfaceAvailable = false;
                closeCamera();
            }
        });

        transparencySeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
            @Override
            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
                setImageAlpha(progress);
            }

            @Override
            public void onStartTrackingTouch(SeekBar seekBar) {}

            @Override
            public void onStopTrackingTouch(SeekBar seekBar) {}
        });

        pickImageButton.setOnClickListener(v -> pickImage());

        pencilModeSwitch.setOnCheckedChangeListener((buttonView, isChecked) -> {
            isPencilMode = isChecked;
            layerSelectButton.setVisibility(isChecked ? View.VISIBLE : View.GONE);
            if (isPencilMode) {
                processPencilEffect();
            }
            updateImageDisplay();
        });

        layerSelectButton.setOnClickListener(v -> showLayerSelectionDialog());

        controlsVisibilityCheckbox.setOnCheckedChangeListener((buttonView, isChecked) -> {
            int visibility = isChecked ? View.VISIBLE : View.GONE;
            transparencySeekBar.setVisibility(visibility);
            pickImageButton.setVisibility(visibility);
            pencilModeSwitch.setVisibility(visibility);
            layerSelectButton.setVisibility(isPencilMode && isChecked ? View.VISIBLE : View.GONE);
            hideImageCheckbox.setVisibility(visibility);
            saveParametersButton.setVisibility(visibility);
            loadParametersButton.setVisibility(visibility);
            switchCameraButton.setVisibility(visibility);
        });

        hideImageCheckbox.setOnCheckedChangeListener((buttonView, isChecked) -> {
            isImageVisible = !isChecked;
            updateImageDisplay();
        });

        saveParametersButton.setOnClickListener(v -> saveParameters());

        loadParametersButton.setOnClickListener(v -> loadParameters());

        switchCameraButton.setOnClickListener(v -> switchCamera());

        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.CAMERA}, REQUEST_CAMERA_PERMISSION);
        } else {
            isCameraPendingOpen = true;
        }

        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED ||
                ActivityCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE}, REQUEST_STORAGE_PERMISSION);
        }

        // Инициализация списка камер
        CameraManager manager = (CameraManager) getSystemService(CAMERA_SERVICE);
        try {
            cameraIds = manager.getCameraIdList();
            if (cameraIds.length > 0) {
                cameraId = cameraIds[0];
            }
        } catch (CameraAccessException e) {
            Log.e(TAG, "Error accessing camera list", e);
            Toast.makeText(this, "Cannot access cameras", Toast.LENGTH_LONG).show();
        }

        // Инициализация layerVisibility
        layerVisibility = new boolean[20];
        Arrays.fill(layerVisibility, true);
    }

    private void adjustSurfaceViewAspectRatioWithCropping(int width, int height) {
        if (previewSize == null) {
            return;
        }

        float previewRatio = (float) previewSize.getWidth() / previewSize.getHeight();
        float viewRatio = (float) width / height;

        int newWidth, newHeight;
        if (previewRatio > viewRatio) {
            newWidth = width;
            newHeight = (int) (width / previewRatio);
        } else {
            newHeight = height;
            newWidth = (int) (height * previewRatio);
        }

        ViewGroup.LayoutParams params = cameraSurfaceView.getLayoutParams();
        params.width = width;
        params.height = height;
        cameraSurfaceView.setLayoutParams(params);

        float scaleX = (float) width / newWidth;
        float scaleY = (float) height / newHeight;
        float scale = Math.max(scaleX, scaleY);

        cameraSurfaceView.setScaleX(scale);
        cameraSurfaceView.setScaleY(scale);

        cameraSurfaceView.setPivotX(width / 2f);
        cameraSurfaceView.setPivotY(height / 2f);

        cameraSurfaceView.requestLayout();
        Log.d(TAG, "Adjusted SurfaceView with cropping to " + width + "x" + height + " (preview ratio: " + previewRatio + ")");
    }

    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
        if (requestCode == REQUEST_CAMERA_PERMISSION) {
            if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                if (isSurfaceAvailable && !isCameraOpen) {
                    openCamera();
                } else {
                    isCameraPendingOpen = true;
                }
            } else {
                Toast.makeText(this, "Camera permission is required", Toast.LENGTH_LONG).show();
                finish();
            }
        } else if (requestCode == REQUEST_STORAGE_PERMISSION) {
            if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                // Разрешение получено
            } else {
                Toast.makeText(this, "Storage permission is required", Toast.LENGTH_LONG).show();
            }
        }
    }

    private void startBackgroundThread() {
        if (backgroundThread == null) {
            backgroundThread = new HandlerThread("CameraBackground");
            backgroundThread.start();
            backgroundHandler = new Handler(backgroundThread.getLooper());
        }
    }

    private void stopBackgroundThread() {
        if (backgroundThread != null) {
            backgroundThread.quitSafely();
            try {
                backgroundThread.join();
                backgroundThread = null;
                backgroundHandler = null;
            } catch (InterruptedException e) {
                Log.e(TAG, "Error stopping background thread", e);
            }
        }
    }

    private void openCamera() {
        if (!isSurfaceAvailable || isCameraOpen) {
            Log.d(TAG, "Surface not available or camera already open, setting pending open");
            isCameraPendingOpen = true;
            return;
        }

        startBackgroundThread();
        CameraManager manager = (CameraManager) getSystemService(CAMERA_SERVICE);
        try {
            if (cameraId == null) {
                cameraId = manager.getCameraIdList()[0];
            }
            CameraCharacteristics characteristics = manager.getCameraCharacteristics(cameraId);
            Size[] previewSizes = characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP)
                    .getOutputSizes(SurfaceHolder.class);
            previewSize = chooseOptimalPreviewSize(previewSizes, cameraSurfaceView.getWidth(), cameraSurfaceView.getHeight());

            if (ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {
                return;
            }
            cameraOpenCloseLock.acquire();
            isCameraOpen = true;
            manager.openCamera(cameraId, new CameraDevice.StateCallback() {
                @Override
                public void onOpened(@NonNull CameraDevice camera) {
                    cameraDevice = camera;
                    if (isSurfaceAvailable) {
                        createCameraPreviewSession();
                    } else {
                        Log.d(TAG, "Surface not available after camera opened, closing camera");
                        closeCamera();
                    }
                    cameraOpenCloseLock.release();
                }

                @Override
                public void onDisconnected(@NonNull CameraDevice camera) {
                    cameraOpenCloseLock.release();
                    camera.close();
                    cameraDevice = null;
                    isCameraOpen = false;
                }

                @Override
                public void onError(@NonNull CameraDevice camera, int error) {
                    cameraOpenCloseLock.release();
                    camera.close();
                    cameraDevice = null;
                    isCameraOpen = false;
                    Toast.makeText(MainActivity.this, "Camera error: " + error, Toast.LENGTH_LONG).show();
                }
            }, backgroundHandler);
        } catch (CameraAccessException e) {
            Log.e(TAG, "Cannot access camera", e);
            Toast.makeText(this, "Cannot access camera", Toast.LENGTH_LONG).show();
            isCameraOpen = false;
        } catch (InterruptedException e) {
            Log.e(TAG, "Interrupted while opening camera", e);
            cameraOpenCloseLock.release();
            isCameraOpen = false;
        }
    }

    private Size[] getPreviewSizes() {
        try {
            CameraManager manager = (CameraManager) getSystemService(CAMERA_SERVICE);
            CameraCharacteristics characteristics = manager.getCameraCharacteristics(cameraId);
            return characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP)
                    .getOutputSizes(SurfaceHolder.class);
        } catch (CameraAccessException e) {
            Log.e(TAG, "Error getting preview sizes", e);
            return new Size[]{new Size(1280, 720)};
        }
    }

    private Size chooseOptimalPreviewSize(Size[] choices, int viewWidth, int viewHeight) {
        if (choices == null || choices.length == 0) {
            Log.e(TAG, "No preview sizes available, using default");
            return new Size(1280, 720);
        }

        double targetRatio;
        if (viewWidth > 0 && viewHeight > 0) {
            targetRatio = (double) viewWidth / viewHeight;
        } else {
            targetRatio = 4.0 / 3.0;
        }

        Size optimalSize = null;
        double minDiff = Double.MAX_VALUE;
        int maxArea = 0;

        for (Size size : choices) {
            double ratio = (double) size.getWidth() / size.getHeight();
            int area = size.getWidth() * size.getHeight();
            double ratioDiff = Math.abs(ratio - targetRatio);
            if (ratioDiff < minDiff || (ratioDiff == minDiff && area > maxArea)) {
                optimalSize = size;
                minDiff = ratioDiff;
                maxArea = area;
            }
        }

        if (optimalSize == null) {
            optimalSize = choices[0];
        }

        Log.d(TAG, "Chosen preview size: " + optimalSize.getWidth() + "x" + optimalSize.getHeight());
        return optimalSize;
    }

    private void createCameraPreviewSession() {
        if (!isSurfaceAvailable || cameraDevice == null || !isCameraOpen) {
            Log.d(TAG, "Cannot create preview session: Surface not available, cameraDevice is null, or camera is closed");
            return;
        }

        try {
            SurfaceHolder holder = cameraSurfaceView.getHolder();
            Surface surface = holder.getSurface();
            if (!surface.isValid()) {
                Log.d(TAG, "Surface is not valid, aborting preview session creation");
                return;
            }

            previewRequestBuilder = cameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
            previewRequestBuilder.addTarget(surface);

            cameraDevice.createCaptureSession(Arrays.asList(surface), new CameraCaptureSession.StateCallback() {
                @Override
                public void onConfigured(@NonNull CameraCaptureSession session) {
                    if (cameraDevice == null || !isSurfaceAvailable || !isCameraOpen) {
                        Log.d(TAG, "Camera device closed, surface not available, or camera not open during session configuration");
                        session.close();
                        return;
                    }
                    cameraCaptureSession = session;
                    try {
                        previewRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);
                        cameraCaptureSession.setRepeatingRequest(previewRequestBuilder.build(), null, backgroundHandler);
                        Log.d(TAG, "Camera preview session started");
                    } catch (CameraAccessException e) {
                        Log.e(TAG, "Error setting up camera preview", e);
                    } catch (IllegalStateException e) {
                        Log.e(TAG, "Session already closed during setRepeatingRequest", e);
                    }
                }

                @Override
                public void onConfigureFailed(@NonNull CameraCaptureSession session) {
                    Toast.makeText(MainActivity.this, "Failed to configure camera preview", Toast.LENGTH_LONG).show();
                }
            }, backgroundHandler);
        } catch (CameraAccessException e) {
            Log.e(TAG, "Error creating camera preview session", e);
        }
    }

    private void closeCameraPreviewSession() {
        if (cameraCaptureSession != null) {
            cameraCaptureSession.close();
            cameraCaptureSession = null;
        }
    }

    private void closeCamera() {
        try {
            cameraOpenCloseLock.acquire();
            closeCameraPreviewSession();
            if (cameraDevice != null) {
                cameraDevice.close();
                cameraDevice = null;
            }
            isCameraOpen = false;
        } catch (InterruptedException e) {
            Log.e(TAG, "Error closing camera", e);
        } finally {
            cameraOpenCloseLock.release();
        }
        stopBackgroundThread();
    }

    private void switchCamera() {
        CameraManager manager = (CameraManager) getSystemService(CAMERA_SERVICE);
        try {
            closeCamera();
            currentCameraIndex = (currentCameraIndex + 1) % cameraIds.length;
            cameraId = cameraIds[currentCameraIndex];
            if (isSurfaceAvailable && !isCameraOpen) {
                openCamera();
            } else {
                isCameraPendingOpen = true;
            }
        } catch (Exception e) {
            Log.e(TAG, "Error switching camera", e);
            Toast.makeText(this, "Error switching camera", Toast.LENGTH_LONG).show();
        }
    }

    private void pickImage() {
        Intent intent = new Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI);
        startActivityForResult(intent, PICK_IMAGE_REQUEST);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if (requestCode == PICK_IMAGE_REQUEST && resultCode == RESULT_OK && data != null) {
            Uri imageUri = data.getData();
            try {
                if (originalBitmap != null && !originalBitmap.isRecycled()) {
                    originalBitmap.recycle();
                }
                originalBitmap = MediaStore.Images.Media.getBitmap(getContentResolver(), imageUri);
                resetTransformationsAndFit();
                layerVisibility = new boolean[20];
                Arrays.fill(layerVisibility, true);
                if (isPencilMode) {
                    processPencilEffect();
                }
                updateImageDisplay();
            } catch (IOException e) {
                Log.e(TAG, "Error loading image", e);
                Toast.makeText(this, "Error loading image", Toast.LENGTH_LONG).show();
            }
        }
    }

    private void resetTransformationsAndFit() {
        if (originalBitmap == null || imageView.getWidth() == 0 || imageView.getHeight() == 0) {
            matrix.reset();
            scaleFactor = 1.0f;
            rotationAngle = 0.0f;
            imageView.setImageMatrix(matrix);
            return;
        }

        matrix.reset();

        float viewWidth = imageView.getWidth();
        float viewHeight = imageView.getHeight();
        float bmpWidth = originalBitmap.getWidth();
        float bmpHeight = originalBitmap.getHeight();

        float scaleX = viewWidth / bmpWidth;
        float scaleY = viewHeight / bmpHeight;
        float initialScale = Math.min(scaleX, scaleY);

        float scaledBmpWidth = bmpWidth * initialScale;
        float scaledBmpHeight = bmpHeight * initialScale;
        float initialTranslateX = (viewWidth - scaledBmpWidth) / 2f;
        float initialTranslateY = (viewHeight - scaledBmpHeight) / 2f;

        matrix.postScale(initialScale, initialScale);
        matrix.postTranslate(initialTranslateX, initialTranslateY);

        imageView.post(() -> {
            imageView.setImageMatrix(matrix);
            imageView.invalidate();
            scaleFactor = initialScale;
            rotationAngle = 0.0f;
        });
    }

    private void applyTransformations() {
        imageView.setImageMatrix(matrix);
        imageView.invalidate();
        Log.d(TAG, "Transformations applied: scale=" + scaleFactor);
    }

    private void setImageAlpha(int progress) {
        float alpha = progress / 100.0f;
        imageView.setAlpha(alpha);
        imageView.invalidate();
        Log.d(TAG, "Image alpha set to: " + alpha);
    }

    private void processPencilEffect() {
        Log.d(TAG, "Processing pencil effect");
        if (originalBitmap == null) {
            Log.d(TAG, "Original bitmap is null, cannot process pencil effect");
            return;
        }

        if (pencilBitmap != null && !pencilBitmap.isRecycled()) {
            pencilBitmap.recycle();
            pencilBitmap = null;
        }
        if (layerBitmaps != null) {
            for (Bitmap layer : layerBitmaps) {
                if (layer != null && !layer.isRecycled()) {
                    layer.recycle();
                }
            }
            layerBitmaps = null;
        }

        try {
            pencilBitmap = Bitmap.createBitmap(originalBitmap.getWidth(), originalBitmap.getHeight(), Bitmap.Config.ARGB_8888);
            if (pencilBitmap == null) {
                Log.e(TAG, "Failed to create pencilBitmap");
                return;
            }
            Canvas canvas = new Canvas(pencilBitmap);
            Paint paint = new Paint();
            ColorMatrix colorMatrix = new ColorMatrix();
            colorMatrix.setSaturation(0);
            ColorMatrixColorFilter filter = new ColorMatrixColorFilter(colorMatrix);
            paint.setColorFilter(filter);
            canvas.drawBitmap(originalBitmap, 0, 0, paint);

            layerBitmaps = new Bitmap[20];
            for (int i = 0; i < 20; i++) {
                layerBitmaps[i] = Bitmap.createBitmap(originalBitmap.getWidth(), originalBitmap.getHeight(), Bitmap.Config.ARGB_8888);
                if (layerBitmaps[i] == null) {
                    Log.e(TAG, "Failed to create layerBitmap[" + i + "]");
                    return;
                }
                layerBitmaps[i].eraseColor(Color.TRANSPARENT);
            }

            int[] pixels = new int[originalBitmap.getWidth() * originalBitmap.getHeight()];
            pencilBitmap.getPixels(pixels, 0, originalBitmap.getWidth(), 0, 0, originalBitmap.getWidth(), originalBitmap.getHeight());

            for (int i = 0; i < pixels.length; i++) {
                int gray = Color.red(pixels[i]);
                int layerIndex = getLayerIndex(gray);
                if (layerIndex >= 0 && layerIndex < 20 && layerBitmaps[layerIndex] != null) {
                    layerBitmaps[layerIndex].setPixel(i % originalBitmap.getWidth(), i / originalBitmap.getWidth(), pixels[i]);
                }
            }
            Log.d(TAG, "Pencil effect processed successfully");
        } catch (OutOfMemoryError e) {
            Log.e(TAG, "OutOfMemoryError in processPencilEffect", e);
            Toast.makeText(this, "Not enough memory for pencil effect", Toast.LENGTH_LONG).show();
            pencilBitmap = null;
            layerBitmaps = null;
        }
    }

    private int getLayerIndex(int grayValue) {
        return grayValue / (256 / 20);
    }

    private void updateImageDisplay() {
        Log.d(TAG, "updateImageDisplay: isPencilMode=" + isPencilMode + ", isImageVisible=" + isImageVisible);
        if (originalBitmap == null || !isImageVisible) {
            Log.d(TAG, "updateImageDisplay: originalBitmap is null or image is not visible");
            imageView.setImageBitmap(null);
            imageView.setVisibility(View.INVISIBLE);
            imageView.invalidate();
            return;
        }

        if (isPencilMode) {
            Log.d(TAG, "updateImageDisplay: Processing pencil mode");
            if (pencilBitmap == null || layerBitmaps == null) {
                processPencilEffect();
            }

            if (pencilBitmap == null || layerBitmaps == null) {
                Log.d(TAG, "updateImageDisplay: pencilBitmap or layerBitmaps is null");
                imageView.setImageBitmap(null);
                imageView.setVisibility(View.INVISIBLE);
                imageView.invalidate();
                return;
            }

            Bitmap resultBitmap = Bitmap.createBitmap(originalBitmap.getWidth(), originalBitmap.getHeight(), Bitmap.Config.ARGB_8888);
            if (resultBitmap == null) {
                Log.d(TAG, "updateImageDisplay: Failed to create resultBitmap");
                imageView.setImageBitmap(null);
                imageView.setVisibility(View.INVISIBLE);
                imageView.invalidate();
                return;
            }
            Canvas canvas = new Canvas(resultBitmap);
            canvas.drawColor(Color.TRANSPARENT);

            for (int i = 0; i < layerBitmaps.length; i++) {
                if (layerVisibility[i] && layerBitmaps[i] != null && !layerBitmaps[i].isRecycled()) {
                    canvas.drawBitmap(layerBitmaps[i], 0, 0, null);
                }
            }

            imageView.setImageBitmap(resultBitmap);
            setImageAlpha(transparencySeekBar.getProgress());
            imageView.setVisibility(View.VISIBLE);
            imageView.post(() -> {
                imageView.setImageMatrix(matrix);
                imageView.invalidate();
            });
            Log.d(TAG, "updateImageDisplay: Pencil mode applied");
        } else {
            Log.d(TAG, "updateImageDisplay: Displaying original bitmap");
            imageView.setImageBitmap(originalBitmap);
            setImageAlpha(transparencySeekBar.getProgress());
            imageView.setVisibility(View.VISIBLE);
            imageView.post(() -> {
                imageView.setImageMatrix(matrix);
                imageView.invalidate();
            });
            Log.d(TAG, "updateImageDisplay: Original bitmap displayed");
        }
    }

    private void showLayerSelectionDialog() {
        Dialog dialog = new Dialog(this);
        dialog.setContentView(R.layout.dialog_layer_selection);
        dialog.setTitle(R.string.layer_selection_title);

        RecyclerView recyclerView = dialog.findViewById(R.id.layerRecyclerView);
        recyclerView.setLayoutManager(new LinearLayoutManager(this));
        LayerAdapter adapter = new LayerAdapter(PENCIL_HARDNESS, layerVisibility, this);
        recyclerView.setAdapter(adapter);

        dialog.show();
    }

    @Override
    public void onLayerVisibilityChanged(int position, boolean isVisible) {
        layerVisibility[position] = isVisible;
        updateImageDisplay();
    }

    private void saveParameters() {
        try {
            File file = new File(getFilesDir(), "parameters.dat");
            FileOutputStream fos = new FileOutputStream(file);
            fos.write(Float.toString(scaleFactor).getBytes());
            fos.write("\n".getBytes());
            fos.write(Float.toString(rotationAngle).getBytes());
            fos.write("\n".getBytes());
            float[] matrixValues = new float[9];
            matrix.getValues(matrixValues);
            for (float value : matrixValues) {
                fos.write(Float.toString(value).getBytes());
                fos.write(" ".getBytes());
            }
            fos.write("\n".getBytes());
            fos.write(String.valueOf(isPencilMode).getBytes());
            fos.write("\n".getBytes());
            for (boolean visible : layerVisibility) {
                fos.write(String.valueOf(visible).getBytes());
                fos.write(" ".getBytes());
            }
            fos.close();
            Toast.makeText(this, "Parameters saved", Toast.LENGTH_SHORT).show();
        } catch (IOException e) {
            Log.e(TAG, "Error saving parameters", e);
            Toast.makeText(this, "Error saving parameters", Toast.LENGTH_LONG).show();
        }
    }

    private void loadParameters() {
        try {
            File file = new File(getFilesDir(), "parameters.dat");
            if (!file.exists()) {
                Toast.makeText(this, "No saved parameters found", Toast.LENGTH_SHORT).show();
                return;
            }
            FileInputStream fis = new FileInputStream(file);
            byte[] buffer = new byte[(int) file.length()];
            fis.read(buffer);
            fis.close();
            String[] lines = new String(buffer).split("\n");
            if (lines.length < 4) {
                Toast.makeText(this, "Invalid parameters file", Toast.LENGTH_LONG).show();
                return;
            }
            scaleFactor = Float.parseFloat(lines[0]);
            rotationAngle = Float.parseFloat(lines[1]);
            String[] matrixValues = lines[2].split(" ");
            float[] values = new float[9];
            for (int i = 0; i < 9; i++) {
                values[i] = Float.parseFloat(matrixValues[i]);
            }
            matrix.setValues(values);
            isPencilMode = Boolean.parseBoolean(lines[3]);
            pencilModeSwitch.setChecked(isPencilMode);
            String[] visibilityValues = lines[4].split(" ");
            for (int i = 0; i < layerVisibility.length; i++) {
                layerVisibility[i] = Boolean.parseBoolean(visibilityValues[i]);
            }
            applyTransformations();
            updateImageDisplay();
            Toast.makeText(this, "Parameters loaded", Toast.LENGTH_SHORT).show();
        } catch (IOException | NumberFormatException e) {
            Log.e(TAG, "Error loading parameters", e);
            Toast.makeText(this, "Error loading parameters", Toast.LENGTH_LONG).show();
        }
    }

    @Override
    protected void onResume() {
        super.onResume();
        if (isSurfaceAvailable && !isCameraOpen) {
            openCamera();
        } else {
            isCameraPendingOpen = true;
        }
    }

    @Override
    protected void onPause() {
        closeCamera();
        super.onPause();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        if (originalBitmap != null && !originalBitmap.isRecycled()) {
            originalBitmap.recycle();
            originalBitmap = null;
        }
        if (pencilBitmap != null && !pencilBitmap.isRecycled()) {
            pencilBitmap.recycle();
            pencilBitmap = null;
        }
        if (layerBitmaps != null) {
            for (Bitmap layer : layerBitmaps) {
                if (layer != null && !layer.isRecycled()) {
                    layer.recycle();
                }
            }
            layerBitmaps = null;
        }
    }

    @Override
    public void onConfigurationChanged(@NonNull Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        resetTransformationsAndFit();
        updateImageDisplay();
    }
}

# app/src/main/res/drawable/ic_open_arrow.png
PNG

   IHDR         \rf   sRGB    gAMA  a   	pHYs    od  xIDATx^+I˕HJ$D"H$D"HJ$9=UsGnVfWDt<z'>J&Z7D$O_=oI3~I_%7/?% Xg[?
t,?ϒ"7Hn J|;
OT2K]]_ ĕ-X-J9 ѯ/QI:G7nq+sTQ*H7$7%/~K$
[-,9t+ῢݗ!_)yGC AşY ]yT$o8
3}.Z4?S5F]hY%&x{sc{IR oI(E7MiP*%Q 0;w`|[,ޤ2CUxCsH@.K[1q=xSF6PRz(18qTvޥ$tBF\*c`BpE,QD*kmxQ}2
C/,p@AF(T~t+_5{51\1T~tR6k:ʏp@GPhZ I5#4
sҵnOal?J<w	D¬>4t-y!K5Ļ T>/-΋ V/1Ȋ6,/zDt3'hEY:forqWʌd|
j+x||W?.}ĎDg 	ZK|=Uz/.QpCȳw'I?}wui6|ggk?'&d%BxȜg8㛽ҟoQYxac	o{v7i^;9D!XP׹XE=Uch|kp%f߷Os?`!O6qz?[n7Nd%?* {9{KξQe݄$/=.03#çJ㥞|O!H5Gn[Ugs6gW;Gawx-q7pC2gedXiq xS4N/+qzVַ$d.ǽ#_"oy;yr]}zgr6$`+J1LBr^4XEsFI-\ Fz"3^}^_ȬA0Qk7&wNYqwf$'Jܹx ٯspITm(Enj/*=ʿ-4$t7q\*h&H^y)p8OϣF`N0j?=]}T|pggA3-DtF\&yoOİ;'zpvCf_7#@<+=[oA[گ1Ńs	1.;? S~tȘq2mCɟ>8Org	ɛ3=䅡dXPɟ̰I F
)jЃ~}c]z}J>9GZ.y-vɾa@'cq.@ R"3[^K{}̎G'u=xvęWf/]o*zojua۱#ɓn'}}ual嘀{~w]B>[:@mmwJ~xW[=
?p+Itx﫿pC+K~t5.`fYd8fԲU$?|0W1DD%?!;h7?\ɏ.{o2p{ʒ])F`\ɏW:K}p~AS;ca,$/"|rv*v&tӻ Lqe*yd|;G`4VʒMNwx`@I>4FnO8`2+CEmj_ y~"T[開- ɇfqO2T|hjn~A򢉻]s|h"O6`SQI>41`'}\OC95ZhҳWRYDcܰN$R>ˍ`Sm,SQ!7	@a0IH׋v1`y{7	vN v9l%Ö `InW*yr nWSHGCA)N ,M݃Az Ҕ_$D\"I63$Rvk#4O&k9$RmeI ZL6'sSQxUJ9OւD`ݶ|0, kRzX#}{r X3uf2MT1HkoC' [; ڔ1HXzA ][->-(8?E?lEIA:9)U*h ST1翷a[<`b	~(bT?Eja(E | fV&Wh  X ⯨bTΟ4OQE: (@[QzF?V UJl IT)*i&QD jUJl IT)*i&QD jUJl IT)*i&QD jUJl IT)*i&QD jUJl IT)*i&QD jUJl IT)*i&Qx&=JQȓy]?/ΗAJevx{хps%]A>sAt*-q?|@Rht&'q?L|@'RYEh\*C~KeGWC>Q܈a4&q?
F"!ЀTFKCB> T6
IeBA> T:H@@>`caSl$yOC>`s~H%!V&XXB>`A[~H$_	,yJMA>`&K~h3HCR|w&JC7 yEA>`q?t	3G5NHC$O$?~(I|< ܉<e:o~ Q.s&C|Ε #q?	|΍`tN #*s!H7 q?49\A ;q?41Ds /q?4б,@|`!Rtl 6"Xt q?XV&E>@@ Y>@ML~$g$c|> ! Y,&H" 'q?@#̞4l q?@\{4U q.u 09t|Kzq?@q~9c p Ÿ'q?@AJ??lb    IENDB`
# app/src/main/res/layout/activity_main.xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <SurfaceView
        android:id="@+id/cameraSurfaceView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_centerInParent="true" />

    <ImageView
        android:id="@+id/imageView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_centerInParent="true" />

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_alignParentBottom="true"
        android:orientation="vertical"
        android:padding="10dp">

        <SeekBar
            android:id="@+id/transparencySeekBar"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:max="100"
            android:progress="100" />

        <Button
            android:id="@+id/pickImageButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/pick_image" />

        <Switch
            android:id="@+id/pencilModeSwitch"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/pencil_mode" />

        <Button
            android:id="@+id/layerSelectButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/select_layers"
            android:visibility="gone" />

        <CheckBox
            android:id="@+id/controlsVisibilityCheckbox"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/show_controls"
            android:checked="true" />

        <CheckBox
            android:id="@+id/hideImageCheckbox"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/hide_image" />

        <Button
            android:id="@+id/saveParametersButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/save_parameters" />

        <Button
            android:id="@+id/loadParametersButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/load_parameters" />

        <Button
            android:id="@+id/switchCameraButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/switch_camera" />
    </LinearLayout>

</RelativeLayout>

# app/src/main/res/layout/dialog_layer_selection.xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="wrap_content">
<!-- Это тестовое изменение -->
    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/recyclerView"
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />

</androidx.constraintlayout.widget.ConstraintLayout>

# app/src/main/res/layout/item_layer.xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:padding="8dp">

    <TextView
        android:id="@+id/layerText"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:textSize="16sp" />

    <CheckBox
        android:id="@+id/layerCheckBox"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" />
</LinearLayout>

# app/src/main/res/mipmap-hdpi/ic_launcher.png
PNG

   IHDR   H   H   o#!   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  {ܙ,   bKGD-   tIME(`   IDAT(c``   _   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`
# app/src/main/res/mipmap-hdpi/ic_launcher_round.png
PNG

   IHDR   H   H   o#!   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  ?/O   bKGD-   tIME(`   IDAT(c``   _   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`
# app/src/main/res/mipmap-mdpi/ic_launcher.png
PNG

   IHDR   0   0   mk   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  {ܙ,   bKGD-   tIME'N|   IDATc` P    %tEXtdate:create 2025-04-27T16:18:39+00:00s   %tEXtdate:modify 2025-04-27T16:18:39+00:00Aq    IENDB`
# app/src/main/res/mipmap-mdpi/ic_launcher_round.png
PNG

   IHDR   0   0   mk   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  ?/O   bKGD-   tIME(`   IDATc` P    %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`
# app/src/main/res/mipmap-xhdpi/ic_launcher.png
PNG

   IHDR   `   `   V{   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  {ܙ,   bKGD-   tIME(`   IDAT8c``	  t   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`
# app/src/main/res/mipmap-xhdpi/ic_launcher_round.png
PNG

   IHDR   `   `   V{   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  ?/O   bKGD-   tIME(`   IDAT8c``	  t   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`
# app/src/main/res/mipmap-xxhdpi/ic_launcher.png
PNG

   IHDR         ݈p   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  {ܙ,   bKGD-   tIME(`   IDATH1    Om   
 >4   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`
# app/src/main/res/mipmap-xxhdpi/ic_launcher_round.png
PNG

   IHDR         ݈p   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  ?/O   bKGD-   tIME(`   IDATH1    Om   
 >4   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`
# app/src/main/res/mipmap-xxxhdpi/ic_launcher.png
PNG

   IHDR         hD   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  {ܙ,   bKGD-   tIME(`   IDATX1    Om      R   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`
# app/src/main/res/mipmap-xxxhdpi/ic_launcher_round.png
PNG

   IHDR         hD   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  ?/O   bKGD-   tIME)g{   IDATX1    Om      R   %tEXtdate:create 2025-04-27T16:18:41+00:00J6P   %tEXtdate:modify 2025-04-27T16:18:41+00:00;k    IENDB`
# app/src/main/res/values/strings.xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">HelloWorld</string>
    <string name="pick_image">Pick Image</string>
    <string name="show_controls">Show Controls</string>
    <string name="pencil_mode">Pencil Mode</string>
    <string name="select_layers">Select Layers</string>
    <string name="hide_image">Hide Image</string>
    <string name="save_parameters">Save Parameters</string>
    <string name="load_parameters">Load Parameters</string>
    <string name="switch_camera">Switch Camera</string>
    <string name="layer_selection_title">Select Pencil Layers</string>
</resources>

# app/src/main/res/values/themes.xml
<?xml version="1.0" encoding="utf-8"?>
<resources xmlns:tools="http://schemas.android.com/tools">
    <style name="Theme.HelloWorld" parent="Theme.AppCompat.Light.DarkActionBar">
        <item name="colorPrimary">@android:color/black</item>
        <item name="colorPrimaryDark">@android:color/black</item>
        <item name="colorAccent">@android:color/holo_blue_light</item>
    </style>
</resources>

# app/src/main/res/xml/backup_rules.xml
<?xml version="1.0" encoding="utf-8"?>
<full-backup-content>
    <include domain="file" path="." />
</full-backup-content>

# app/src/main/res/xml/data_extraction_rules.xml
<?xml version="1.0" encoding="utf-8"?>
<data-extraction-rules>
    <cloud-backup>
        <include domain="file" />
    </cloud-backup>
</data-extraction-rules>

# app/src/main/AndroidManifest.xml:
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">

    <!-- Разрешения -->
    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.READ_MEDIA_IMAGES" />

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.HelloWorld">
        <activity
            android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>

# app/build.gradle
plugins {
    id 'com.android.application'
    id 'org.jetbrains.kotlin.android'
}

android {
    namespace 'com.example.helloworld' // Added namespace
    compileSdk 34

    defaultConfig {
        applicationId "com.example.helloworld"
        minSdk 24
        targetSdk 34
        versionCode 1
        versionName "1.0"
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_17
        targetCompatibility JavaVersion.VERSION_17
    }
    kotlinOptions {
        jvmTarget = '17'
    }
}

dependencies {
    implementation 'androidx.core:core-ktx:1.12.0'
    implementation 'androidx.appcompat:appcompat:1.6.1'
    implementation 'com.google.android.material:material:1.10.0'
    implementation 'androidx.constraintlayout:constraintlayout:2.1.4'
}

# app/src/main/AndroidManifest.xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.helloworld">

    <uses-permission android:name="android.permission.CAMERA"/>
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
    <uses-permission android:name="android.permission.READ_MEDIA_IMAGES"/>

    <uses-feature android:name="android.hardware.camera" android:required="true"/>

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.HelloWorld">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:configChanges="orientation|screenSize">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>

# app/src/main/java/com/example/helloworld/LayerAdapter.java
package com.example.helloworld;

import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.CheckBox; // Используем CheckBox
import android.widget.TextView;  // Используем TextView
import androidx.annotation.NonNull;
import androidx.recyclerview.widget.RecyclerView;

public class LayerAdapter extends RecyclerView.Adapter<LayerAdapter.ViewHolder> {

    private final String[] layers;
    private final boolean[] visibility;
    private final OnLayerVisibilityChangedListener listener;

    // Интерфейс для обратного вызова при изменении видимости слоя
    public interface OnLayerVisibilityChangedListener {
        void onLayerVisibilityChanged(int position, boolean isVisible);
    }

    // Конструктор адаптера
    public LayerAdapter(String[] layers, boolean[] visibility, OnLayerVisibilityChangedListener listener) {
        this.layers = layers;
        this.visibility = visibility;
        this.listener = listener;
    }

    // Создание нового ViewHolder (используем item_layer.xml)
    @NonNull
    @Override
    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        // Используем ваш кастомный макет item_layer.xml
        View view = LayoutInflater.from(parent.getContext())
                .inflate(R.layout.item_layer, parent, false); // *** ИЗМЕНЕНО ЗДЕСЬ ***
        return new ViewHolder(view);
    }

    // Привязка данных к ViewHolder
    @Override
    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
        // Устанавливаем текст слоя в TextView
        holder.layerText.setText(layers[position]); // *** ИЗМЕНЕНО ЗДЕСЬ ***

        // Сначала удаляем слушатель, чтобы он не сработал при установке состояния
        holder.layerCheckBox.setOnCheckedChangeListener(null);
        // Устанавливаем состояние CheckBox
        holder.layerCheckBox.setChecked(visibility[position]); // *** ИЗМЕНЕНО ЗДЕСЬ ***

        // Устанавливаем слушатель изменения состояния CheckBox
        holder.layerCheckBox.setOnCheckedChangeListener((buttonView, isChecked) -> { // *** ИЗМЕНЕНО ЗДЕСЬ ***
            // Обновляем массив видимости
            int currentPosition = holder.getAdapterPosition(); // Получаем актуальную позицию
             if (currentPosition != RecyclerView.NO_POSITION) { // Проверяем, что позиция валидна
                 visibility[currentPosition] = isChecked;
                 // Уведомляем MainActivity через интерфейс
                 if (listener != null) {
                     listener.onLayerVisibilityChanged(currentPosition, isChecked);
                 }
             }
        });
    }

    // Возвращаем общее количество элементов
    @Override
    public int getItemCount() {
        // Проверяем на null на всякий случай
        return (layers != null) ? layers.length : 0;
    }

    // Класс ViewHolder, хранящий ссылки на View одного элемента списка
    static class ViewHolder extends RecyclerView.ViewHolder {
        TextView layerText;     // *** ИЗМЕНЕНО ЗДЕСЬ *** Ссылка на TextView из item_layer.xml
        CheckBox layerCheckBox; // *** ИЗМЕНЕНО ЗДЕСЬ *** Ссылка на CheckBox из item_layer.xml

        ViewHolder(View itemView) {
            super(itemView);
            // Находим View по их ID из item_layer.xml
            layerText = itemView.findViewById(R.id.layerText);       // *** ИЗМЕНЕНО ЗДЕСЬ ***
            layerCheckBox = itemView.findViewById(R.id.layerCheckBox); // *** ИЗМЕНЕНО ЗДЕСЬ ***
        }
    }
}

# app/src/main/java/com/example/helloworld/MainActivity.java
package com.example.helloworld;

import android.Manifest;
import android.app.Activity;
import android.app.Dialog;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.res.Configuration;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.ColorMatrix;
import android.graphics.ColorMatrixColorFilter;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.graphics.PointF;
// import android.graphics.SurfaceTexture; // Не используется напрямую
import android.hardware.camera2.CameraAccessException;
import android.hardware.camera2.CameraCaptureSession;
import android.hardware.camera2.CameraCharacteristics;
import android.hardware.camera2.CameraDevice;
import android.hardware.camera2.CameraManager;
import android.hardware.camera2.CaptureRequest;
import android.hardware.camera2.params.StreamConfigurationMap;
import android.hardware.display.DisplayManager;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.os.HandlerThread;
import android.provider.MediaStore;
import android.util.Log;
import android.util.Size;
import android.view.Display;
import android.view.MotionEvent;
import android.view.ScaleGestureDetector;
import android.view.Surface;
import android.view.SurfaceHolder;
import android.view.SurfaceView;
import android.view.View;
// import android.view.ViewGroup;
import android.view.WindowInsets;
import android.view.WindowInsetsController;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.ImageView;
import android.widget.SeekBar;
import android.widget.Switch;
import android.widget.Toast;

import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.contract.ActivityResultContracts;
import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import org.json.JSONArray;
import org.json.JSONObject;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

public class MainActivity extends AppCompatActivity implements SurfaceHolder.Callback, LayerAdapter.OnLayerVisibilityChangedListener {

    private static final String TAG = "MainActivity";
    private static final int CAMERA_PERMISSION_CODE = 100;
    private static final int STORAGE_PERMISSION_CODE = 101;
    private static final int WRITE_STORAGE_PERMISSION_CODE = 102;

    // Ключи для сохранения состояния
    private static final String KEY_IMAGE_URI = "imageUri";
    private static final String KEY_MATRIX_VALUES = "matrixValues";
    private static final String KEY_CONTROLS_VISIBLE = "controlsVisible";
    private static final String KEY_IMAGE_VISIBLE = "imageVisible";
    private static final String KEY_PENCIL_MODE = "isPencilMode";
    private static final String KEY_LAYER_VISIBILITY = "layerVisibility";
    private static final String KEY_CURRENT_CAMERA_ID = "currentCameraId";


    // UI элементы
    private ImageView imageView;
    private SeekBar transparencySeekBar;
    private Button pickImageButton;
    private SurfaceView cameraSurfaceView;
    private SurfaceHolder cameraSurfaceHolder;
    private CheckBox controlsVisibilityCheckbox;
    private Switch pencilModeSwitch;
    private Button layerSelectButton;
    private CheckBox hideImageCheckbox;
    private Button saveParametersButton;
    private Button loadParametersButton;
    private Button switchCameraButton;

    // Camera2 API
    private CameraManager cameraManager;
    private CameraDevice cameraDevice;
    private CameraCaptureSession cameraCaptureSession;
    private CaptureRequest.Builder previewRequestBuilder;
    private String[] cameraIds;
    private String currentCameraId;
    private List<String> rearCameraIds = new ArrayList<>();
    private int currentRearCameraIndex = 0;
    private final ExecutorService cameraExecutor = Executors.newSingleThreadExecutor();
    private HandlerThread backgroundThread;
    private Handler backgroundHandler;
    private final Semaphore cameraOpenCloseLock = new Semaphore(1, true);
    private volatile boolean isSurfaceAvailable = false;
    private volatile boolean isCameraOpen = false;
    private Size previewSize;

    // Манипуляции с изображением
    private Bitmap originalBitmap = null;
    private Matrix matrix = new Matrix();
    private float scaleFactor = 1.0f; // Глобальный масштаб для ScaleListener
    private Uri currentImageUri;

    // Карандашный режим
    private boolean isPencilMode = false;
    private Bitmap pencilBitmap;
    private Bitmap[] layerBitmaps;
    private boolean[] layerVisibility = new boolean[20];
    private static final String[] PENCIL_HARDNESS = {
            "9H", "8H", "7H", "6H", "5H", "4H", "3H", "2H", "H", "F",
            "HB", "B", "2B", "3B", "4B", "5B", "6B", "7B", "8B", "9B"
    };

    // Управление видимостью изображения
    private boolean isImageVisible = true;

    // Распознавание жестов
    private ScaleGestureDetector scaleGestureDetector;
    private static final int NONE = 0;
    private static final int DRAG = 1;
    private static final int ZOOM = 2;
    private int touchMode = NONE;
    private final PointF lastTouchPoint = new PointF();
    private final PointF midPoint = new PointF();
    private float initialAngle = 0f;
    private final Matrix savedMatrix = new Matrix();


    // Activity Result API
    private ActivityResultLauncher<Intent> imagePickerLauncher;
    private ActivityResultLauncher<Intent> saveFileLauncher;
    private ActivityResultLauncher<Intent> loadFileLauncher;

    private final ExecutorService imageLoadExecutor = Executors.newSingleThreadExecutor();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        hideSystemUI();

        initializeUI();
        setupListeners();

        scaleGestureDetector = new ScaleGestureDetector(this, new ScaleListener());
        imageView.setOnTouchListener(new TouchAndGestureListener());

        cameraSurfaceHolder = cameraSurfaceView.getHolder();
        cameraSurfaceHolder.addCallback(this);

        cameraManager = (CameraManager) getSystemService(Context.CAMERA_SERVICE);
        if (cameraManager == null) {
            Log.e(TAG, "CameraManager is null! Cannot proceed.");
            Toast.makeText(this, "Camera service not available.", Toast.LENGTH_LONG).show();
            finish();
            return;
        }
        setupCameraSelector();

        checkAndRequestPermissions();

        if (savedInstanceState != null) {
            restoreInstanceState(savedInstanceState);
        } else {
            Arrays.fill(layerVisibility, true);
            updateControlsVisibility(controlsVisibilityCheckbox.isChecked());
            updateImageDisplay();
        }
    }

    // --- Инициализация UI и Слушателей ---
    private void initializeUI() {
        imageView = findViewById(R.id.imageView);
        transparencySeekBar = findViewById(R.id.transparencySeekBar);
        pickImageButton = findViewById(R.id.pickImageButton);
        cameraSurfaceView = findViewById(R.id.cameraSurfaceView);
        controlsVisibilityCheckbox = findViewById(R.id.controlsVisibilityCheckbox);
        pencilModeSwitch = findViewById(R.id.pencilModeSwitch);
        layerSelectButton = findViewById(R.id.layerSelectButton);
        hideImageCheckbox = findViewById(R.id.hideImageCheckbox);
        saveParametersButton = findViewById(R.id.saveParametersButton);
        loadParametersButton = findViewById(R.id.loadParametersButton);
        switchCameraButton = findViewById(R.id.switchCameraButton);
        imageView.setScaleType(ImageView.ScaleType.MATRIX);
    }

    private void setupListeners() {
        imagePickerLauncher = registerForActivityResult(
                new ActivityResultContracts.StartActivityForResult(),
                result -> {
                    if (result.getResultCode() == Activity.RESULT_OK && result.getData() != null) {
                        Uri selectedImageUri = result.getData().getData();
                        if (selectedImageUri != null) {
                            currentImageUri = selectedImageUri;
                            Log.d(TAG, "Image selected: " + currentImageUri);
                            loadImage(currentImageUri);
                        }
                    } else {
                        Log.w(TAG, "Image selection cancelled or failed. ResultCode: " + result.getResultCode());
                    }
                }
        );

        saveFileLauncher = registerForActivityResult(
                new ActivityResultContracts.StartActivityForResult(),
                result -> {
                    if (result.getResultCode() == Activity.RESULT_OK && result.getData() != null) {
                        Uri uri = result.getData().getData();
                        if (uri != null) {
                            saveParametersToFile(uri);
                        }
                    }
                }
        );

        loadFileLauncher = registerForActivityResult(
                new ActivityResultContracts.StartActivityForResult(),
                result -> {
                    if (result.getResultCode() == Activity.RESULT_OK && result.getData() != null) {
                        Uri uri = result.getData().getData();
                        if (uri != null) {
                            loadParametersFromFile(uri);
                        }
                    }
                }
        );

        pickImageButton.setOnClickListener(v -> checkPermissionAndPickImage());
        transparencySeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
            @Override
            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
                setImageAlpha(progress);
            }
            @Override public void onStartTrackingTouch(SeekBar seekBar) {}
            @Override public void onStopTrackingTouch(SeekBar seekBar) {}
        });
        controlsVisibilityCheckbox.setOnCheckedChangeListener((buttonView, isChecked) -> updateControlsVisibility(isChecked));
        pencilModeSwitch.setOnCheckedChangeListener((buttonView, isChecked) -> {
            isPencilMode = isChecked;
            layerSelectButton.setVisibility(isChecked ? View.VISIBLE : View.GONE);
            if (isPencilMode && originalBitmap != null && !originalBitmap.isRecycled()) {
                imageLoadExecutor.submit(this::processPencilEffect);
            } else {
                recyclePencilBitmaps();
                updateImageDisplay();
            }
        });
        layerSelectButton.setOnClickListener(v -> showLayerSelectionDialog());
        hideImageCheckbox.setOnCheckedChangeListener((buttonView, isChecked) -> {
            isImageVisible = !isChecked;
            updateImageDisplay();
        });
        saveParametersButton.setOnClickListener(v -> checkPermissionAndSaveParameters());
        loadParametersButton.setOnClickListener(v -> checkPermissionAndLoadParameters());
        switchCameraButton.setOnClickListener(v -> switchCamera());
    }

    // --- Управление UI ---
    private void hideSystemUI() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            getWindow().setDecorFitsSystemWindows(false);
            WindowInsetsController controller = getWindow().getInsetsController();
            if (controller != null) {
                controller.hide(WindowInsets.Type.statusBars() | WindowInsets.Type.navigationBars());
                controller.setSystemBarsBehavior(WindowInsetsController.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE);
            } else {
                // Fallback
                //noinspection deprecation
                getWindow().getDecorView().setSystemUiVisibility(
                        View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY
                                | View.SYSTEM_UI_FLAG_LAYOUT_STABLE
                                | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
                                | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
                                | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
                                | View.SYSTEM_UI_FLAG_FULLSCREEN);
            }
        } else {
            //noinspection deprecation
            getWindow().getDecorView().setSystemUiVisibility(
                    View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY
                            | View.SYSTEM_UI_FLAG_LAYOUT_STABLE
                            | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
                            | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
                            | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
                            | View.SYSTEM_UI_FLAG_FULLSCREEN);
        }
        if (getSupportActionBar() != null) {
            getSupportActionBar().hide();
        }
    }

    private void updateControlsVisibility(boolean show) {
        int visibility = show ? View.VISIBLE : View.GONE;
        pickImageButton.setVisibility(visibility);
        transparencySeekBar.setVisibility(visibility);
        pencilModeSwitch.setVisibility(visibility);
        layerSelectButton.setVisibility(show && isPencilMode ? View.VISIBLE : View.GONE);
        saveParametersButton.setVisibility(visibility);
        loadParametersButton.setVisibility(visibility);
        hideImageCheckbox.setVisibility(visibility);
        switchCameraButton.setVisibility(show && rearCameraIds != null && rearCameraIds.size() > 1 ? View.VISIBLE : View.GONE);
        controlsVisibilityCheckbox.setVisibility(View.VISIBLE);
        Log.d(TAG, "Controls visibility updated: " + (show ? "VISIBLE" : "GONE"));
    }

    // --- Управление Разрешениями ---
    private void checkAndRequestPermissions() {
        List<String> permissionsNeeded = new ArrayList<>();
        if (ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {
            permissionsNeeded.add(Manifest.permission.CAMERA);
        }
        String storagePermission = null;
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            storagePermission = Manifest.permission.READ_MEDIA_IMAGES;
        } else {
            storagePermission = Manifest.permission.READ_EXTERNAL_STORAGE;
        }
        if (storagePermission != null && ContextCompat.checkSelfPermission(this, storagePermission) != PackageManager.PERMISSION_GRANTED) {
            permissionsNeeded.add(storagePermission);
        }

        if (!permissionsNeeded.isEmpty()) {
            Log.d(TAG, "Requesting permissions: " + permissionsNeeded);
            ActivityCompat.requestPermissions(this, permissionsNeeded.toArray(new String[0]), CAMERA_PERMISSION_CODE);
        } else {
            Log.d(TAG, "All necessary permissions already granted.");
            if (cameraIds == null) setupCameraSelector();
            if (!isCameraOpen && cameraSurfaceHolder != null && cameraSurfaceHolder.getSurface() != null && cameraSurfaceHolder.getSurface().isValid()) {
                openCamera();
            }
        }
    }
    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
        boolean cameraGranted = ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED;
        boolean storageGranted = false;
        String storagePermission = Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU ? Manifest.permission.READ_MEDIA_IMAGES : Manifest.permission.READ_EXTERNAL_STORAGE;
        if (ContextCompat.checkSelfPermission(this, storagePermission) == PackageManager.PERMISSION_GRANTED) {
            storageGranted = true;
        }

        if (requestCode == CAMERA_PERMISSION_CODE) {
            if (cameraGranted) {
                Log.d(TAG, "Camera permission granted via request result.");
                if (cameraIds == null) setupCameraSelector();
                openCamera();
            } else {
                Toast.makeText(this, "Camera Permission is Required", Toast.LENGTH_SHORT).show();
            }
            if (!storageGranted) {
                Log.d(TAG, "Storage permission still denied after request.");
            }
        }
    }

    // --- Логика Камеры (Camera2 API) ---
    private void setupCameraSelector() {
        if (cameraManager == null) return;
        try {
            cameraIds = cameraManager.getCameraIdList();
            rearCameraIds.clear();
            String firstBackCameraId = null;

            for (String id : cameraIds) {
                CameraCharacteristics characteristics = cameraManager.getCameraCharacteristics(id);
                Integer facing = characteristics.get(CameraCharacteristics.LENS_FACING);
                if (facing != null && facing == CameraCharacteristics.LENS_FACING_BACK) {
                    rearCameraIds.add(id);
                    if (firstBackCameraId == null) firstBackCameraId = id;
                    logCameraCharacteristics(id);
                }
            }

            if (!rearCameraIds.isEmpty()) {
                currentCameraId = firstBackCameraId;
                currentRearCameraIndex = rearCameraIds.indexOf(currentCameraId);
                Log.d(TAG, "Found " + rearCameraIds.size() + " rear cameras. Defaulting to: " + currentCameraId);
            } else if (cameraIds.length > 0) {
                currentCameraId = cameraIds[0];
                currentRearCameraIndex = -1;
                Log.w(TAG, "No rear cameras found, defaulting to first available camera: " + currentCameraId);
            } else {
                Log.e(TAG, "No cameras available.");
                Toast.makeText(this, "No cameras found on this device", Toast.LENGTH_LONG).show();
                currentCameraId = null;
            }

            // Обновляем видимость кнопки переключения
            runOnUiThread(() -> switchCameraButton.setVisibility(rearCameraIds != null && rearCameraIds.size() > 1 ? View.VISIBLE : View.GONE));

        } catch (CameraAccessException e) {
            Log.e(TAG, "Error accessing camera characteristics during setup", e);
            Toast.makeText(this, "Cannot access cameras: " + e.getMessage(), Toast.LENGTH_LONG).show();
        }
    }

    private void logCameraCharacteristics(String camId) {
        try {
            CameraCharacteristics characteristics = cameraManager.getCameraCharacteristics(camId);
            StreamConfigurationMap map = characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
            if (map != null) {
                Size[] outputSizes = map.getOutputSizes(SurfaceHolder.class);
                Log.d(TAG, "Camera " + camId + ": Preview Sizes (SurfaceHolder): " + Arrays.toString(outputSizes));
            } else {
                Log.w(TAG, "Camera " + camId + ": StreamConfigurationMap is null");
            }
            Integer facing = characteristics.get(CameraCharacteristics.LENS_FACING);
            float[] focalLengths = characteristics.get(CameraCharacteristics.LENS_INFO_AVAILABLE_FOCAL_LENGTHS);
            Log.d(TAG, "Camera " + camId + ": Facing: " + (facing == null ? "Unknown" : (facing == CameraCharacteristics.LENS_FACING_BACK ? "BACK" : "FRONT")));
            if (focalLengths != null && focalLengths.length > 0) {
                Log.d(TAG, "Camera " + camId + ": Focal Lengths: " + Arrays.toString(focalLengths));
            } else {
                Log.d(TAG, "Camera " + camId + ": Focal Lengths: Not available");
            }
        } catch (CameraAccessException e) {
            Log.e(TAG, "Error logging camera characteristics for camera " + camId, e);
        }
    }

    private void startBackgroundThread() {
        if (backgroundThread == null || !backgroundThread.isAlive()) {
            stopBackgroundThread();
            backgroundThread = new HandlerThread("CameraBackground");
            backgroundThread.start();
            backgroundHandler = new Handler(backgroundThread.getLooper());
            Log.d(TAG, "Background thread started");
        }
    }

    private void stopBackgroundThread() {
        if (backgroundThread != null) {
            backgroundThread.quitSafely();
            try {
                backgroundThread.join(500);
                if (backgroundThread.isAlive()) {
                    Log.w(TAG, "Background thread did not stop in time.");
                }
                backgroundThread = null;
                backgroundHandler = null;
                Log.d(TAG, "Background thread stopped");
            } catch (InterruptedException e) {
                Log.e(TAG, "Error stopping background thread", e);
                Thread.currentThread().interrupt();
            }
        }
    }

    private void openCamera() {
        if (ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) { Log.w(TAG, "openCamera called without permission."); checkAndRequestPermissions(); return; }
        if (currentCameraId == null) { Log.e(TAG, "Cannot open camera, no valid camera ID selected."); return; }
        if (cameraManager == null) { Log.e(TAG, "Cannot open camera, CameraManager is null."); return; }
        if (isCameraOpen) { Log.d(TAG, "Camera already open."); return; }

        startBackgroundThread();

        cameraExecutor.submit(() -> {
            try {
                if (!cameraOpenCloseLock.tryAcquire(2500, TimeUnit.MILLISECONDS)) { Log.e(TAG, "Time out waiting to lock camera opening."); return; }
                try {
                    if (ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) { Log.e(TAG, "Permission lost before opening camera."); cameraOpenCloseLock.release(); return; }
                    isCameraOpen = true;
                    cameraManager.openCamera(currentCameraId, cameraStateCallback, backgroundHandler);
                } catch (CameraAccessException | SecurityException | IllegalArgumentException e) {
                    Log.e(TAG, "Failed to open camera " + currentCameraId, e);
                    isCameraOpen = false;
                    cameraOpenCloseLock.release();
                    runOnUiThread(() -> Toast.makeText(this, "Failed to open camera", Toast.LENGTH_SHORT).show());
                }
            } catch (InterruptedException e) { Log.e(TAG, "Interrupted while waiting for camera lock", e); Thread.currentThread().interrupt(); }
        });
    }

    private final CameraDevice.StateCallback cameraStateCallback = new CameraDevice.StateCallback() {
        @Override
        public void onOpened(@NonNull CameraDevice camera) {
            Log.d(TAG, "Camera " + camera.getId() + " opened.");
            cameraDevice = camera;
            cameraOpenCloseLock.release();
            startCameraPreview();
        }

        @Override
        public void onDisconnected(@NonNull CameraDevice camera) {
            Log.w(TAG, "Camera " + camera.getId() + " disconnected.");
            cameraOpenCloseLock.release();
            camera.close();
            cameraDevice = null;
            isCameraOpen = false;
        }

        @Override
        public void onError(@NonNull CameraDevice camera, int error) {
            Log.e(TAG, "Camera " + camera.getId() + " error: " + error);
            cameraOpenCloseLock.release();
            camera.close();
            cameraDevice = null;
            isCameraOpen = false;
            runOnUiThread(() -> Toast.makeText(MainActivity.this, "Camera error: " + error, Toast.LENGTH_SHORT).show());
        }
    };

    private void closeCameraPreviewSession() {
        if (cameraCaptureSession != null) {
            try {
                cameraCaptureSession.close();
                Log.d(TAG, "Camera preview session closed.");
            } catch (IllegalStateException e) {
                Log.e(TAG, "IllegalStateException closing preview session (already closed?)", e);
            } catch (Exception e) {
                Log.e(TAG, "Exception closing preview session", e);
            } finally {
                cameraCaptureSession = null;
            }
        }
    }

    private void closeCamera() {
        Log.d(TAG, "Attempting to close camera...");
        try {
            if (!cameraOpenCloseLock.tryAcquire(1000, TimeUnit.MILLISECONDS)) { Log.w(TAG, "Timeout waiting for camera lock to close."); return; }
            try {
                closeCameraPreviewSession();
                if (cameraDevice != null) { cameraDevice.close(); cameraDevice = null; Log.d(TAG,"CameraDevice closed."); }
                isCameraOpen = false;
            } finally {
                cameraOpenCloseLock.release(); Log.d(TAG,"Camera close lock released.");
            }
        } catch (InterruptedException e) { Log.e(TAG, "Interrupted while waiting for camera lock to close.", e); Thread.currentThread().interrupt(); }
        finally { stopBackgroundThread(); }
    }

    private void switchCamera() {
        if (cameraManager == null || rearCameraIds == null || rearCameraIds.size() < 2) { Log.w(TAG, "Cannot switch camera: Not enough rear cameras available."); runOnUiThread(()->Toast.makeText(this, "Only one rear camera available", Toast.LENGTH_SHORT).show()); return; }
        Log.d(TAG, "Switching camera...");
        closeCamera();
        currentRearCameraIndex = (currentRearCameraIndex + 1) % rearCameraIds.size();
        currentCameraId = rearCameraIds.get(currentRearCameraIndex);
        Log.d(TAG, "Switched to camera ID: " + currentCameraId);
        openCamera();
    }

    private Size[] getPreviewSizes() {
        try {
            if (cameraManager == null || currentCameraId == null) return new Size[]{new Size(1280, 720)};
            CameraCharacteristics characteristics = cameraManager.getCameraCharacteristics(currentCameraId);
            StreamConfigurationMap map = characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
            if (map != null) { return map.getOutputSizes(SurfaceHolder.class); }
            else { return new Size[]{new Size(1280, 720)}; }
        } catch (CameraAccessException | IllegalArgumentException e) {
            Log.e(TAG, "Error getting preview sizes for camera " + currentCameraId, e);
            return new Size[]{new Size(1280, 720)};
        }
    }

    private Size chooseOptimalPreviewSize(Size[] choices, int viewWidth, int viewHeight) {
        if (choices == null || choices.length == 0) { Log.e(TAG, "No preview sizes available, using default"); return new Size(1280, 720); }
        int targetWidth = viewWidth > 0 ? viewWidth : 1280; int targetHeight = viewHeight > 0 ? viewHeight : 720;
        List<Size> sortedChoices = new ArrayList<>(Arrays.asList(choices));
        Collections.sort(sortedChoices, (a, b) -> Long.compare((long)b.getWidth() * b.getHeight(), (long)a.getWidth() * a.getHeight()));
        Size optimalSize = null; double targetRatio = (double) targetWidth / targetHeight;
        for (Size size : sortedChoices) {
            if (size.getWidth() * size.getHeight() > 4000 * 3000) continue;
            double ratio = (double) size.getWidth() / size.getHeight();
            if (Math.abs(ratio - targetRatio) < 0.05) { optimalSize = size; break; }
        }
        if (optimalSize == null) {
            for (Size size : sortedChoices) { if (size.getWidth() * size.getHeight() <= 4000*3000) { optimalSize = size; break; } }
        }
        if (optimalSize == null) optimalSize = choices[0];
        Log.d(TAG, "Chosen preview size: " + optimalSize.getWidth() + "x" + optimalSize.getHeight() + " for view size " + targetWidth + "x" + targetHeight);
        return optimalSize;
    }


    private void startCameraPreview() {
        if (cameraDevice == null || cameraSurfaceHolder == null || !cameraSurfaceHolder.getSurface().isValid() || !isCameraOpen) { Log.w(TAG, "Cannot start preview..."); return; }
        if (backgroundHandler == null) { startBackgroundThread(); if(backgroundHandler == null) { Log.e(TAG, "Cannot start preview, background handler is null."); return;} }

        backgroundHandler.post(() -> {
            try {
                closeCameraPreviewSession();
                if (previewSize == null) { previewSize = chooseOptimalPreviewSize(getPreviewSizes(), cameraSurfaceView.getWidth(), cameraSurfaceView.getHeight()); if (previewSize == null) { Log.e(TAG, "Failed to select preview size"); return; } }

                Surface surface = cameraSurfaceHolder.getSurface();
                final Size finalPreviewSize = previewSize;
                runOnUiThread(() -> {
                     if (cameraSurfaceHolder != null && cameraSurfaceHolder.getSurface() != null && cameraSurfaceHolder.getSurface().isValid()) {
                         try {
                             cameraSurfaceHolder.setFixedSize(finalPreviewSize.getWidth(), finalPreviewSize.getHeight());
                             Log.d(TAG, "Set SurfaceHolder fixed size for preview (UI Thread): " + finalPreviewSize.getWidth() + "x" + finalPreviewSize.getHeight());
                         } catch(Exception e) { Log.e(TAG, "Error setting fixed size in startCameraPreview", e); }
                     } else { Log.w(TAG, "Surface became invalid before setting fixed size."); }
                 });

                previewRequestBuilder = cameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
                previewRequestBuilder.addTarget(surface);
                previewRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);

                cameraDevice.createCaptureSession(Collections.singletonList(surface), new CameraCaptureSession.StateCallback() {
                    @Override
                    public void onConfigured(@NonNull CameraCaptureSession session) {
                        if (cameraDevice == null || !isCameraOpen) { Log.w(TAG, "Camera closed or null during preview session config."); session.close(); return; }
                        cameraCaptureSession = session;
                        try {
                            cameraCaptureSession.setRepeatingRequest(previewRequestBuilder.build(), null, backgroundHandler);
                            Log.d(TAG, "Camera preview repeating request started.");
                        } catch (CameraAccessException | IllegalStateException e) { Log.e(TAG, "Error starting preview repeating request", e); }
                    }
                    @Override
                    public void onConfigureFailed(@NonNull CameraCaptureSession session) {
                        Log.e(TAG, "Failed to configure camera preview session.");
                        runOnUiThread(() -> Toast.makeText(MainActivity.this, "Failed to configure camera", Toast.LENGTH_SHORT).show());
                    }
                }, backgroundHandler);

            } catch (CameraAccessException | IllegalStateException | IllegalArgumentException e) {
                Log.e(TAG, "Error starting camera preview", e);
                 runOnUiThread(() -> Toast.makeText(MainActivity.this, "Error starting preview", Toast.LENGTH_SHORT).show());
            }
        });
    }

    // --- SurfaceHolder.Callback ---
    @Override
    public void surfaceCreated(@NonNull SurfaceHolder holder) {
        Log.d(TAG, "Surface created.");
        isSurfaceAvailable = true;
        if (ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED && !isCameraOpen) {
            openCamera();
        }
    }
    @Override
    public void surfaceChanged(@NonNull SurfaceHolder holder, int format, int width, int height) {
        Log.d(TAG, "Surface changed. New dimensions: " + width + "x" + height);
        if (isCameraOpen && cameraDevice != null) {
            previewSize = chooseOptimalPreviewSize(getPreviewSizes(), width, height);
            startCameraPreview();
        }
    }
    @Override
    public void surfaceDestroyed(@NonNull SurfaceHolder holder) {
        Log.d(TAG, "Surface destroyed.");
        isSurfaceAvailable = false;
        closeCamera();
    }

    // --- Image Loading and Processing ---
    private void checkPermissionAndPickImage() {
        String permission = Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU ? Manifest.permission.READ_MEDIA_IMAGES : Manifest.permission.READ_EXTERNAL_STORAGE;
        if (ContextCompat.checkSelfPermission(this, permission) != PackageManager.PERMISSION_GRANTED) { Log.d(TAG, "Requesting storage permission for picking image."); ActivityCompat.requestPermissions(this, new String[]{permission}, STORAGE_PERMISSION_CODE); }
        else { Log.d(TAG, "Storage permission already granted."); openImagePicker(); }
    }
    private void openImagePicker() {
        Intent intent = new Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI);
        intent.setType("image/*");
        try { imagePickerLauncher.launch(intent); Log.d(TAG, "Launching image picker."); }
        catch (Exception ex) { Log.e(TAG, "No activity found to handle image picking.", ex); Toast.makeText(this, "Cannot open image picker: " + ex.getMessage(), Toast.LENGTH_LONG).show(); }
    }
    private void loadImage(Uri uri) {
        if (uri == null) { Log.e(TAG, "Cannot load image, URI is null."); return; }
        Log.d(TAG, "Requesting image load for URI: " + uri);
        imageLoadExecutor.submit(() -> {
            Bitmap loadedBitmap = null; InputStream inputStream = null;
            try {
                ContentResolver resolver = getContentResolver();
                BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true;
                inputStream = resolver.openInputStream(uri); BitmapFactory.decodeStream(inputStream, null, options);
                if (inputStream != null) inputStream.close();
                int reqWidth = 1920; int reqHeight = 1080;
                options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight); options.inJustDecodeBounds = false;
                inputStream = resolver.openInputStream(uri); loadedBitmap = BitmapFactory.decodeStream(inputStream, null, options);
                Log.d(TAG, "Bitmap loaded in background: " + (loadedBitmap != null ? loadedBitmap.getWidth() + "x" + loadedBitmap.getHeight() : "null"));
            } catch (IOException e) { Log.e(TAG, "IOException loading bitmap", e);
            } catch (OutOfMemoryError oom) { Log.e(TAG, "OutOfMemoryError loading bitmap", oom); runOnUiThread(()-> Toast.makeText(this, "Image too large - Out of Memory", Toast.LENGTH_LONG).show());
            } catch (Exception e) { Log.e(TAG, "Exception loading bitmap", e);
            } finally { if (inputStream != null) { try { inputStream.close(); } catch (IOException e) { /* ignore */ } } }
            final Bitmap finalBitmap = loadedBitmap;
            runOnUiThread(() -> {
                if (finalBitmap != null) {
                    recycleBitmaps(); originalBitmap = finalBitmap; currentImageUri = uri;
                    resetTransformationsAndFit();
                    if (isPencilMode) { imageLoadExecutor.submit(this::processPencilEffect); } else { updateImageDisplay(); }
                } else { Toast.makeText(this, "Failed to load image", Toast.LENGTH_SHORT).show(); }
            });
        });
    }

    private int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) {
        final int height = options.outHeight; final int width = options.outWidth; int inSampleSize = 1;
        if (height > reqHeight || width > reqWidth) {
            final int halfHeight = height / 2; final int halfWidth = width / 2;
            while ((halfHeight / inSampleSize) >= reqHeight && (halfWidth / inSampleSize) >= reqWidth) { inSampleSize *= 2; }
        }
        Log.d(TAG, "Calculated inSampleSize: " + inSampleSize);
        return inSampleSize;
    }

    private void recycleBitmaps() {
        Bitmap ob = originalBitmap; Bitmap pb = pencilBitmap; Bitmap[] lb = layerBitmaps;
        originalBitmap = null; pencilBitmap = null; layerBitmaps = null;
        if (ob != null && !ob.isRecycled()) { ob.recycle(); Log.d(TAG, "Recycled originalBitmap"); }
        if (pb != null && !pb.isRecycled()) { pb.recycle(); Log.d(TAG, "Recycled pencilBitmap"); }
        if (lb != null) { for (int i = 0; i < lb.length; i++) { if (lb[i] != null && !lb[i].isRecycled()) { lb[i].recycle(); Log.d(TAG, "Recycled layerBitmap[" + i + "]"); } } }
    }

    private void recyclePencilBitmaps() {
        Bitmap pb = pencilBitmap; Bitmap[] lb = layerBitmaps;
        pencilBitmap = null; layerBitmaps = null;
        if (pb != null && !pb.isRecycled()) { pb.recycle(); Log.d(TAG, "Recycled pencilBitmap"); }
        if (lb != null) { for (int i = 0; i < lb.length; i++) { if (lb[i] != null && !lb[i].isRecycled()) { lb[i].recycle(); Log.d(TAG, "Recycled layerBitmap[" + i + "]"); } } }
    }

    private void resetTransformationsAndFit() {
        matrix.reset();
        if (originalBitmap == null || originalBitmap.isRecycled() || imageView.getWidth() == 0 || imageView.getHeight() == 0) {
            scaleFactor = 1.0f;
            // rotationAngle = 0.0f; // Угол сбрасывается при reset() матрицы
            if (imageView != null) runOnUiThread(() -> { imageView.setImageMatrix(matrix); imageView.invalidate(); });
            return;
        }
        final float viewWidth = imageView.getWidth(); final float viewHeight = imageView.getHeight();
        final float bmpWidth = originalBitmap.getWidth(); final float bmpHeight = originalBitmap.getHeight();
        float scale = Math.min(viewWidth / bmpWidth, viewHeight / bmpHeight); // Используем fitCenter по умолчанию
        float dx = (viewWidth - bmpWidth * scale) / 2f;
        float dy = (viewHeight - bmpHeight * scale) / 2f;
        matrix.setScale(scale, scale);
        matrix.postTranslate(dx, dy);
        scaleFactor = scale; // Сохраняем начальный масштаб
        // rotationAngle = 0.0f;
        if (imageView != null) runOnUiThread(() -> { imageView.setImageMatrix(matrix); imageView.invalidate(); });
        Log.d(TAG, "Image reset and fit CENTER. Scale: " + scaleFactor);
    }

    private void applyTransformations() {
        if (imageView != null) {
            runOnUiThread(() -> {
                imageView.setImageMatrix(matrix);
                imageView.invalidate();
            });
        }
    }

    private void setImageAlpha(int progress) {
        if (imageView != null) {
            float alpha = Math.max(0.0f, Math.min(1.0f, progress / 100.0f));
            runOnUiThread(() -> {
                imageView.setAlpha(alpha);
                imageView.invalidate();
            });
        }
    }

    private void processPencilEffect() {
        Log.d(TAG, "Processing pencil effect...");
        if (originalBitmap == null || originalBitmap.isRecycled()) { Log.w(TAG, "Original bitmap unavailable."); return; }
        final Bitmap sourceBitmap = originalBitmap.copy(originalBitmap.getConfig(), false);
        imageLoadExecutor.submit(() -> {
            recyclePencilBitmaps();
            Bitmap grayBitmap = null; Bitmap[] newLayerBitmaps = new Bitmap[PENCIL_HARDNESS.length]; boolean success = false;
            try {
                int width = sourceBitmap.getWidth(); int height = sourceBitmap.getHeight();
                grayBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
                Canvas canvasGray = new Canvas(grayBitmap); Paint paintGray = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.FILTER_BITMAP_FLAG);
                ColorMatrix cmGray = new ColorMatrix(); cmGray.setSaturation(0); paintGray.setColorFilter(new ColorMatrixColorFilter(cmGray));
                canvasGray.drawBitmap(sourceBitmap, 0, 0, paintGray);
                int[] pixels = new int[width * height]; grayBitmap.getPixels(pixels, 0, width, 0, 0, width, height);
                int numLayers = newLayerBitmaps.length; int step = 256 / numLayers;
                int[][] layerPixels = new int[numLayers][width * height];
                for (int i = 0; i < numLayers; i++) Arrays.fill(layerPixels[i], Color.TRANSPARENT);
                for (int i = 0; i < pixels.length; i++) { int gray = Color.red(pixels[i]); int layerIndex = getLayerIndex(gray); if (layerIndex >= 0) { layerPixels[layerIndex][i] = pixels[i]; } }
                pixels = null;
                for (int i = 0; i < numLayers; i++) { newLayerBitmaps[i] = Bitmap.createBitmap(layerPixels[i], width, height, Bitmap.Config.ARGB_8888); layerPixels[i] = null; }
                layerPixels = null; success = true; Log.d(TAG, "Pencil effect processing successful.");
            } catch (OutOfMemoryError e) { Log.e(TAG, "OutOfMemoryError processing pencil effect", e); runOnUiThread(()-> Toast.makeText(this, "Not enough memory for pencil effect", Toast.LENGTH_LONG).show()); if (grayBitmap != null && !grayBitmap.isRecycled()) grayBitmap.recycle(); for (int i = 0; i < newLayerBitmaps.length; i++) { if (newLayerBitmaps[i] != null && !newLayerBitmaps[i].isRecycled()) newLayerBitmaps[i].recycle(); }
            } catch (Exception e) { Log.e(TAG, "Error processing pencil effect", e); runOnUiThread(() -> Toast.makeText(this, "Error processing pencil effect", Toast.LENGTH_SHORT).show()); }
            finally { if (sourceBitmap != null && !sourceBitmap.isRecycled()) { sourceBitmap.recycle(); } if (grayBitmap != null && !grayBitmap.isRecycled()) { grayBitmap.recycle(); } }
            final boolean finalSuccess = success; final Bitmap[] finalLayerBitmaps = newLayerBitmaps;
            runOnUiThread(() -> {
                if (finalSuccess) { layerBitmaps = finalLayerBitmaps; pencilBitmap = null; }
                else { layerBitmaps = null; pencilBitmap = null; isPencilMode = false; pencilModeSwitch.setChecked(false); layerSelectButton.setVisibility(View.GONE); }
                updateImageDisplay();
            });
        });
    }

    private int getLayerIndex(int grayValue) {
        int numLayers = PENCIL_HARDNESS.length;
        int index = (int) (((float) grayValue / 256.0f) * numLayers);
        return Math.max(0, Math.min(index, numLayers - 1));
    }

    private void updateImageDisplay() {
        Log.d(TAG, "Updating image display: isPencilMode=" + isPencilMode + ", isImageVisible=" + isImageVisible);
        if (!isImageVisible || originalBitmap == null || originalBitmap.isRecycled()) {
            Log.d(TAG, "Hiding ImageView or originalBitmap is unavailable.");
            runOnUiThread(() -> { if (imageView != null) { imageView.setImageBitmap(null); imageView.setVisibility(View.INVISIBLE); imageView.invalidate(); } });
            return;
        }
        Bitmap bitmapToDisplay = null; boolean isPencilBitmapReady = isPencilMode && layerBitmaps != null;
        if (isPencilBitmapReady) {
            Log.d(TAG, "Updating display for Pencil mode");
            try {
                bitmapToDisplay = Bitmap.createBitmap(originalBitmap.getWidth(), originalBitmap.getHeight(), Bitmap.Config.ARGB_8888);
                Canvas canvas = new Canvas(bitmapToDisplay); canvas.drawColor(Color.TRANSPARENT);
                Paint layerPaint = new Paint(Paint.FILTER_BITMAP_FLAG); boolean drawnSomething = false;
                for (int i = 0; i < layerBitmaps.length; i++) { if (layerVisibility[i] && layerBitmaps[i] != null && !layerBitmaps[i].isRecycled()) { canvas.drawBitmap(layerBitmaps[i], 0, 0, layerPaint); drawnSomething = true; } }
                Log.d(TAG, "Drew visible pencil layers. Drawn something: " + drawnSomething);
                if (!drawnSomething && bitmapToDisplay != null && !bitmapToDisplay.isRecycled()) { bitmapToDisplay.recycle(); bitmapToDisplay = Bitmap.createBitmap(1, 1, Bitmap.Config.ARGB_8888); bitmapToDisplay.eraseColor(Color.TRANSPARENT); }
            } catch (OutOfMemoryError e) {
                Log.e(TAG, "OOM Error creating result bitmap for pencil mode", e); bitmapToDisplay = originalBitmap;
                isPencilMode = false;
                runOnUiThread(() -> { pencilModeSwitch.setChecked(false); layerSelectButton.setVisibility(View.GONE); Toast.makeText(this, "Out of memory displaying layers", Toast.LENGTH_SHORT).show(); });
                recyclePencilBitmaps();
            } catch (Exception e) { Log.e(TAG, "Error composing pencil layers", e); bitmapToDisplay = originalBitmap; }
        } else { Log.d(TAG, "Displaying original bitmap"); bitmapToDisplay = originalBitmap; }
        final Bitmap finalBitmap = bitmapToDisplay;
        runOnUiThread(() -> {
            if (imageView != null) {
                if (finalBitmap != null && !finalBitmap.isRecycled()) { imageView.setImageBitmap(finalBitmap); imageView.setVisibility(View.VISIBLE); imageView.setImageMatrix(matrix); setImageAlpha(transparencySeekBar.getProgress()); imageView.invalidate(); Log.d(TAG, "ImageView updated."); }
                else { Log.w(TAG, "Bitmap to display is null or recycled."); imageView.setImageBitmap(null); imageView.setVisibility(View.INVISIBLE); }
            }
        });
    }

    // --- Диалог выбора слоев ---
    private void showLayerSelectionDialog() {
        final Dialog dialog = new Dialog(this);
        dialog.setContentView(R.layout.dialog_layer_selection);
        dialog.setTitle(R.string.layer_selection_title);
        // *** ИСПРАВЛЕНО ID ЗДЕСЬ ***
        RecyclerView recyclerView = dialog.findViewById(R.id.recyclerView);
        if (recyclerView == null) { Log.e(TAG, "RecyclerView (R.id.recyclerView) not found!"); Toast.makeText(this, "Error dialog", Toast.LENGTH_SHORT).show(); return; }
        recyclerView.setLayoutManager(new LinearLayoutManager(this));
        LayerAdapter adapter = new LayerAdapter(PENCIL_HARDNESS, layerVisibility, this);
        recyclerView.setAdapter(adapter);
        dialog.show();
    }
    @Override
    public void onLayerVisibilityChanged(int position, boolean isVisible) {
        if (position >= 0 && position < layerVisibility.length) {
            layerVisibility[position] = isVisible;
            Log.d(TAG, "Layer " + position + " (" + PENCIL_HARDNESS[position] + ") visibility changed to: " + isVisible);
            updateImageDisplay();
        } else {
            Log.w(TAG, "Invalid position received from LayerAdapter: " + position);
        }
    }

    // --- Сохранение/Загрузка параметров ---
    private void checkPermissionAndSaveParameters() { openSaveFilePicker(); }
    private void checkPermissionAndLoadParameters() { openLoadFilePicker(); }
    private void openSaveFilePicker() {
        Intent intent = new Intent(Intent.ACTION_CREATE_DOCUMENT);
        intent.addCategory(Intent.CATEGORY_OPENABLE);
        intent.setType("application/json");
        intent.putExtra(Intent.EXTRA_TITLE, "camera_overlay_params.json");
        try { saveFileLauncher.launch(intent); }
        catch (Exception e) { Log.e(TAG, "Could not launch save file picker", e); Toast.makeText(this, "Error opening save dialog", Toast.LENGTH_SHORT).show(); }
    }
    private void openLoadFilePicker() {
        Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);
        intent.addCategory(Intent.CATEGORY_OPENABLE);
        intent.setType("application/json");
        try { loadFileLauncher.launch(intent); }
        catch (Exception e) { Log.e(TAG, "Could not launch load file picker", e); Toast.makeText(this, "Error opening load dialog", Toast.LENGTH_SHORT).show(); }
    }
    private void saveParametersToFile(Uri uri) {
        if (originalBitmap == null || originalBitmap.isRecycled()) { Toast.makeText(this, "Load an image first to save parameters", Toast.LENGTH_SHORT).show(); return; }
        if (uri == null) { Log.e(TAG, "Save URI is null"); return; }
        try {
            JSONObject json = new JSONObject();
            if (currentImageUri != null) { json.put("imageUri", currentImageUri.toString()); }
            JSONArray matrixArray = new JSONArray(); float[] matrixValues = new float[9]; matrix.getValues(matrixValues); for (float value : matrixValues) matrixArray.put(value);
            json.put("matrix", matrixArray);
            json.put("transparency", transparencySeekBar.getProgress());
            json.put("isPencilMode", isPencilMode);
            json.put("isImageVisible", isImageVisible);
            json.put("controlsVisible", controlsVisibilityCheckbox.isChecked());
            JSONArray visibilityArray = new JSONArray(); for (boolean visible : layerVisibility) visibilityArray.put(visible);
            json.put("layerVisibility", visibilityArray);
            ContentResolver resolver = getContentResolver();
            try (OutputStream outputStream = resolver.openOutputStream(uri)) {
                if (outputStream != null) { outputStream.write(json.toString(2).getBytes()); Toast.makeText(this, "Parameters saved", Toast.LENGTH_SHORT).show(); Log.d(TAG, "Parameters saved to " + uri); }
                else { throw new IOException("OutputStream is null"); }
            }
        } catch (Exception e) { Log.e(TAG, "Error saving parameters to file", e); Toast.makeText(this, "Failed to save parameters", Toast.LENGTH_LONG).show(); }
    }

    private void loadParametersFromFile(Uri uri) {
        if (uri == null) { Log.e(TAG, "Load URI is null"); return; }
        Log.d(TAG, "Loading parameters from URI: " + uri);
        try {
            ContentResolver resolver = getContentResolver();
            try (InputStream inputStream = resolver.openInputStream(uri)) {
                if (inputStream != null) {
                    StringBuilder jsonString = new StringBuilder(); byte[] buffer = new byte[4096]; int bytesRead;
                    while ((bytesRead = inputStream.read(buffer)) != -1) { jsonString.append(new String(buffer, 0, bytesRead)); }
                    JSONObject json = new JSONObject(jsonString.toString());
                    Uri loadedImageUri = null; if (json.has("imageUri")) { loadedImageUri = Uri.parse(json.getString("imageUri")); }
                    if (loadedImageUri != null && !loadedImageUri.equals(currentImageUri)) {
                        Log.d(TAG, "Loading image specified in parameters: " + loadedImageUri);
                        currentImageUri = loadedImageUri;
                        final JSONObject finalJson = json;
                        loadImageAndApplyParams(currentImageUri, finalJson);
                    } else {
                        applyLoadedParameters(json);
                    }
                } else { throw new IOException("InputStream is null"); }
            }
        } catch (Exception e) { Log.e(TAG, "Error loading parameters from file", e); Toast.makeText(this, "Failed to load parameters", Toast.LENGTH_LONG).show(); }
    }

    private void loadImageAndApplyParams(Uri uri, JSONObject paramsToApply) {
        if (uri == null) { return; }
        Log.d(TAG, "Requesting image load for URI (with params): " + uri);
        imageLoadExecutor.submit(() -> {
            Bitmap loadedBitmap = null; InputStream inputStream = null;
            try {
                ContentResolver resolver = getContentResolver();
                BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true;
                inputStream = resolver.openInputStream(uri); BitmapFactory.decodeStream(inputStream, null, options);
                if (inputStream != null) inputStream.close();
                int reqWidth = 1920; int reqHeight = 1080;
                options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight); options.inJustDecodeBounds = false;
                inputStream = resolver.openInputStream(uri); loadedBitmap = BitmapFactory.decodeStream(inputStream, null, options);
            } catch (Exception e) { Log.e(TAG, "Exception loading bitmap for params", e); }
            finally { if (inputStream != null) { try { inputStream.close(); } catch (IOException e) { /* ignore */ } } }
            final Bitmap finalBitmap = loadedBitmap;
            runOnUiThread(() -> {
                if (finalBitmap != null) {
                    recycleBitmaps(); originalBitmap = finalBitmap; currentImageUri = uri;
                    try { applyLoadedParameters(paramsToApply); }
                    catch (Exception e) { Log.e(TAG, "Error applying loaded parameters after image load", e); Toast.makeText(this, "Error applying parameters", Toast.LENGTH_SHORT).show(); resetTransformationsAndFit(); updateImageDisplay(); }
                } else { Toast.makeText(this, "Failed to load image specified in parameters", Toast.LENGTH_SHORT).show(); }
            });
        });
    }

    private void applyLoadedParameters(JSONObject json) throws Exception {
        Log.d(TAG, "Applying loaded parameters...");
        if (json.has("matrix")) {
            JSONArray matrixArray = json.getJSONArray("matrix");
            if (matrixArray.length() >= 9) {
                float[] matrixValues = new float[9];
                for (int i = 0; i < 9; i++) matrixValues[i] = (float) matrixArray.getDouble(i);
                matrix.setValues(matrixValues);
                scaleFactor = getMatrixScale(matrix); // Восстанавливаем масштаб из матрицы
            }
        } else { matrix.reset(); scaleFactor = 1.0f; }

        if (json.has("transparency")) transparencySeekBar.setProgress(json.getInt("transparency"));
        if (json.has("isPencilMode")) isPencilMode = json.getBoolean("isPencilMode");
        if (json.has("isImageVisible")) isImageVisible = json.getBoolean("isImageVisible");
        boolean controlsVisible = true; if (json.has("controlsVisible")) controlsVisible = json.getBoolean("controlsVisible");

        if (json.has("layerVisibility")) {
            JSONArray visibilityArray = json.getJSONArray("layerVisibility");
            for (int i = 0; i < visibilityArray.length() && i < layerVisibility.length; i++) { layerVisibility[i] = visibilityArray.getBoolean(i); }
        }
        final boolean finalControlsVisible = controlsVisible;
        runOnUiThread(() -> {
            pencilModeSwitch.setChecked(isPencilMode);
            hideImageCheckbox.setChecked(!isImageVisible);
            controlsVisibilityCheckbox.setChecked(finalControlsVisible);
            updateControlsVisibility(finalControlsVisible);
            applyTransformations();
             if (isPencilMode && originalBitmap != null && !originalBitmap.isRecycled()) { imageLoadExecutor.submit(this::processPencilEffect); }
             else { updateImageDisplay(); }
            Toast.makeText(this, "Parameters applied", Toast.LENGTH_SHORT).show();
            Log.d(TAG, "Parameters applied successfully.");
        });
    }

    // --- Жизненный цикл Activity ---
    @Override
    protected void onResume() {
        super.onResume();
        Log.d(TAG, "onResume");
        hideSystemUI();
        startBackgroundThread();
        if (isSurfaceAvailable && ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED && !isCameraOpen) {
            Log.d(TAG, "Opening camera from onResume");
            openCamera();
        }
        updateImageDisplay();
    }
    @Override
    protected void onPause() {
        Log.d(TAG, "onPause");
        closeCamera();
        super.onPause();
    }
    @Override
    protected void onDestroy() {
        Log.d(TAG, "onDestroy");
        closeCamera();
        cameraExecutor.shutdown();
        imageLoadExecutor.shutdown();
        recycleBitmaps();
        super.onDestroy();
    }
    @Override
    protected void onSaveInstanceState(@NonNull Bundle outState) {
        super.onSaveInstanceState(outState);
        Log.d(TAG, "Saving instance state...");
        if (currentImageUri != null) { outState.putString(KEY_IMAGE_URI, currentImageUri.toString()); }
        if (originalBitmap != null) { float[] matrixValues = new float[9]; matrix.getValues(matrixValues); outState.putFloatArray(KEY_MATRIX_VALUES, matrixValues); }
        if (controlsVisibilityCheckbox != null) { outState.putBoolean(KEY_CONTROLS_VISIBLE, controlsVisibilityCheckbox.isChecked()); }
        outState.putBoolean(KEY_PENCIL_MODE, isPencilMode);
        outState.putBooleanArray(KEY_LAYER_VISIBILITY, layerVisibility);
        outState.putBoolean(KEY_IMAGE_VISIBLE, isImageVisible);
        if (currentCameraId != null) { outState.putString(KEY_CURRENT_CAMERA_ID, currentCameraId); }
    }
    private void restoreInstanceState(@NonNull Bundle savedInstanceState) {
        Log.d(TAG, "Restoring instance state...");
        String savedUriString = savedInstanceState.getString(KEY_IMAGE_URI);
        boolean imageNeedsLoading = false;
        if (savedUriString != null) {
             Uri savedUri = Uri.parse(savedUriString);
             if (!savedUri.equals(currentImageUri)) { currentImageUri = savedUri; imageNeedsLoading = true; }
             Log.d(TAG, "Restored Image URI: " + currentImageUri);
        }
        float[] savedMatrixValues = savedInstanceState.getFloatArray(KEY_MATRIX_VALUES);
        if (savedMatrixValues != null) {
            matrix.setValues(savedMatrixValues);
            scaleFactor = getMatrixScale(matrix);
            Log.d(TAG, "Restored Matrix, Scale");
        }
        isPencilMode = savedInstanceState.getBoolean(KEY_PENCIL_MODE, false);
        boolean[] savedLayerVisibility = savedInstanceState.getBooleanArray(KEY_LAYER_VISIBILITY);
        if (savedLayerVisibility != null && savedLayerVisibility.length == layerVisibility.length) { System.arraycopy(savedLayerVisibility, 0, layerVisibility, 0, layerVisibility.length); }
        isImageVisible = savedInstanceState.getBoolean(KEY_IMAGE_VISIBLE, true);
        boolean restoredControlsVisible = savedInstanceState.getBoolean(KEY_CONTROLS_VISIBLE, true);
        pencilModeSwitch.setChecked(isPencilMode);
        hideImageCheckbox.setChecked(!isImageVisible);
        controlsVisibilityCheckbox.setChecked(restoredControlsVisible);
        updateControlsVisibility(restoredControlsVisible);
        setImageAlpha(transparencySeekBar.getProgress());
        currentCameraId = savedInstanceState.getString(KEY_CURRENT_CAMERA_ID, currentCameraId);
        if (imageNeedsLoading) { loadImage(currentImageUri); }
        else if (originalBitmap != null) { applyTransformations(); updateImageDisplay(); }
    }

    // --- Обработка Касаний и Жестов ---
    private class TouchAndGestureListener implements View.OnTouchListener {
        PointF startDragPoint = new PointF(); Matrix savedMatrix = new Matrix();
        @Override
        public boolean onTouch(View v, MotionEvent event) {
            if (originalBitmap == null || originalBitmap.isRecycled()) return false;
            scaleGestureDetector.onTouchEvent(event);
            int action = event.getActionMasked(); int pointerCount = event.getPointerCount();
            switch (action) {
                case MotionEvent.ACTION_DOWN: savedMatrix.set(matrix); startDragPoint.set(event.getX(), event.getY()); touchMode = DRAG; Log.d(TAG, "Touch Mode: DRAG"); break;
                case MotionEvent.ACTION_POINTER_DOWN: if (pointerCount >= 2) { savedMatrix.set(matrix); initialAngle = rotation(event); midPoint(midPoint, event); touchMode = ZOOM; Log.d(TAG, "Touch Mode: ZOOM/ROTATE"); } break;
                case MotionEvent.ACTION_MOVE:
                    if (touchMode == DRAG && pointerCount == 1 && !scaleGestureDetector.isInProgress()) { matrix.set(savedMatrix); float dx = event.getX() - startDragPoint.x; float dy = event.getY() - startDragPoint.y; matrix.postTranslate(dx, dy); applyTransformations(); }
                    else if (touchMode == ZOOM && pointerCount >= 2) { float currentAngle = rotation(event); float deltaAngle = currentAngle - initialAngle; float initialScaleFactor = getMatrixScale(savedMatrix); float scaleChange = (initialScaleFactor > 0.001f) ? scaleFactor / initialScaleFactor : 1f; matrix.set(savedMatrix); midPoint(midPoint, event); matrix.postScale(scaleChange, scaleChange, midPoint.x, midPoint.y); matrix.postRotate(deltaAngle, midPoint.x, midPoint.y); applyTransformations(); }
                    break;
                case MotionEvent.ACTION_POINTER_UP: if (pointerCount == 2) { int remainingPointerIndex = (event.getActionIndex() == 0) ? 1 : 0; startDragPoint.set(event.getX(remainingPointerIndex), event.getY(remainingPointerIndex)); savedMatrix.set(matrix); touchMode = DRAG; Log.d(TAG, "Touch Mode changed to DRAG after POINTER_UP"); } else if (pointerCount < 2) { touchMode = NONE; Log.d(TAG, "Touch Mode: NONE (Pointer Up)"); } break;
                case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: touchMode = NONE; Log.d(TAG, "Touch Mode: NONE (Up/Cancel)"); break;
            }
            return true;
        }
        private void midPoint(PointF point, MotionEvent event) { if (event.getPointerCount() < 2) { point.set(event.getX(), event.getY()); return; } float x = event.getX(0) + event.getX(1); float y = event.getY(0) + event.getY(1); point.set(x / 2f, y / 2f); }
        private float rotation(MotionEvent event) { if (event.getPointerCount() < 2) return 0f; double delta_x = (event.getX(0) - event.getX(1)); double delta_y = (event.getY(0) - event.getY(1)); return (float) Math.toDegrees(Math.atan2(delta_y, delta_x)); }
        // getMatrixScale удален отсюда
    }

    private class ScaleListener extends ScaleGestureDetector.SimpleOnScaleGestureListener {
        @Override public boolean onScaleBegin(@NonNull ScaleGestureDetector detector) { if (originalBitmap == null || originalBitmap.isRecycled()) return false; touchMode = ZOOM; return true; }
        @Override public boolean onScale(@NonNull ScaleGestureDetector detector) { if (originalBitmap == null || touchMode != ZOOM) return false; scaleFactor *= detector.getScaleFactor(); scaleFactor = Math.max(0.1f, Math.min(scaleFactor, 10.0f)); return true; }
        // getMatrixScale удален отсюда
    }

    // --- Вспомогательные методы ---

    // Метод getMatrixScale (ПЕРЕМЕЩЕН ИЗ TouchAndGestureListener)
    private float getMatrixScale(Matrix mat) {
        float[] values = new float[9]; mat.getValues(values);
        float scaleX = values[Matrix.MSCALE_X]; float skewY = values[Matrix.MSKEW_Y];
        // Используем более точный расчет масштаба, учитывая возможный поворот/наклон
        return (float) Math.sqrt(scaleX * scaleX + skewY * skewY);
    }

    public Display getDisplay() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            DisplayManager displayManager = (DisplayManager) getSystemService(Context.DISPLAY_SERVICE);
            if (displayManager != null) { return displayManager.getDisplay(Display.DEFAULT_DISPLAY); }
            else { Log.e(TAG, "DisplayManager service not found!"); /* Fallback */ }
        }
        //noinspection deprecation
        return getWindowManager().getDefaultDisplay();
    }
}

# app/src/main/res/drawable/ic_open_arrow.png
PNG

   IHDR         \rf   sRGB    gAMA  a   	pHYs    od  xIDATx^+I˕HJ$D"H$D"HJ$9=UsGnVfWDt<z'>J&Z7D$O_=oI3~I_%7/?% Xg[?
t,?ϒ"7Hn J|;
OT2K]]_ ĕ-X-J9 ѯ/QI:G7nq+sTQ*H7$7%/~K$
[-,9t+ῢݗ!_)yGC AşY ]yT$o8
3}.Z4?S5F]hY%&x{sc{IR oI(E7MiP*%Q 0;w`|[,ޤ2CUxCsH@.K[1q=xSF6PRz(18qTvޥ$tBF\*c`BpE,QD*kmxQ}2
C/,p@AF(T~t+_5{51\1T~tR6k:ʏp@GPhZ I5#4
sҵnOal?J<w	D¬>4t-y!K5Ļ T>/-΋ V/1Ȋ6,/zDt3'hEY:forqWʌd|
j+x||W?.}ĎDg 	ZK|=Uz/.QpCȳw'I?}wui6|ggk?'&d%BxȜg8㛽ҟoQYxac	o{v7i^;9D!XP׹XE=Uch|kp%f߷Os?`!O6qz?[n7Nd%?* {9{KξQe݄$/=.03#çJ㥞|O!H5Gn[Ugs6gW;Gawx-q7pC2gedXiq xS4N/+qzVַ$d.ǽ#_"oy;yr]}zgr6$`+J1LBr^4XEsFI-\ Fz"3^}^_ȬA0Qk7&wNYqwf$'Jܹx ٯspITm(Enj/*=ʿ-4$t7q\*h&H^y)p8OϣF`N0j?=]}T|pggA3-DtF\&yoOİ;'zpvCf_7#@<+=[oA[گ1Ńs	1.;? S~tȘq2mCɟ>8Org	ɛ3=䅡dXPɟ̰I F
)jЃ~}c]z}J>9GZ.y-vɾa@'cq.@ R"3[^K{}̎G'u=xvęWf/]o*zojua۱#ɓn'}}ual嘀{~w]B>[:@mmwJ~xW[=
?p+Itx﫿pC+K~t5.`fYd8fԲU$?|0W1DD%?!;h7?\ɏ.{o2p{ʒ])F`\ɏW:K}p~AS;ca,$/"|rv*v&tӻ Lqe*yd|;G`4VʒMNwx`@I>4FnO8`2+CEmj_ y~"T[開- ɇfqO2T|hjn~A򢉻]s|h"O6`SQI>41`'}\OC95ZhҳWRYDcܰN$R>ˍ`Sm,SQ!7	@a0IH׋v1`y{7	vN v9l%Ö `InW*yr nWSHGCA)N ,M݃Az Ҕ_$D\"I63$Rvk#4O&k9$RmeI ZL6'sSQxUJ9OւD`ݶ|0, kRzX#}{r X3uf2MT1HkoC' [; ڔ1HXzA ][->-(8?E?lEIA:9)U*h ST1翷a[<`b	~(bT?Eja(E | fV&Wh  X ⯨bTΟ4OQE: (@[QzF?V UJl IT)*i&QD jUJl IT)*i&QD jUJl IT)*i&QD jUJl IT)*i&QD jUJl IT)*i&QD jUJl IT)*i&Qx&=JQȓy]?/ΗAJevx{хps%]A>sAt*-q?|@Rht&'q?L|@'RYEh\*C~KeGWC>Q܈a4&q?
F"!ЀTFKCB> T6
IeBA> T:H@@>`caSl$yOC>`s~H%!V&XXB>`A[~H$_	,yJMA>`&K~h3HCR|w&JC7 yEA>`q?t	3G5NHC$O$?~(I|< ܉<e:o~ Q.s&C|Ε #q?	|΍`tN #*s!H7 q?49\A ;q?41Ds /q?4б,@|`!Rtl 6"Xt q?XV&E>@@ Y>@ML~$g$c|> ! Y,&H" 'q?@#̞4l q?@\{4U q.u 09t|Kzq?@q~9c p Ÿ'q?@AJ??lb    IENDB`
# app/src/main/res/layout/activity_main.xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <SurfaceView
        android:id="@+id/cameraSurfaceView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_centerInParent="true" />

    <ImageView
        android:id="@+id/imageView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_centerInParent="true" />

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_alignParentBottom="true"
        android:orientation="vertical"
        android:padding="10dp">

        <SeekBar
            android:id="@+id/transparencySeekBar"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:max="100"
            android:progress="100" />

        <Button
            android:id="@+id/pickImageButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/pick_image" />

        <Switch
            android:id="@+id/pencilModeSwitch"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/pencil_mode" />

        <Button
            android:id="@+id/layerSelectButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/select_layers"
            android:visibility="gone" />

        <CheckBox
            android:id="@+id/controlsVisibilityCheckbox"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/show_controls"
            android:checked="true" />

        <CheckBox
            android:id="@+id/hideImageCheckbox"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/hide_image" />

        <Button
            android:id="@+id/saveParametersButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/save_parameters" />

        <Button
            android:id="@+id/loadParametersButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/load_parameters" />

        <Button
            android:id="@+id/switchCameraButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/switch_camera" />
    </LinearLayout>

</RelativeLayout>

# app/src/main/res/layout/dialog_layer_selection.xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="wrap_content">
<!-- Это тестовое изменение -->
    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/recyclerView"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent" /> <!-- <<<=== УБЕДИТЕСЬ, ЧТО ЗДЕСЬ ЕСТЬ СЛЭШ '/' ПЕРЕД '>' -->

</androidx.constraintlayout.widget.ConstraintLayout>

# app/src/main/res/layout/item_layer.xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:padding="8dp">

    <TextView
        android:id="@+id/layerText"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:textSize="16sp" />

    <CheckBox
        android:id="@+id/layerCheckBox"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" />
</LinearLayout>

# app/src/main/res/mipmap-hdpi/ic_launcher.png
PNG

   IHDR   H   H   o#!   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  {ܙ,   bKGD-   tIME(`   IDAT(c``   _   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`
# app/src/main/res/mipmap-hdpi/ic_launcher_round.png
PNG

   IHDR   H   H   o#!   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  ?/O   bKGD-   tIME(`   IDAT(c``   _   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`
# app/src/main/res/mipmap-mdpi/ic_launcher.png
PNG

   IHDR   0   0   mk   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  {ܙ,   bKGD-   tIME'N|   IDATc` P    %tEXtdate:create 2025-04-27T16:18:39+00:00s   %tEXtdate:modify 2025-04-27T16:18:39+00:00Aq    IENDB`
# app/src/main/res/mipmap-mdpi/ic_launcher_round.png
PNG

   IHDR   0   0   mk   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  ?/O   bKGD-   tIME(`   IDATc` P    %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`
# app/src/main/res/mipmap-xhdpi/ic_launcher.png
PNG

   IHDR   `   `   V{   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  {ܙ,   bKGD-   tIME(`   IDAT8c``	  t   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`
# app/src/main/res/mipmap-xhdpi/ic_launcher_round.png
PNG

   IHDR   `   `   V{   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  ?/O   bKGD-   tIME(`   IDAT8c``	  t   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`
# app/src/main/res/mipmap-xxhdpi/ic_launcher.png
PNG

   IHDR         ݈p   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  {ܙ,   bKGD-   tIME(`   IDATH1    Om   
 >4   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`
# app/src/main/res/mipmap-xxhdpi/ic_launcher_round.png
PNG

   IHDR         ݈p   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  ?/O   bKGD-   tIME(`   IDATH1    Om   
 >4   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`
# app/src/main/res/mipmap-xxxhdpi/ic_launcher.png
PNG

   IHDR         hD   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  {ܙ,   bKGD-   tIME(`   IDATX1    Om      R   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`
# app/src/main/res/mipmap-xxxhdpi/ic_launcher_round.png
PNG

   IHDR         hD   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  ?/O   bKGD-   tIME)g{   IDATX1    Om      R   %tEXtdate:create 2025-04-27T16:18:41+00:00J6P   %tEXtdate:modify 2025-04-27T16:18:41+00:00;k    IENDB`
# app/src/main/res/values/strings.xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">HelloWorld</string>
    <string name="pick_image">Pick Image</string>
    <string name="show_controls">Show Controls</string>
    <string name="pencil_mode">Pencil Mode</string>
    <string name="select_layers">Select Layers</string>
    <string name="hide_image">Hide Image</string>
    <string name="save_parameters">Save Parameters</string>
    <string name="load_parameters">Load Parameters</string>
    <string name="switch_camera">Switch Camera</string>
    <string name="layer_selection_title">Select Pencil Layers</string>
</resources>

# app/src/main/res/values/themes.xml
<?xml version="1.0" encoding="utf-8"?>
<resources xmlns:tools="http://schemas.android.com/tools">
    <style name="Theme.HelloWorld" parent="Theme.AppCompat.Light.DarkActionBar">
        <item name="colorPrimary">@android:color/black</item>
        <item name="colorPrimaryDark">@android:color/black</item>
        <item name="colorAccent">@android:color/holo_blue_light</item>
    </style>
</resources>

# app/src/main/res/xml/backup_rules.xml
<?xml version="1.0" encoding="utf-8"?>
<full-backup-content>
    <include domain="file" path="." />
</full-backup-content>

# app/src/main/res/xml/data_extraction_rules.xml
<?xml version="1.0" encoding="utf-8"?>
<data-extraction-rules>
    <cloud-backup>
        <include domain="file" />
    </cloud-backup>
</data-extraction-rules>

# app/src/main/AndroidManifest.xml:
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">

    <!-- Разрешения -->
    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.READ_MEDIA_IMAGES" />

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.HelloWorld">
        <activity
            android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>



===== File: ./fix_build.sh =====
#!/bin/bash

# Убедимся, что мы в корневой директории проекта
PROJECT_DIR="/root/android-hello-world-app"
cd $PROJECT_DIR || { echo "Директория проекта не найдена!"; exit 1; }

# Создание или обновление dialog_layer_selection.xml
echo "Создание/обновление dialog_layer_selection.xml..."
mkdir -p app/src/main/res/layout
cat > app/src/main/res/layout/dialog_layer_selection.xml << 'EOL'
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="16dp">

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/layerRecyclerView"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

</LinearLayout>
EOL

# Создание или обновление strings.xml
echo "Создание/обновление strings.xml..."
mkdir -p app/src/main/res/values
cat > app/src/main/res/values/strings.xml << 'EOL'
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">HelloWorld</string>
    <string name="layer_selection_title">Select Pencil Layers</string>
    <string name="pick_image">Pick Image</string>
    <string name="pencil_mode">Pencil Mode</string>
    <string name="select_layers">Select Layers</string>
    <string name="show_controls">Show Controls</string>
    <string name="hide_image">Hide Image</string>
    <string name="save_parameters">Save Parameters</string>
    <string name="load_parameters">Load Parameters</string>
    <string name="switch_camera">Switch Camera</string>
    <string name="capture_image">Capture Image</string>
</resources>
EOL

# Замена MainActivity.java с добавленными импортами
echo "Замена MainActivity.java..."
cat > app/src/main/java/com/example/helloworld/MainActivity.java << 'EOL'
package com.example.helloworld;

import android.Manifest;
import android.app.Dialog;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.res.Configuration;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.ColorMatrix;
import android.graphics.ColorMatrixColorFilter;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.hardware.camera2.CameraAccessException;
import android.hardware.camera2.CameraCaptureSession;
import android.hardware.camera2.CameraCharacteristics;
import android.hardware.camera2.CameraDevice;
import android.hardware.camera2.CameraManager;
import android.hardware.camera2.CaptureRequest;
import android.hardware.camera2.TotalCaptureResult;
import android.media.Image;
import android.media.ImageReader;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.HandlerThread;
import android.provider.MediaStore;
import android.util.Log;
import android.util.Size;
import android.view.MotionEvent;
import android.view.ScaleGestureDetector;
import android.view.Surface;
import android.view.SurfaceHolder;
import android.view.SurfaceView;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.ImageView;
import android.widget.SeekBar;
import android.widget.Switch;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.app.ActivityCompat;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class MainActivity extends AppCompatActivity implements LayerAdapter.OnLayerVisibilityChangedListener {

    private static final String TAG = "MainActivity";
    private static final int REQUEST_CAMERA_PERMISSION = 100;
    private static final int REQUEST_STORAGE_PERMISSION = 101;
    private static final int PICK_IMAGE_REQUEST = 1;

    private SurfaceView cameraSurfaceView;
    private ImageView imageView;
    private SeekBar transparencySeekBar;
    private Button pickImageButton;
    private Switch pencilModeSwitch;
    private Button layerSelectButton;
    private CheckBox controlsVisibilityCheckbox;
    private CheckBox hideImageCheckbox;
    private Button saveParametersButton;
    private Button loadParametersButton;
    private Button switchCameraButton;
    private Button captureButton;

    private CameraDevice cameraDevice;
    private CameraCaptureSession cameraCaptureSession;
    private CaptureRequest.Builder previewRequestBuilder;
    private String cameraId;
    private Size previewSize;
    private HandlerThread backgroundThread;
    private Handler backgroundHandler;
    private final Object cameraOpenCloseLock = new Object();
    private volatile boolean isSurfaceAvailable = false;
    private volatile boolean isCameraPendingOpen = false;
    private volatile boolean isCameraOpen = false;

    private Bitmap originalBitmap;
    private Bitmap pencilBitmap;
    private Bitmap[] layerBitmaps;
    private boolean[] layerVisibility;
    private Matrix matrix = new Matrix();
    private float scaleFactor = 1.0f;
    private float rotationAngle = 0.0f;
    private boolean isPencilMode = false;
    private boolean isImageVisible = true;
    private ScaleGestureDetector scaleGestureDetector;
    private float lastTouchX, lastTouchY;
    private boolean isDragging = false;

    private String[] cameraIds;
    private int currentCameraIndex = 0;

    private ImageReader imageReader;
    private static final int CAPTURE_WIDTH = 1280;
    private static final int CAPTURE_HEIGHT = 720;

    private static final String[] PENCIL_HARDNESS = {
            "9H", "8H", "7H", "6H", "5H", "4H", "3H", "2H", "H", "F",
            "HB", "B", "2B", "3B", "4B", "5B", "6B", "7B", "8B", "9B"
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        cameraSurfaceView = findViewById(R.id.cameraSurfaceView);
        imageView = findViewById(R.id.imageView);
        transparencySeekBar = findViewById(R.id.transparencySeekBar);
        pickImageButton = findViewById(R.id.pickImageButton);
        pencilModeSwitch = findViewById(R.id.pencilModeSwitch);
        layerSelectButton = findViewById(R.id.layerSelectButton);
        controlsVisibilityCheckbox = findViewById(R.id.controlsVisibilityCheckbox);
        hideImageCheckbox = findViewById(R.id.hideImageCheckbox);
        saveParametersButton = findViewById(R.id.saveParametersButton);
        loadParametersButton = findViewById(R.id.loadParametersButton);
        switchCameraButton = findViewById(R.id.switchCameraButton);
        captureButton = findViewById(R.id.captureButton);

        scaleGestureDetector = new ScaleGestureDetector(this, new ScaleGestureDetector.SimpleOnScaleGestureListener() {
            @Override
            public boolean onScale(ScaleGestureDetector detector) {
                scaleFactor *= detector.getScaleFactor();
                scaleFactor = Math.max(0.1f, Math.min(scaleFactor, 5.0f));
                matrix.postScale(detector.getScaleFactor(), detector.getScaleFactor(), detector.getFocusX(), detector.getFocusY());
                applyTransformations();
                return true;
            }
        });

        imageView.setOnTouchListener((v, event) -> {
            scaleGestureDetector.onTouchEvent(event);
            switch (event.getAction()) {
                case MotionEvent.ACTION_DOWN:
                    lastTouchX = event.getX();
                    lastTouchY = event.getY();
                    isDragging = true;
                    break;
                case MotionEvent.ACTION_MOVE:
                    if (isDragging) {
                        float dx = event.getX() - lastTouchX;
                        float dy = event.getY() - lastTouchY;
                        matrix.postTranslate(dx, dy);
                        applyTransformations();
                        lastTouchX = event.getX();
                        lastTouchY = event.getY();
                    }
                    break;
                case MotionEvent.ACTION_UP:
                case MotionEvent.ACTION_CANCEL:
                    isDragging = false;
                    break;
            }
            return true;
        });

        cameraSurfaceView.getHolder().addCallback(new SurfaceHolder.Callback() {
            @Override
            public void surfaceCreated(SurfaceHolder holder) {
                Log.d(TAG, "Surface created");
                isSurfaceAvailable = true;
                if (isCameraPendingOpen && !isCameraOpen) {
                    openCamera();
                    isCameraPendingOpen = false;
                }
            }

            @Override
            public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
                Log.d(TAG, "Surface changed: " + width + "x" + height);
                adjustSurfaceViewAspectRatioWithCropping(width, height);
                if (cameraDevice != null && isSurfaceAvailable) {
                    closeCameraPreviewSession();
                    previewSize = chooseOptimalPreviewSize(getPreviewSizes(), width, height);
                    createCameraPreviewSession();
                }
            }

            @Override
            public void surfaceDestroyed(SurfaceHolder holder) {
                Log.d(TAG, "Surface destroyed");
                isSurfaceAvailable = false;
                closeCamera();
            }
        });

        transparencySeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
            @Override
            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
                setImageAlpha(progress);
            }

            @Override
            public void onStartTrackingTouch(SeekBar seekBar) {}

            @Override
            public void onStopTrackingTouch(SeekBar seekBar) {}
        });

        pickImageButton.setOnClickListener(v -> pickImage());

        pencilModeSwitch.setOnCheckedChangeListener((buttonView, isChecked) -> {
            isPencilMode = isChecked;
            layerSelectButton.setVisibility(isChecked ? View.VISIBLE : View.GONE);
            if (isPencilMode) {
                processPencilEffect();
            }
            updateImageDisplay();
        });

        layerSelectButton.setOnClickListener(v -> showLayerSelectionDialog());

        controlsVisibilityCheckbox.setOnCheckedChangeListener((buttonView, isChecked) -> {
            int visibility = isChecked ? View.VISIBLE : View.GONE;
            transparencySeekBar.setVisibility(visibility);
            pickImageButton.setVisibility(visibility);
            pencilModeSwitch.setVisibility(visibility);
            layerSelectButton.setVisibility(isPencilMode && isChecked ? View.VISIBLE : View.GONE);
            hideImageCheckbox.setVisibility(visibility);
            saveParametersButton.setVisibility(visibility);
            loadParametersButton.setVisibility(visibility);
            switchCameraButton.setVisibility(visibility);
            captureButton.setVisibility(visibility);
        });

        hideImageCheckbox.setOnCheckedChangeListener((buttonView, isChecked) -> {
            isImageVisible = !isChecked;
            updateImageDisplay();
        });

        saveParametersButton.setOnClickListener(v -> saveParameters());

        loadParametersButton.setOnClickListener(v -> loadParameters());

        switchCameraButton.setOnClickListener(v -> switchCamera());

        captureButton.setOnClickListener(v -> captureImage());

        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.CAMERA}, REQUEST_CAMERA_PERMISSION);
        } else {
            isCameraPendingOpen = true;
        }

        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED ||
                ActivityCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE}, REQUEST_STORAGE_PERMISSION);
        }

        CameraManager manager = (CameraManager) getSystemService(CAMERA_SERVICE);
        try {
            cameraIds = manager.getCameraIdList();
            if (cameraIds.length > 0) {
                cameraId = cameraIds[0];
            }
        } catch (CameraAccessException e) {
            Log.e(TAG, "Error accessing camera list", e);
            Toast.makeText(this, "Cannot access cameras", Toast.LENGTH_LONG).show();
        }

        layerVisibility = new boolean[20];
        Arrays.fill(layerVisibility, true);
    }

    private void adjustSurfaceViewAspectRatioWithCropping(int width, int height) {
        if (previewSize == null) {
            Log.e(TAG, "Preview size is null, cannot adjust aspect ratio");
            return;
        }

        float previewRatio = (float) previewSize.getWidth() / previewSize.getHeight();
        float viewRatio = (float) width / height;

        cameraSurfaceView.setScaleX(1.0f);
        cameraSurfaceView.setScaleY(1.0f);

        float scaleX, scaleY;
        if (previewRatio > viewRatio) {
            scaleY = 1.0f;
            scaleX = previewRatio / viewRatio;
        } else {
            scaleX = 1.0f;
            scaleY = viewRatio / previewRatio;
        }

        cameraSurfaceView.setScaleX(scaleX);
        cameraSurfaceView.setScaleY(scaleY);

        cameraSurfaceView.setPivotX(width / 2f);
        cameraSurfaceView.setPivotY(height / 2f);

        ViewGroup.LayoutParams params = cameraSurfaceView.getLayoutParams();
        params.width = width;
        params.height = height;
        cameraSurfaceView.setLayoutParams(params);

        cameraSurfaceView.requestLayout();
        Log.d(TAG, "Adjusted SurfaceView: width=" + width + ", height=" + height +
                ", previewRatio=" + previewRatio + ", scaleX=" + scaleX + ", scaleY=" + scaleY);
    }

    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
        if (requestCode == REQUEST_CAMERA_PERMISSION) {
            if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                if (isSurfaceAvailable && !isCameraOpen) {
                    openCamera();
                } else {
                    isCameraPendingOpen = true;
                }
            } else {
                Toast.makeText(this, "Camera permission is required", Toast.LENGTH_LONG).show();
                finish();
            }
        } else if (requestCode == REQUEST_STORAGE_PERMISSION) {
            if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                // Permission granted
            } else {
                Toast.makeText(this, "Storage permission is required", Toast.LENGTH_LONG).show();
            }
        }
    }

    private void startBackgroundThread() {
        if (backgroundThread == null) {
            backgroundThread = new HandlerThread("CameraBackground");
            backgroundThread.start();
            backgroundHandler = new Handler(backgroundThread.getLooper());
        }
    }

    private void stopBackgroundThread() {
        if (backgroundThread != null) {
            backgroundThread.quitSafely();
            try {
                backgroundThread.join();
                backgroundThread = null;
                backgroundHandler = null;
            } catch (InterruptedException e) {
                Log.e(TAG, "Error stopping background thread", e);
            }
        }
    }

    private void openCamera() {
        if (!isSurfaceAvailable || isCameraOpen) {
            Log.d(TAG, "Surface not available or camera already open, setting pending open");
            isCameraPendingOpen = true;
            return;
        }

        startBackgroundThread();
        CameraManager manager = (CameraManager) getSystemService(CAMERA_SERVICE);
        try {
            if (cameraId == null) {
                cameraId = manager.getCameraIdList()[0];
            }
            CameraCharacteristics characteristics = manager.getCameraCharacteristics(cameraId);
            Size[] previewSizes = characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP)
                    .getOutputSizes(SurfaceHolder.class);
            previewSize = chooseOptimalPreviewSize(previewSizes, cameraSurfaceView.getWidth(), cameraSurfaceView.getHeight());

            imageReader = ImageReader.newInstance(CAPTURE_WIDTH, CAPTURE_HEIGHT, android.graphics.ImageFormat.JPEG, 2);
            imageReader.setOnImageAvailableListener(reader -> {
                Image image = reader.acquireLatestImage();
                if (image != null) {
                    Bitmap bitmap = imageToBitmap(image);
                    image.close();
                    if (bitmap != null) {
                        processCapturedImage(bitmap);
                    }
                }
            }, backgroundHandler);

            if (ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {
                return;
            }
            synchronized (cameraOpenCloseLock) {
                isCameraOpen = true;
                manager.openCamera(cameraId, new CameraDevice.StateCallback() {
                    @Override
                    public void onOpened(@NonNull CameraDevice camera) {
                        cameraDevice = camera;
                        if (isSurfaceAvailable) {
                            createCameraPreviewSession();
                        } else {
                            Log.d(TAG, "Surface not available after camera opened, closing camera");
                            closeCamera();
                        }
                        synchronized (cameraOpenCloseLock) {
                            cameraOpenCloseLock.notify();
                        }
                    }

                    @Override
                    public void onDisconnected(@NonNull CameraDevice camera) {
                        synchronized (cameraOpenCloseLock) {
                            cameraOpenCloseLock.notify();
                        }
                        camera.close();
                        cameraDevice = null;
                        isCameraOpen = false;
                    }

                    @Override
                    public void onError(@NonNull CameraDevice camera, int error) {
                        synchronized (cameraOpenCloseLock) {
                            cameraOpenCloseLock.notify();
                        }
                        camera.close();
                        cameraDevice = null;
                        isCameraOpen = false;
                        Toast.makeText(MainActivity.this, "Camera error: " + error, Toast.LENGTH_LONG).show();
                    }
                }, backgroundHandler);
            }
        } catch (CameraAccessException e) {
            Log.e(TAG, "Cannot access camera", e);
            Toast.makeText(this, "Cannot access camera", Toast.LENGTH_LONG).show();
            isCameraOpen = false;
        }
    }

    private Size[] getPreviewSizes() {
        try {
            CameraManager manager = (CameraManager) getSystemService(CAMERA_SERVICE);
            CameraCharacteristics characteristics = manager.getCameraCharacteristics(cameraId);
            return characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP)
                    .getOutputSizes(SurfaceHolder.class);
        } catch (CameraAccessException e) {
            Log.e(TAG, "Error getting preview sizes", e);
            return new Size[]{new Size(1280, 720)};
        }
    }

    private Size chooseOptimalPreviewSize(Size[] choices, int viewWidth, int viewHeight) {
        if (choices == null || choices.length == 0) {
            Log.e(TAG, "No preview sizes available, using default");
            return new Size(1280, 720);
        }

        double targetRatio = (viewWidth > 0 && viewHeight > 0) ? (double) viewWidth / viewHeight : 4.0 / 3.0;

        Size optimalSize = null;
        double minDiff = Double.MAX_VALUE;
        int maxArea = 0;

        for (Size size : choices) {
            double ratio = (double) size.getWidth() / size.getHeight();
            int area = size.getWidth() * size.getHeight();
            double ratioDiff = Math.abs(ratio - targetRatio);
            if (ratioDiff < minDiff || (ratioDiff == minDiff && area > maxArea)) {
                optimalSize = size;
                minDiff = ratioDiff;
                maxArea = area;
            }
        }

        if (optimalSize == null) {
            optimalSize = choices[0];
        }

        Log.d(TAG, "Chosen preview size: " + optimalSize.getWidth() + "x" + optimalSize.getHeight() +
                ", targetRatio=" + targetRatio);
        return optimalSize;
    }

    private void createCameraPreviewSession() {
        if (!isSurfaceAvailable || cameraDevice == null || !isCameraOpen) {
            Log.d(TAG, "Cannot create preview session: Surface not available, cameraDevice is null, or camera is closed");
            return;
        }

        try {
            SurfaceHolder holder = cameraSurfaceView.getHolder();
            Surface surface = holder.getSurface();
            if (!surface.isValid()) {
                Log.d(TAG, "Surface is not valid, aborting preview session creation");
                return;
            }

            previewRequestBuilder = cameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
            previewRequestBuilder.addTarget(surface);

            List<Surface> surfaces = new ArrayList<>();
            surfaces.add(surface);
            surfaces.add(imageReader.getSurface());

            cameraDevice.createCaptureSession(surfaces, new CameraCaptureSession.StateCallback() {
                @Override
                public void onConfigured(@NonNull CameraCaptureSession session) {
                    if (cameraDevice == null || !isSurfaceAvailable || !isCameraOpen) {
                        Log.d(TAG, "Camera device closed, surface not available, or camera not open during session configuration");
                        session.close();
                        return;
                    }
                    cameraCaptureSession = session;
                    try {
                        previewRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);
                        cameraCaptureSession.setRepeatingRequest(previewRequestBuilder.build(), null, backgroundHandler);
                        Log.d(TAG, "Camera preview session started");
                    } catch (CameraAccessException e) {
                        Log.e(TAG, "Error setting up camera preview", e);
                    } catch (IllegalStateException e) {
                        Log.e(TAG, "Session already closed during setRepeatingRequest", e);
                    }
                }

                @Override
                public void onConfigureFailed(@NonNull CameraCaptureSession session) {
                    Toast.makeText(MainActivity.this, "Failed to configure camera preview", Toast.LENGTH_LONG).show();
                }
            }, backgroundHandler);
        } catch (CameraAccessException e) {
            Log.e(TAG, "Error creating camera preview session", e);
        }
    }

    private void closeCameraPreviewSession() {
        if (cameraCaptureSession != null) {
            cameraCaptureSession.close();
            cameraCaptureSession = null;
        }
    }

    private void closeCamera() {
        synchronized (cameraOpenCloseLock) {
            closeCameraPreviewSession();
            if (cameraDevice != null) {
                cameraDevice.close();
                cameraDevice = null;
            }
            if (imageReader != null) {
                imageReader.close();
                imageReader = null;
            }
            isCameraOpen = false;
        }
        stopBackgroundThread();
    }

    private void switchCamera() {
        CameraManager manager = (CameraManager) getSystemService(CAMERA_SERVICE);
        try {
            closeCamera();
            currentCameraIndex = (currentCameraIndex + 1) % cameraIds.length;
            cameraId = cameraIds[currentCameraIndex];
            if (isSurfaceAvailable && !isCameraOpen) {
                openCamera();
            } else {
                isCameraPendingOpen = true;
            }
        } catch (Exception e) {
            Log.e(TAG, "Error switching camera", e);
            Toast.makeText(this, "Error switching camera", Toast.LENGTH_LONG).show();
        }
    }

    private void captureImage() {
        if (cameraDevice == null || cameraCaptureSession == null) {
            Log.e(TAG, "Cannot capture image: camera not initialized");
            return;
        }

        try {
            CaptureRequest.Builder captureBuilder = cameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);
            captureBuilder.addTarget(imageReader.getSurface());
            captureBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);

            cameraCaptureSession.capture(captureBuilder.build(), new CameraCaptureSession.CaptureCallback() {
                @Override
                public void onCaptureCompleted(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull TotalCaptureResult result) {
                    Log.d(TAG, "Image captured successfully");
                }
            }, backgroundHandler);
        } catch (CameraAccessException e) {
            Log.e(TAG, "Error capturing image", e);
            Toast.makeText(this, "Error capturing image", Toast.LENGTH_LONG).show();
        }
    }

    private Bitmap imageToBitmap(Image image) {
        ByteBuffer buffer = image.getPlanes()[0].getBuffer();
        byte[] bytes = new byte[buffer.remaining()];
        buffer.get(bytes);
        return BitmapFactory.decodeByteArray(bytes, 0, bytes.length);
    }

    private void processCapturedImage(Bitmap bitmap) {
        // Упрощённая обработка без OpenCV: просто сохраняем изображение
        runOnUiThread(() -> {
            if (originalBitmap != null && !originalBitmap.isRecycled()) {
                originalBitmap.recycle();
            }
            originalBitmap = bitmap.copy(Bitmap.Config.ARGB_8888, true);
            resetTransformationsAndFit();
            updateImageDisplay();
        });
    }

    private void pickImage() {
        Intent intent = new Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI);
        startActivityForResult(intent, PICK_IMAGE_REQUEST);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if (requestCode == PICK_IMAGE_REQUEST && resultCode == RESULT_OK && data != null) {
            Uri imageUri = data.getData();
            try {
                if (originalBitmap != null && !originalBitmap.isRecycled()) {
                    originalBitmap.recycle();
                }
                originalBitmap = MediaStore.Images.Media.getBitmap(getContentResolver(), imageUri);
                resetTransformationsAndFit();
                layerVisibility = new boolean[20];
                Arrays.fill(layerVisibility, true);
                if (isPencilMode) {
                    processPencilEffect();
                }
                updateImageDisplay();
            } catch (IOException e) {
                Log.e(TAG, "Error loading image", e);
                Toast.makeText(this, "Error loading image", Toast.LENGTH_LONG).show();
            }
        }
    }

    private void resetTransformationsAndFit() {
        if (originalBitmap == null || imageView.getWidth() == 0 || imageView.getHeight() == 0) {
            matrix.reset();
            scaleFactor = 1.0f;
            rotationAngle = 0.0f;
            imageView.setImageMatrix(matrix);
            return;
        }

        matrix.reset();

        float viewWidth = imageView.getWidth();
        float viewHeight = imageView.getHeight();
        float bmpWidth = originalBitmap.getWidth();
        float bmpHeight = originalBitmap.getHeight();

        float scaleX = viewWidth / bmpWidth;
        float scaleY = viewHeight / bmpHeight;
        float initialScale = Math.min(scaleX, scaleY);

        float scaledBmpWidth = bmpWidth * initialScale;
        float scaledBmpHeight = bmpHeight * initialScale;
        float initialTranslateX = (viewWidth - scaledBmpWidth) / 2f;
        float initialTranslateY = (viewHeight - scaledBmpHeight) / 2f;

        matrix.postScale(initialScale, initialScale);
        matrix.postTranslate(initialTranslateX, initialTranslateY);

        imageView.post(() -> {
            imageView.setImageMatrix(matrix);
            imageView.invalidate();
            scaleFactor = initialScale;
            rotationAngle = 0.0f;
        });
    }

    private void applyTransformations() {
        imageView.setImageMatrix(matrix);
        imageView.invalidate();
        Log.d(TAG, "Transformations applied: scale=" + scaleFactor);
    }

    private void setImageAlpha(int progress) {
        float alpha = progress / 100.0f;
        imageView.setAlpha(alpha);
        imageView.invalidate();
        Log.d(TAG, "Image alpha set to: " + alpha);
    }

    private void processPencilEffect() {
        Log.d(TAG, "Processing pencil effect");
        if (originalBitmap == null) {
            Log.d(TAG, "Original bitmap is null, cannot process pencil effect");
            return;
        }

        if (pencilBitmap != null && !pencilBitmap.isRecycled()) {
            pencilBitmap.recycle();
            pencilBitmap = null;
        }
        if (layerBitmaps != null) {
            for (Bitmap layer : layerBitmaps) {
                if (layer != null && !layer.isRecycled()) {
                    layer.recycle();
                }
            }
            layerBitmaps = null;
        }

        try {
            pencilBitmap = Bitmap.createBitmap(originalBitmap.getWidth(), originalBitmap.getHeight(), Bitmap.Config.ARGB_8888);
            if (pencilBitmap == null) {
                Log.e(TAG, "Failed to create pencilBitmap");
                return;
            }
            Canvas canvas = new Canvas(pencilBitmap);
            Paint paint = new Paint();
            ColorMatrix colorMatrix = new ColorMatrix();
            colorMatrix.setSaturation(0); // Преобразование в чёрно-белое
            ColorMatrixColorFilter filter = new ColorMatrixColorFilter(colorMatrix);
            paint.setColorFilter(filter);
            canvas.drawBitmap(originalBitmap, 0, 0, paint);

            layerBitmaps = new Bitmap[20];
            for (int i = 0; i < 20; i++) {
                layerBitmaps[i] = Bitmap.createBitmap(originalBitmap.getWidth(), originalBitmap.getHeight(), Bitmap.Config.ARGB_8888);
                if (layerBitmaps[i] == null) {
                    Log.e(TAG, "Failed to create layerBitmap[" + i + "]");
                    return;
                }
                layerBitmaps[i].eraseColor(Color.TRANSPARENT);
            }

            int[] pixels = new int[originalBitmap.getWidth() * originalBitmap.getHeight()];
            pencilBitmap.getPixels(pixels, 0, originalBitmap.getWidth(), 0, 0, originalBitmap.getWidth(), originalBitmap.getHeight());

            for (int i = 0; i < pixels.length; i++) {
                int gray = Color.red(pixels[i]); // Простое преобразование в градации серого
                int layerIndex = getLayerIndex(gray);
                if (layerIndex >= 0 && layerIndex < 20 && layerBitmaps[layerIndex] != null) {
                    layerBitmaps[layerIndex].setPixel(i % originalBitmap.getWidth(), i / originalBitmap.getWidth(), pixels[i]);
                }
            }
            Log.d(TAG, "Pencil effect processed successfully");
        } catch (OutOfMemoryError e) {
            Log.e(TAG, "OutOfMemoryError in processPencilEffect", e);
            Toast.makeText(this, "Not enough memory for pencil effect", Toast.LENGTH_LONG).show();
            pencilBitmap = null;
            layerBitmaps = null;
        }
    }

    private int getLayerIndex(int grayValue) {
        return grayValue / (256 / 20);
    }

    private void updateImageDisplay() {
        Log.d(TAG, "updateImageDisplay: isPencilMode=" + isPencilMode + ", isImageVisible=" + isImageVisible);
        if (originalBitmap == null || !isImageVisible) {
            Log.d(TAG, "updateImageDisplay: originalBitmap is null or image is not visible");
            imageView.setImageBitmap(null);
            imageView.setVisibility(View.INVISIBLE);
            imageView.invalidate();
            return;
        }

        if (isPencilMode) {
            Log.d(TAG, "updateImageDisplay: Processing pencil mode");
            if (pencilBitmap == null || layerBitmaps == null) {
                processPencilEffect();
            }

            if (pencilBitmap == null || layerBitmaps == null) {
                Log.d(TAG, "updateImageDisplay: pencilBitmap or layerBitmaps is null");
                imageView.setImageBitmap(null);
                imageView.setVisibility(View.INVISIBLE);
                imageView.invalidate();
                return;
            }

            Bitmap resultBitmap = Bitmap.createBitmap(originalBitmap.getWidth(), originalBitmap.getHeight(), Bitmap.Config.ARGB_8888);
            if (resultBitmap == null) {
                Log.d(TAG, "updateImageDisplay: Failed to create resultBitmap");
                imageView.setImageBitmap(null);
                imageView.setVisibility(View.INVISIBLE);
                imageView.invalidate();
                return;
            }
            Canvas canvas = new Canvas(resultBitmap);
            canvas.drawColor(Color.TRANSPARENT);

            for (int i = 0; i < layerBitmaps.length; i++) {
                if (layerVisibility[i] && layerBitmaps[i] != null && !layerBitmaps[i].isRecycled()) {
                    canvas.drawBitmap(layerBitmaps[i], 0, 0, null);
                }
            }

            imageView.setImageBitmap(resultBitmap);
            setImageAlpha(transparencySeekBar.getProgress());
            imageView.setVisibility(View.VISIBLE);
            imageView.post(() -> {
                imageView.setImageMatrix(matrix);
                imageView.invalidate();
            });
            Log.d(TAG, "updateImageDisplay: Pencil mode applied");
        } else {
            Log.d(TAG, "updateImageDisplay: Displaying original bitmap");
            imageView.setImageBitmap(originalBitmap);
            setImageAlpha(transparencySeekBar.getProgress());
            imageView.setVisibility(View.VISIBLE);
            imageView.post(() -> {
                imageView.setImageMatrix(matrix);
                imageView.invalidate();
            });
            Log.d(TAG, "updateImageDisplay: Original bitmap displayed");
        }
    }

    private void showLayerSelectionDialog() {
        Dialog dialog = new Dialog(this);
        dialog.setContentView(R.layout.dialog_layer_selection);
        dialog.setTitle(R.string.layer_selection_title);

        RecyclerView recyclerView = dialog.findViewById(R.id.layerRecyclerView);
        recyclerView.setLayoutManager(new LinearLayoutManager(this));
        LayerAdapter adapter = new LayerAdapter(PENCIL_HARDNESS, layerVisibility, this);
        recyclerView.setAdapter(adapter);

        dialog.show();
    }

    @Override
    public void onLayerVisibilityChanged(int position, boolean isVisible) {
        layerVisibility[position] = isVisible;
        updateImageDisplay();
    }

    private void saveParameters() {
        try {
            File file = new File(getFilesDir(), "parameters.dat");
            FileOutputStream fos = new FileOutputStream(file);
            fos.write(Float.toString(scaleFactor).getBytes());
            fos.write("\n".getBytes());
            fos.write(Float.toString(rotationAngle).getBytes());
            fos.write("\n".getBytes());
            float[] matrixValues = new float[9];
            matrix.getValues(matrixValues);
            for (float value : matrixValues) {
                fos.write(Float.toString(value).getBytes());
                fos.write(" ".getBytes());
            }
            fos.write("\n".getBytes());
            fos.write(String.valueOf(isPencilMode).getBytes());
            fos.write("\n".getBytes());
            for (boolean visible : layerVisibility) {
                fos.write(String.valueOf(visible).getBytes());
                fos.write(" ".getBytes());
            }
            fos.close();
            Toast.makeText(this, "Parameters saved", Toast.LENGTH_SHORT).show();
        } catch (IOException e) {
            Log.e(TAG, "Error saving parameters", e);
            Toast.makeText(this, "Error saving parameters", Toast.LENGTH_LONG).show();
        }
    }

    private void loadParameters() {
        try {
            File file = new File(getFilesDir(), "parameters.dat");
            if (!file.exists()) {
                Toast.makeText(this, "No saved parameters found", Toast.LENGTH_SHORT).show();
                return;
            }
            FileInputStream fis = new FileInputStream(file);
            byte[] buffer = new byte[(int) file.length()];
            fis.read(buffer);
            fis.close();
            String[] lines = new String(buffer).split("\n");
            if (lines.length < 4) {
                Toast.makeText(this, "Invalid parameters file", Toast.LENGTH_LONG).show();
                return;
            }
            scaleFactor = Float.parseFloat(lines[0]);
            rotationAngle = Float.parseFloat(lines[1]);
            String[] matrixValues = lines[2].split(" ");
            float[] values = new float[9];
            for (int i = 0; i < 9; i++) {
                values[i] = Float.parseFloat(matrixValues[i]);
            }
            matrix.setValues(values);
            isPencilMode = Boolean.parseBoolean(lines[3]);
            pencilModeSwitch.setChecked(isPencilMode);
            String[] visibilityValues = lines[4].split(" ");
            for (int i = 0; i < layerVisibility.length; i++) {
                layerVisibility[i] = Boolean.parseBoolean(visibilityValues[i]);
            }
            applyTransformations();
            updateImageDisplay();
            Toast.makeText(this, "Parameters loaded", Toast.LENGTH_SHORT).show();
        } catch (IOException | NumberFormatException e) {
            Log.e(TAG, "Error loading parameters", e);
            Toast.makeText(this, "Error loading parameters", Toast.LENGTH_LONG).show();
        }
    }

    @Override
    protected void onResume() {
        super.onResume();
        if (isSurfaceAvailable && !isCameraOpen) {
            openCamera();
        } else {
            isCameraPendingOpen = true;
        }
    }

    @Override
    protected void onPause() {
        closeCamera();
        super.onPause();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        if (originalBitmap != null && !originalBitmap.isRecycled()) {
            originalBitmap.recycle();
            originalBitmap = null;
        }
        if (pencilBitmap != null && !pencilBitmap.isRecycled()) {
            pencilBitmap.recycle();
            pencilBitmap = null;
        }
        if (layerBitmaps != null) {
            for (Bitmap layer : layerBitmaps) {
                if (layer != null && !layer.isRecycled()) {
                    layer.recycle();
                }
            }
            layerBitmaps = null;
        }
    }

    @Override
    public void onConfigurationChanged(@NonNull Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        resetTransformationsAndFit();
        updateImageDisplay();
    }
}
EOL

# Очистка проекта
echo "Очистка проекта..."
./gradlew clean

# Пересборка проекта
echo "Пересборка проекта..."
./gradlew assembleDebug

echo "Исправление завершено!"


===== File: ./gradle-wrapper.properties =====
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.5-bin.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists


===== File: ./gradle.properties =====
android.useAndroidX=true


===== File: ./ic_launcher.png =====


===== File: ./.gitattributes =====
*.jpg filter=lfs diff=lfs merge=lfs -text
*.zip filter=lfs diff=lfs merge=lfs -text


===== File: ./.gitignore =====
# Gradle файлы
.gradle/
build/
*/build/

# Локальные настройки
local.properties

# Сгенерированные файлы
*.apk
*.ap_
*.aab

# Кэш и временные файлы
.idea/
*.iml

# Логи
*.log


===== File: ./README.md =====
# android-hello-world-app
File: app-debug.apk
# My Android App


===== File: ./.github/workflows/android-ci.yml =====
name: Android CI Build

on:
  push:
    branches: [ "main", "master" ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest # Важно: Запуск на x86-64 сервере GitHub

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
         # cache: gradle

      # Настройка Android SDK на сервере GitHub
      - name: Setup Android SDK
        run: |
          mkdir -p $HOME/android-sdk
          export ANDROID_HOME=$HOME/android-sdk
          # Скачиваем свежие Command-line tools
          wget https://dl.google.com/android/repository/commandlinetools-linux-11076708_latest.zip -O cmdline-tools.zip
          unzip cmdline-tools.zip -d $ANDROID_HOME/cmdline-tools
          mv $ANDROID_HOME/cmdline-tools/cmdline-tools $ANDROID_HOME/cmdline-tools/latest
          export PATH=$PATH:$ANDROID_HOME/cmdline-tools/latest/bin:$ANDROID_HOME/platform-tools
          echo "y" | sdkmanager --licenses > /dev/null || true # Принимаем лицензии
          # Устанавливаем платформу и Build Tools (версии, которые работают на x86-64)
          sdkmanager "platforms;android-34" "build-tools;34.0.0"
        shell: bash

      - name: Grant execute permission for gradlew
        run: chmod +x gradlew
        shell: bash

      # ДОБАВЛЕН НОВЫЙ ШАГ ОЧИСТКИ:
      - name: Clean Gradle project
        run: ./gradlew clean


      # Запуск сборки Debug APK
      - name: Build with Gradle
        run: ./gradlew assembleDebug
        shell: bash

      # Загрузка APK как артефакта
      - name: Upload Debug APK
        uses: actions/upload-artifact@v4
        with:
          name: app-debug-apk
          path: app/build/outputs/apk/debug/app-debug.apk


===== File: ./Build =====


===== File: ./app/build.gradle =====
// App-level build.gradle (app module)
plugins {
    id 'com.android.application'
}

android {
    namespace 'com.example.helloworld'
    compileSdk 33 // Изменяем на 33 для совместимости с AGP 8.1.0

    defaultConfig {
        applicationId "com.example.helloworld"
        minSdk 24
        targetSdk 28
        versionCode 1
        versionName "1.0"
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
}

dependencies {
    implementation 'androidx.appcompat:appcompat:1.6.1'
    implementation 'androidx.recyclerview:recyclerview:1.3.2'
    implementation 'androidx.constraintlayout:constraintlayout:2.1.4'
}


===== File: ./app/src/main/AndroidManifest.xml =====
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.AppCompat.Light.DarkActionBar">
        <activity
            android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>


===== File: ./app/src/main/java/com/example/helloworld/LayerAdapter.java =====
package com.example.helloworld;

import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.CheckBox; // Используем CheckBox
import android.widget.TextView;  // Используем TextView
import androidx.annotation.NonNull;
import androidx.recyclerview.widget.RecyclerView;

public class LayerAdapter extends RecyclerView.Adapter<LayerAdapter.ViewHolder> {

    private final String[] layers;
    private final boolean[] visibility;
    private final OnLayerVisibilityChangedListener listener;

    // Интерфейс для обратного вызова при изменении видимости слоя
    public interface OnLayerVisibilityChangedListener {
        void onLayerVisibilityChanged(int position, boolean isVisible);
    }

    // Конструктор адаптера
    public LayerAdapter(String[] layers, boolean[] visibility, OnLayerVisibilityChangedListener listener) {
        this.layers = layers;
        this.visibility = visibility;
        this.listener = listener;
    }

    // Создание нового ViewHolder (используем item_layer.xml)
    @NonNull
    @Override
    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        // Используем ваш кастомный макет item_layer.xml
        View view = LayoutInflater.from(parent.getContext())
                .inflate(R.layout.item_layer, parent, false); // *** ИЗМЕНЕНО ЗДЕСЬ ***
        return new ViewHolder(view);
    }

    // Привязка данных к ViewHolder
    @Override
    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
        // Устанавливаем текст слоя в TextView
        holder.layerText.setText(layers[position]); // *** ИЗМЕНЕНО ЗДЕСЬ ***

        // Сначала удаляем слушатель, чтобы он не сработал при установке состояния
        holder.layerCheckBox.setOnCheckedChangeListener(null);
        // Устанавливаем состояние CheckBox
        holder.layerCheckBox.setChecked(visibility[position]); // *** ИЗМЕНЕНО ЗДЕСЬ ***

        // Устанавливаем слушатель изменения состояния CheckBox
        holder.layerCheckBox.setOnCheckedChangeListener((buttonView, isChecked) -> { // *** ИЗМЕНЕНО ЗДЕСЬ ***
            // Обновляем массив видимости
            int currentPosition = holder.getAdapterPosition(); // Получаем актуальную позицию
             if (currentPosition != RecyclerView.NO_POSITION) { // Проверяем, что позиция валидна
                 visibility[currentPosition] = isChecked;
                 // Уведомляем MainActivity через интерфейс
                 if (listener != null) {
                     listener.onLayerVisibilityChanged(currentPosition, isChecked);
                 }
             }
        });
    }

    // Возвращаем общее количество элементов
    @Override
    public int getItemCount() {
        // Проверяем на null на всякий случай
        return (layers != null) ? layers.length : 0;
    }

    // Класс ViewHolder, хранящий ссылки на View одного элемента списка
    static class ViewHolder extends RecyclerView.ViewHolder {
        TextView layerText;     // *** ИЗМЕНЕНО ЗДЕСЬ *** Ссылка на TextView из item_layer.xml
        CheckBox layerCheckBox; // *** ИЗМЕНЕНО ЗДЕСЬ *** Ссылка на CheckBox из item_layer.xml

        ViewHolder(View itemView) {
            super(itemView);
            // Находим View по их ID из item_layer.xml
            layerText = itemView.findViewById(R.id.layerText);       // *** ИЗМЕНЕНО ЗДЕСЬ ***
            layerCheckBox = itemView.findViewById(R.id.layerCheckBox); // *** ИЗМЕНЕНО ЗДЕСЬ ***
        }
    }
}


===== File: ./app/src/main/java/com/example/helloworld/MainActivity.java =====
package com.example.helloworld;

import android.Manifest;
import android.app.Dialog;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.res.Configuration;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.ColorMatrix;
import android.graphics.ColorMatrixColorFilter;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.graphics.PointF;
import android.hardware.camera2.CameraAccessException;
import android.hardware.camera2.CameraCaptureSession;
import android.hardware.camera2.CameraCharacteristics;
import android.hardware.camera2.CameraDevice;
import android.hardware.camera2.CameraManager;
import android.hardware.camera2.CaptureRequest;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.HandlerThread;
import android.provider.MediaStore;
import android.util.Log;
import android.util.Size;
import android.view.MotionEvent;
import android.view.ScaleGestureDetector;
import android.view.Surface;
import android.view.SurfaceHolder;
import android.view.SurfaceView;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.ImageView;
import android.widget.SeekBar;
import android.widget.Switch;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.app.ActivityCompat;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.concurrent.TimeUnit;

public class MainActivity extends AppCompatActivity implements LayerAdapter.OnLayerVisibilityChangedListener {

    private static final String TAG = "MainActivity";
    private static final int REQUEST_CAMERA_PERMISSION = 100;
    private static final int REQUEST_STORAGE_PERMISSION = 101;
    private static final int PICK_IMAGE_REQUEST = 1;

    // --- UI Elements ---
    private SurfaceView cameraSurfaceView;
    private ImageView imageView;
    private SeekBar transparencySeekBar;
    private Button pickImageButton;
    private Switch pencilModeSwitch;
    private Button layerSelectButton;
    private CheckBox controlsVisibilityCheckbox;
    private CheckBox hideImageCheckbox;
    private Button saveParametersButton;
    private Button loadParametersButton;
    private Button switchCameraButton;

    // --- Camera ---
    private CameraDevice cameraDevice;
    private CameraCaptureSession cameraCaptureSession;
    private CaptureRequest.Builder previewRequestBuilder;
    private String cameraId;
    private Size previewSize;
    private HandlerThread backgroundThread;
    private Handler backgroundHandler;
    private final Object cameraOpenCloseLock = new Object();
    private volatile boolean isSurfaceAvailable = false;
    private volatile boolean isCameraOpen = false;
    private String[] cameraIds;
    private int currentCameraIndex = 0;

    // --- Image Manipulation ---
    private Bitmap originalBitmap;
    private Bitmap pencilBitmap; // Note: pencilBitmap is created but not directly used for display, layers are used
    private Bitmap[] layerBitmaps;
    private boolean[] layerVisibility;
    private Matrix matrix = new Matrix();
    private Matrix savedMatrix = new Matrix();
    private boolean isPencilMode = false;
    private boolean isImageVisible = true;

    // --- Gesture Detection ---
    private ScaleGestureDetector scaleGestureDetector;
    private static final int NONE = 0;
    private static final int DRAG = 1;
    private static final int ZOOM = 2;
    private int touchMode = NONE;
    private final PointF startPoint = new PointF();
    private final PointF midPoint = new PointF();
    private float initialAngle = 0f;

    // --- Pencil Mode Layers ---
    private static final String[] PENCIL_HARDNESS = {
            "9H", "8H", "7H", "6H", "5H", "4H", "3H", "2H", "H", "F",
            "HB", "B", "2B", "3B", "4B", "5B", "6B", "7B", "8B", "9B"
    };

    //==========================================================================
    // SurfaceHolder Callback (Defined before use in onCreate)
    //==========================================================================
    private final SurfaceHolder.Callback surfaceHolderCallback = new SurfaceHolder.Callback() {
        @Override
        public void surfaceCreated(SurfaceHolder holder) {
            Log.d(TAG, "Surface created");
            isSurfaceAvailable = true;
            if (ActivityCompat.checkSelfPermission(MainActivity.this, Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED) {
                openCamera();
            } else {
                checkPermissionsAndSetupCamera();
            }
        }
        @Override
        public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
            Log.d(TAG, "Surface changed: " + width + "x" + height);
            if (isCameraOpen && cameraDevice != null) {
                startCameraPreview(); // Restart preview if surface changes
            }
        }
        @Override
        public void surfaceDestroyed(SurfaceHolder holder) {
            Log.d(TAG, "Surface destroyed");
            isSurfaceAvailable = false;
            closeCamera();
        }
    };

    //==========================================================================
    // Activity Lifecycle & Initialization
    //==========================================================================

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initializeUI();
        scaleGestureDetector = new ScaleGestureDetector(this, new ScaleListener());
        imageView.setOnTouchListener(new TouchAndRotateListener());
        imageView.setScaleType(ImageView.ScaleType.MATRIX);
        cameraSurfaceView.getHolder().addCallback(surfaceHolderCallback); // Use the defined callback
        setupUIListeners();
        checkPermissionsAndSetupCamera();
        layerVisibility = new boolean[20]; Arrays.fill(layerVisibility, true);
        updateControlsVisibility(controlsVisibilityCheckbox.isChecked());
    }

    private void initializeUI() {
        cameraSurfaceView = findViewById(R.id.cameraSurfaceView); imageView = findViewById(R.id.imageView);
        transparencySeekBar = findViewById(R.id.transparencySeekBar); pickImageButton = findViewById(R.id.pickImageButton);
        pencilModeSwitch = findViewById(R.id.pencilModeSwitch); layerSelectButton = findViewById(R.id.layerSelectButton);
        controlsVisibilityCheckbox = findViewById(R.id.controlsVisibilityCheckbox); hideImageCheckbox = findViewById(R.id.hideImageCheckbox);
        saveParametersButton = findViewById(R.id.saveParametersButton); loadParametersButton = findViewById(R.id.loadParametersButton);
        switchCameraButton = findViewById(R.id.switchCameraButton);
    }

    private void setupUIListeners() {
        transparencySeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() { @Override public void onProgressChanged(SeekBar s, int p, boolean u) { setImageAlpha(p); } @Override public void onStartTrackingTouch(SeekBar s) {} @Override public void onStopTrackingTouch(SeekBar s) {} });
        pickImageButton.setOnClickListener(v -> pickImage());
        pencilModeSwitch.setOnCheckedChangeListener((v, isChecked) -> { isPencilMode = isChecked; layerSelectButton.setVisibility(isChecked ? View.VISIBLE : View.GONE); if (isPencilMode) processPencilEffect(); else recyclePencilBitmaps(); updateImageDisplay(); });
        layerSelectButton.setOnClickListener(v -> showLayerSelectionDialog());
        controlsVisibilityCheckbox.setOnCheckedChangeListener((v, c) -> updateControlsVisibility(c));
        hideImageCheckbox.setOnCheckedChangeListener((v, c) -> { isImageVisible = !c; updateImageDisplay(); });
        saveParametersButton.setOnClickListener(v -> saveParameters());
        loadParametersButton.setOnClickListener(v -> loadParameters());
        switchCameraButton.setOnClickListener(v -> switchCamera());
    }

    //==========================================================================
    // Gesture Handling
    //==========================================================================

    private class ScaleListener extends ScaleGestureDetector.SimpleOnScaleGestureListener {
        @Override public boolean onScaleBegin(@NonNull ScaleGestureDetector d) { return originalBitmap != null && !originalBitmap.isRecycled(); }
        @Override public boolean onScale(@NonNull ScaleGestureDetector d) { if (originalBitmap == null || !originalBitmap.isRecycled() || touchMode != ZOOM) return false; float scale = d.getScaleFactor(); matrix.postScale(scale, scale, d.getFocusX(), d.getFocusY()); applyTransformations(); return true; }
    }

    private class TouchAndRotateListener implements View.OnTouchListener {
        @Override public boolean onTouch(View v, MotionEvent event) {
            if (originalBitmap == null || originalBitmap.isRecycled()) return false;
            scaleGestureDetector.onTouchEvent(event);
            switch (event.getActionMasked()) {
                case MotionEvent.ACTION_DOWN: savedMatrix.set(matrix); startPoint.set(event.getX(), event.getY()); touchMode = DRAG; break;
                case MotionEvent.ACTION_POINTER_DOWN: if (event.getPointerCount() >= 2) { savedMatrix.set(matrix); midPoint(midPoint, event); initialAngle = rotation(event); touchMode = ZOOM; } break;
                case MotionEvent.ACTION_MOVE:
                    if (touchMode == DRAG && event.getPointerCount() == 1) { matrix.set(savedMatrix); matrix.postTranslate(event.getX() - startPoint.x, event.getY() - startPoint.y); applyTransformations(); }
                    else if (touchMode == ZOOM && event.getPointerCount() >= 2 && !scaleGestureDetector.isInProgress()) { // Rotate only if not scaling
                        float currentAngle = rotation(event); float deltaAngle = currentAngle - initialAngle;
                        matrix.postRotate(deltaAngle, midPoint.x, midPoint.y); applyTransformations();
                        savedMatrix.set(matrix); initialAngle = currentAngle; midPoint(midPoint, event); // Update state for next move increment
                    }
                    break;
                case MotionEvent.ACTION_POINTER_UP: savedMatrix.set(matrix); if (event.getPointerCount() <= 2) { touchMode = NONE; int remIdx = (event.getActionIndex() == 0) ? 1 : 0; if(event.getPointerCount() > remIdx) { startPoint.set(event.getX(remIdx), event.getY(remIdx)); touchMode = DRAG; } } break;
                case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: touchMode = NONE; break;
            }
            return true;
        }
        private void midPoint(PointF p, MotionEvent e) { if (e.getPointerCount() < 2) return; p.set((e.getX(0) + e.getX(1)) / 2f, (e.getY(0) + e.getY(1)) / 2f); }
        private float rotation(MotionEvent e) { if (e.getPointerCount() < 2) return 0f; return (float) Math.toDegrees(Math.atan2(e.getY(0) - e.getY(1), e.getX(0) - e.getX(1))); }
    }

    //==========================================================================
    // UI Updates & Display Logic
    //==========================================================================

    private void updateControlsVisibility(boolean show) { int v = show ? View.VISIBLE : View.GONE; transparencySeekBar.setVisibility(v); pickImageButton.setVisibility(v); pencilModeSwitch.setVisibility(v); layerSelectButton.setVisibility(show && isPencilMode ? View.VISIBLE : View.GONE); hideImageCheckbox.setVisibility(v); saveParametersButton.setVisibility(v); loadParametersButton.setVisibility(v); switchCameraButton.setVisibility(v); }
    private void applyTransformations() { if (imageView != null) { runOnUiThread(() -> imageView.setImageMatrix(matrix)); } }
    private void setImageAlpha(int p) { float a = Math.max(0.0f, Math.min(1.0f, p / 100.0f)); if (imageView != null) { runOnUiThread(() -> imageView.setAlpha(a)); } }
    private void updateImageDisplay() { /* ... код без изменений ... */ if (imageView == null) return; if (!isImageVisible || originalBitmap == null || originalBitmap.isRecycled()) { runOnUiThread(() -> { imageView.setImageBitmap(null); imageView.setVisibility(View.INVISIBLE); }); return; } new Thread(() -> { Bitmap bmp = null; boolean displayOrig = true; if (isPencilMode && layerBitmaps != null) { try { bmp = Bitmap.createBitmap(originalBitmap.getWidth(), originalBitmap.getHeight(), Bitmap.Config.ARGB_8888); Canvas c = new Canvas(bmp); c.drawColor(Color.TRANSPARENT); Paint p = new Paint(Paint.FILTER_BITMAP_FLAG); boolean drawn = false; for (int i = 0; i < layerBitmaps.length; i++) if (layerVisibility[i] && layerBitmaps[i] != null && !layerBitmaps[i].isRecycled()) { c.drawBitmap(layerBitmaps[i], 0, 0, p); drawn = true; } if (!drawn) { if (bmp != null && !bmp.isRecycled()) bmp.recycle(); bmp = Bitmap.createBitmap(1, 1, Bitmap.Config.ARGB_8888); bmp.eraseColor(Color.TRANSPARENT); } displayOrig = false; } catch (Exception e) { bmp = null; runOnUiThread(() -> Toast.makeText(this, "Layer Err", Toast.LENGTH_SHORT).show()); } } if (displayOrig) bmp = originalBitmap; final Bitmap finalBmp = bmp; final boolean finalOrig = displayOrig; runOnUiThread(() -> { if (imageView != null) { if (finalBmp != null && !finalBmp.isRecycled()) { imageView.setImageBitmap(finalBmp); imageView.setVisibility(View.VISIBLE); imageView.setImageMatrix(matrix); setImageAlpha(transparencySeekBar.getProgress()); imageView.invalidate(); } else { imageView.setImageBitmap(null); imageView.setVisibility(View.INVISIBLE); } } }); }).start(); }

    //==========================================================================
    // Permission Handling
    //==========================================================================

    private void checkPermissionsAndSetupCamera() { String[] ps = { Manifest.permission.CAMERA, Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE }; List<String> n = new ArrayList<>(); for (String p : ps) if (ActivityCompat.checkSelfPermission(this, p) != PackageManager.PERMISSION_GRANTED) n.add(p); if (!n.isEmpty()) ActivityCompat.requestPermissions(this, n.toArray(new String[0]), REQUEST_CAMERA_PERMISSION); else setupCamera(); }
    @Override public void onRequestPermissionsResult(int code, @NonNull String[] perms, @NonNull int[] results) { super.onRequestPermissionsResult(code, perms, results); boolean ok = results.length > 0; for (int r : results) if (r != PackageManager.PERMISSION_GRANTED) ok = false; if (ok) { setupCamera(); if (isSurfaceAvailable && !isCameraOpen) openCamera(); } else Toast.makeText(this, "Permissions required", Toast.LENGTH_LONG).show(); }

    //==========================================================================
    // Camera Setup & Control
    //==========================================================================

    private void setupCamera() { CameraManager m = (CameraManager) getSystemService(CAMERA_SERVICE); try { cameraIds = m.getCameraIdList(); if (cameraIds.length > 0) { String r = null; for (String id : cameraIds) { Integer f = m.getCameraCharacteristics(id).get(CameraCharacteristics.LENS_FACING); if (f != null && f == CameraCharacteristics.LENS_FACING_BACK) { r = id; break; } } cameraId = (r != null) ? r : cameraIds[0]; currentCameraIndex = Arrays.asList(cameraIds).indexOf(cameraId); } else cameraId = null; } catch (Exception e) { Log.e(TAG, "Cam setup err", e); } if (cameraId == null) Toast.makeText(this, "No cams", Toast.LENGTH_LONG).show(); }
    private void startBackgroundThread() { if (backgroundThread == null || !backgroundThread.isAlive()) { stopBackgroundThread(); backgroundThread = new HandlerThread("CameraBg"); backgroundThread.start(); backgroundHandler = new Handler(backgroundThread.getLooper()); } }
    private void stopBackgroundThread() { if (backgroundThread != null) { backgroundThread.quitSafely(); try { backgroundThread.join(500); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } backgroundThread = null; backgroundHandler = null; } }

    private void openCamera() {
        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) return;
        if (cameraId == null || !isSurfaceAvailable || isCameraOpen) return;
        startBackgroundThread(); if (backgroundHandler == null) return;
        CameraManager manager = (CameraManager) getSystemService(CAMERA_SERVICE);
        try {
             CameraCharacteristics ch = manager.getCameraCharacteristics(cameraId);
             previewSize = chooseOptimalPreviewSize(ch.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP).getOutputSizes(SurfaceHolder.class), cameraSurfaceView.getWidth(), cameraSurfaceView.getHeight());
             synchronized (cameraOpenCloseLock) { if (!isCameraOpen) { manager.openCamera(cameraId, cameraStateCallback, backgroundHandler); isCameraOpen = true; } }
        } catch (Exception e) { isCameraOpen = false; runOnUiThread(() -> Toast.makeText(this, "Open cam fail", Toast.LENGTH_SHORT).show()); Log.e(TAG, "Open cam err", e); }
    }

     private final CameraDevice.StateCallback cameraStateCallback = new CameraDevice.StateCallback() {
         @Override public void onOpened(@NonNull CameraDevice camera) { synchronized (cameraOpenCloseLock) { cameraDevice = camera; isCameraOpen = true; } startCameraPreview(); }
         @Override public void onDisconnected(@NonNull CameraDevice camera) { closeCamera(); }
         @Override public void onError(@NonNull CameraDevice camera, int error) { runOnUiThread(() -> Toast.makeText(MainActivity.this, "Cam Err: "+error, Toast.LENGTH_LONG).show()); closeCamera(); }
     };

    private Size[] getPreviewSizes() { if (cameraId == null) return new Size[]{new Size(1280, 720)}; try { return ((CameraManager) getSystemService(CAMERA_SERVICE)).getCameraCharacteristics(cameraId).get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP).getOutputSizes(SurfaceHolder.class); } catch (Exception e) { return new Size[]{new Size(1280, 720)}; } }
    private Size chooseOptimalPreviewSize(Size[] choices, int w, int h) { if (choices == null || choices.length == 0) return new Size(1280, 720); double ratio = (w > 0 && h > 0) ? (double) w / h : (16.0 / 9.0); Size opt = null; double diff = Double.MAX_VALUE; final int MAX_A = 1920 * 1080; List<Size> suit = new ArrayList<>(); for (Size s : choices) if ((long)s.getWidth() * s.getHeight() <= MAX_A) suit.add(s); if(suit.isEmpty()) return Collections.min(Arrays.asList(choices), Comparator.comparingLong(s -> (long)s.getWidth() * s.getHeight())); for (Size s : suit) { double r = (double) s.getWidth() / s.getHeight(); double d = Math.abs(r - ratio); if (d < diff) { diff = d; opt = s; } else if (d == diff && opt != null && (long)s.getWidth() * s.getHeight() > (long)opt.getWidth() * opt.getHeight()) opt = s; } if (opt == null) opt = Collections.max(suit, Comparator.comparingLong(s -> (long)s.getWidth() * s.getHeight())); Log.d(TAG, "Chosen preview size: " + opt); return opt; } // Added Log

    private void startCameraPreview() {
         synchronized (cameraOpenCloseLock) {
             if (cameraDevice == null || !isSurfaceAvailable || !isCameraOpen || backgroundHandler == null) {
                 Log.w(TAG, "Cannot start preview - conditions not met.");
                 return;
             }
             try {
                 closeCameraPreviewSession();
                 if (previewSize == null) {
                     previewSize = chooseOptimalPreviewSize(getPreviewSizes(), cameraSurfaceView.getWidth(), cameraSurfaceView.getHeight());
                     if (previewSize == null) { Log.e(TAG, "Failed to choose preview size!"); return; }
                 }

                 Surface surface = cameraSurfaceView.getHolder().getSurface();
                 if (!surface.isValid()) { Log.e(TAG, "Preview surface is invalid!"); return; }

                 // --- ВОЗВРАЩАЕМ УСТАНОВКУ РАЗМЕРА БУФЕРА ---
                 final Size finalSize = previewSize;
                 runOnUiThread(() -> {
                     SurfaceHolder holder = cameraSurfaceView.getHolder();
                     if (holder != null && holder.getSurface() != null && holder.getSurface().isValid()) {
                         try {
                             holder.setFixedSize(finalSize.getWidth(), finalSize.getHeight());
                             Log.d(TAG, "Set SurfaceHolder fixed size for preview: " + finalSize);
                         } catch (Exception e) { Log.e(TAG, "Error setting fixed size for SurfaceHolder", e); }
                     } else { Log.w(TAG, "SurfaceHolder or Surface invalid when setting fixed size."); }
                 });
                 // --- КОНЕЦ ВОЗВРАТА ---

                 previewRequestBuilder = cameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
                 previewRequestBuilder.addTarget(surface);
                 cameraDevice.createCaptureSession(Collections.singletonList(surface), new CameraCaptureSession.StateCallback() {
                     @Override public void onConfigured(@NonNull CameraCaptureSession session) { synchronized (cameraOpenCloseLock) { if (cameraDevice == null || !isCameraOpen) { session.close(); return; } cameraCaptureSession = session; try { previewRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE); cameraCaptureSession.setRepeatingRequest(previewRequestBuilder.build(), null, backgroundHandler); } catch (Exception e) { Log.e(TAG, "Preview repeat err", e); } } }
                     @Override public void onConfigureFailed(@NonNull CameraCaptureSession session) { runOnUiThread(() -> Toast.makeText(MainActivity.this, "Preview cfg fail", Toast.LENGTH_LONG).show()); }
                 }, backgroundHandler);
             } catch (Exception e) { runOnUiThread(() -> Toast.makeText(MainActivity.this, "Preview start err", Toast.LENGTH_SHORT).show()); Log.e(TAG, "Preview start exception", e); }
         }
     }

    private void closeCameraPreviewSession() { synchronized (cameraOpenCloseLock) { if (cameraCaptureSession != null) { try { cameraCaptureSession.close(); } catch (Exception e){} finally { cameraCaptureSession = null; } } } }
    private void closeCamera() { try { synchronized(cameraOpenCloseLock) { closeCameraPreviewSession(); if (cameraDevice != null) { cameraDevice.close(); cameraDevice = null; } isCameraOpen = false; } } catch(Exception e) { Log.e(TAG, "Cam close err", e); } finally { stopBackgroundThread(); } }
    private void switchCamera() { if (cameraIds == null || cameraIds.length < 2) { Toast.makeText(this, "1 cam", Toast.LENGTH_SHORT).show(); return; } closeCamera(); currentCameraIndex = (currentCameraIndex + 1) % cameraIds.length; cameraId = cameraIds[currentCameraIndex]; previewSize = null; openCamera(); }

    // --- Image Picking ---
    private void pickImage() { Intent i = new Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI); checkPermissionsAndSetupCamera(); try { startActivityForResult(i, PICK_IMAGE_REQUEST); } catch (Exception e) { Toast.makeText(this, "No gallery", Toast.LENGTH_SHORT).show(); } }
    @Override protected void onActivityResult(int req, int res, Intent data) { super.onActivityResult(req, res, data); if (req == PICK_IMAGE_REQUEST && res == RESULT_OK && data != null) { Uri uri = data.getData(); if (uri != null) loadImageFromUri(uri); else Toast.makeText(this, "No URI", Toast.LENGTH_SHORT).show(); } }
     private void loadImageFromUri(Uri uri) { try { new Thread(() -> { Bitmap bmp = null; try (InputStream is = getContentResolver().openInputStream(uri)) { BitmapFactory.Options opts = new BitmapFactory.Options(); opts.inSampleSize = 2; bmp = BitmapFactory.decodeStream(is, null, opts); } catch (Exception e) { runOnUiThread(()-> Toast.makeText(this, "Load err", Toast.LENGTH_SHORT).show()); } final Bitmap finalBmp = bmp; runOnUiThread(() -> { if (finalBmp != null) { recycleBitmaps(); originalBitmap = finalBmp; if (isPencilMode) { isPencilMode = false; pencilModeSwitch.setChecked(false); layerSelectButton.setVisibility(View.GONE); } layerVisibility = new boolean[20]; Arrays.fill(layerVisibility, true); resetTransformationsAndFit(); updateImageDisplay(); } else Toast.makeText(this, "Load fail", Toast.LENGTH_SHORT).show(); }); }).start(); } catch (Exception e) { Log.e(TAG, "Load thread start err", e); } }

    // --- Image Transformation & Display ---
    private void resetTransformationsAndFit() { matrix.reset(); if (originalBitmap == null || originalBitmap.isRecycled() || imageView.getWidth() == 0 || imageView.getHeight() == 0) { if (imageView != null) runOnUiThread(()-> imageView.setImageMatrix(matrix)); return; } final float vw = imageView.getWidth(), vh = imageView.getHeight(), bw = originalBitmap.getWidth(), bh = originalBitmap.getHeight(); float scale = Math.min(vw / bw, vh / bh); float dx = (vw - bw * scale) / 2f, dy = (vh - bh * scale) / 2f; matrix.setScale(scale, scale); matrix.postTranslate(dx, dy); Log.d(TAG, "Reset & fit. Scale: " + scale); applyTransformations(); }

    // --- Pencil Effect Logic ---
     private void processPencilEffect() { if (originalBitmap == null || originalBitmap.isRecycled()) { return; } new Thread(() -> { recyclePencilBitmaps(); Bitmap gray = null; Bitmap[] layers = new Bitmap[PENCIL_HARDNESS.length]; boolean ok = false; try { int w = originalBitmap.getWidth(), h = originalBitmap.getHeight(); gray = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888); Canvas cg = new Canvas(gray); Paint pg = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.FILTER_BITMAP_FLAG); ColorMatrix cm = new ColorMatrix(); cm.setSaturation(0); pg.setColorFilter(new ColorMatrixColorFilter(cm)); cg.drawBitmap(originalBitmap, 0, 0, pg); int[] pix = new int[w * h]; gray.getPixels(pix, 0, w, 0, 0, w, h); int[][] lpix = new int[layers.length][w * h]; for (int i = 0; i < layers.length; i++) Arrays.fill(lpix[i], Color.TRANSPARENT); for (int i = 0; i < pix.length; i++) { int layerIdx = getLayerIndex(Color.red(pix[i])); if (layerIdx >= 0 && layerIdx < layers.length) lpix[layerIdx][i] = pix[i]; } pix = null; gray.recycle(); gray = null; for (int i = 0; i < layers.length; i++) { layers[i] = Bitmap.createBitmap(lpix[i], w, h, Bitmap.Config.ARGB_8888); lpix[i] = null; } lpix = null; ok = true; } catch (OutOfMemoryError e) { if (gray != null && !gray.isRecycled()) gray.recycle(); for(Bitmap b : layers) if(b!=null && !b.isRecycled()) b.recycle(); runOnUiThread(() -> Toast.makeText(this, "OOM Pencil", Toast.LENGTH_LONG).show()); } catch (Exception e) { runOnUiThread(() -> Toast.makeText(this, "Pencil Err", Toast.LENGTH_SHORT).show()); } final boolean finalOk = ok; final Bitmap[] finalLayers = layers; runOnUiThread(() -> { if (finalOk) { pencilBitmap = null; layerBitmaps = finalLayers; } else { isPencilMode = false; pencilModeSwitch.setChecked(false); layerSelectButton.setVisibility(View.GONE); layerBitmaps = null; } updateImageDisplay(); }); }).start(); }
     private int getLayerIndex(int grayValue) { int numLayers = PENCIL_HARDNESS.length; if (numLayers <= 0) return -1; int rawIndex = (int) (((float)grayValue / 256.0f) * numLayers); rawIndex = Math.max(0, Math.min(rawIndex, numLayers - 1)); int invertedIndex = (numLayers - 1) - rawIndex; return invertedIndex; }
     private void recyclePencilBitmaps() { if (pencilBitmap != null && !pencilBitmap.isRecycled()) pencilBitmap.recycle(); pencilBitmap = null; if (layerBitmaps != null) { for (Bitmap b : layerBitmaps) if (b != null && !b.isRecycled()) b.recycle(); layerBitmaps = null; } }

    // --- Layer Selection Dialog ---
    private void showLayerSelectionDialog() { Dialog d = new Dialog(this); d.setContentView(R.layout.dialog_layer_selection); d.setTitle(R.string.layer_selection_title); RecyclerView rv = d.findViewById(R.id.layerRecyclerView); if (rv == null) return; rv.setLayoutManager(new LinearLayoutManager(this)); LayerAdapter a = new LayerAdapter(PENCIL_HARDNESS, layerVisibility, this); rv.setAdapter(a); d.show(); }
    @Override public void onLayerVisibilityChanged(int p, boolean isVisible) { if (p >= 0 && p < layerVisibility.length) { layerVisibility[p] = isVisible; updateImageDisplay(); } }

    // --- Save/Load Parameters ---
    private float getMatrixScale(Matrix mat) { float[] v = new float[9]; mat.getValues(v); float sx = v[Matrix.MSCALE_X], sy = v[Matrix.MSKEW_Y]; return (float) Math.sqrt(sx * sx + sy * sy); }
    private void saveParameters() { /* ... код без изменений ... */ try { File f = new File(getFilesDir(), "parameters.dat"); try (FileOutputStream fos = new FileOutputStream(f)) { float[] mv = new float[9]; matrix.getValues(mv); fos.write(("matrix=" + mv[0]+","+mv[1]+","+mv[2]+","+mv[3]+","+mv[4]+","+mv[5]+","+mv[6]+","+mv[7]+","+mv[8] + "\n").getBytes()); fos.write(("isPencilMode=" + isPencilMode + "\n").getBytes()); fos.write(("isImageVisible=" + isImageVisible + "\n").getBytes()); fos.write(("controlsVisible=" + controlsVisibilityCheckbox.isChecked() + "\n").getBytes()); fos.write(("transparency=" + transparencySeekBar.getProgress() + "\n").getBytes()); StringBuilder ls = new StringBuilder("layerVisibility="); for (int i = 0; i < layerVisibility.length; i++) { ls.append(layerVisibility[i]); if (i < layerVisibility.length - 1) ls.append(","); } fos.write((ls.toString() + "\n").getBytes()); Toast.makeText(this, "Saved", Toast.LENGTH_SHORT).show(); } } catch (IOException e) { Toast.makeText(this, "Save Err", Toast.LENGTH_LONG).show(); } }
    private void loadParameters() { /* ... код без изменений ... */ try { File f = new File(getFilesDir(), "parameters.dat"); if (!f.exists()) { Toast.makeText(this, "No params", Toast.LENGTH_SHORT).show(); return; } try (FileInputStream fis = new FileInputStream(f); java.util.Scanner sc = new java.util.Scanner(fis)) { boolean loadedPencil = isPencilMode; while (sc.hasNextLine()) { String l = sc.nextLine(); String[] p = l.split("=", 2); if (p.length != 2) continue; String k = p[0], v = p[1]; try { switch (k) { case "matrix": String[] mvs = v.split(","); if (mvs.length == 9) { float[] vals = new float[9]; for (int i = 0; i < 9; i++) vals[i] = Float.parseFloat(mvs[i]); matrix.setValues(vals); } break; case "isPencilMode": isPencilMode = Boolean.parseBoolean(v); break; case "isImageVisible": isImageVisible = Boolean.parseBoolean(v); break; case "controlsVisible": controlsVisibilityCheckbox.setChecked(Boolean.parseBoolean(v)); break; case "transparency": transparencySeekBar.setProgress(Integer.parseInt(v)); break; case "layerVisibility": String[] visVals = v.split(","); for (int i = 0; i < layerVisibility.length && i < visVals.length; i++) layerVisibility[i] = Boolean.parseBoolean(visVals[i]); break; } } catch (Exception e) { Log.w(TAG, "Parse err", e); } } pencilModeSwitch.setChecked(isPencilMode); hideImageCheckbox.setChecked(!isImageVisible); updateControlsVisibility(controlsVisibilityCheckbox.isChecked()); applyTransformations(); if (isPencilMode && originalBitmap != null) { if (!loadedPencil) processPencilEffect(); else updateImageDisplay(); } else updateImageDisplay(); Toast.makeText(this, "Loaded", Toast.LENGTH_SHORT).show(); } } catch (Exception e) { Toast.makeText(this, "Load Err", Toast.LENGTH_LONG).show(); } }

    // --- Activity Lifecycle ---
    @Override protected void onResume() { super.onResume(); startBackgroundThread(); if (isSurfaceAvailable && ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED) { if (!isCameraOpen) openCamera(); else startCameraPreview(); } }
    @Override protected void onPause() { closeCamera(); stopBackgroundThread(); super.onPause(); }
    @Override protected void onDestroy() { closeCamera(); recycleBitmaps(); super.onDestroy(); }
    private void recycleBitmaps() { if (originalBitmap != null && !originalBitmap.isRecycled()) originalBitmap.recycle(); originalBitmap = null; recyclePencilBitmaps(); }
    @Override public void onConfigurationChanged(@NonNull Configuration newConfig) { super.onConfigurationChanged(newConfig); imageView.postDelayed(this::resetTransformationsAndFit, 100); }

} // End MainActivity


===== File: ./app/src/main/res/layout/dialog_layer_selection.xml =====
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="16dp">

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/layerRecyclerView"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

</LinearLayout>


===== File: ./app/src/main/res/layout/item_layer.xml =====
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:padding="8dp">

    <TextView
        android:id="@+id/layerText"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:textSize="16sp" />

    <CheckBox
        android:id="@+id/layerCheckBox"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" />
</LinearLayout>


===== File: ./app/src/main/res/layout/activity_main.xml =====
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <SurfaceView
        android:id="@+id/cameraSurfaceView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_centerInParent="true" />

    <ImageView
        android:id="@+id/imageView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_centerInParent="true"
        android:scaleType="matrix" />

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_alignParentBottom="true"
        android:orientation="vertical"
        android:padding="10dp">

        <SeekBar
            android:id="@+id/transparencySeekBar"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:max="100"
            android:progress="100" />

        <Button
            android:id="@+id/pickImageButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/pick_image" />

        <Switch
            android:id="@+id/pencilModeSwitch"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/pencil_mode" />

        <Button
            android:id="@+id/layerSelectButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/select_layers"
            android:visibility="gone" />

        <CheckBox
            android:id="@+id/controlsVisibilityCheckbox"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/show_controls"
            android:checked="true" />

        <CheckBox
            android:id="@+id/hideImageCheckbox"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/hide_image" />

        <Button
            android:id="@+id/saveParametersButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/save_parameters" />

        <Button
            android:id="@+id/loadParametersButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/load_parameters" />

        <Button
            android:id="@+id/switchCameraButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/switch_camera" />

        <!-- Блок кнопки captureButton полностью удален -->

    </LinearLayout>

</RelativeLayout>


===== File: ./app/src/main/res/values/strings.xml =====
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">HelloWorld</string>
    <string name="layer_selection_title">Select Pencil Layers</string>
    <string name="pick_image">Pick Image</string>
    <string name="pencil_mode">Pencil Mode</string>
    <string name="select_layers">Select Layers</string>
    <string name="show_controls">Show Controls</string>
    <string name="hide_image">Hide Image</string>
    <string name="save_parameters">Save Parameters</string>
    <string name="load_parameters">Load Parameters</string>
    <string name="switch_camera">Switch Camera</string>
</resources>


===== File: ./app/src/main/res/values/themes.xml =====
<?xml version="1.0" encoding="utf-8"?>
<resources xmlns:tools="http://schemas.android.com/tools">
    <style name="Theme.HelloWorld" parent="Theme.AppCompat.Light.DarkActionBar">
        <item name="colorPrimary">@android:color/black</item>
        <item name="colorPrimaryDark">@android:color/black</item>
        <item name="colorAccent">@android:color/holo_blue_light</item>
    </style>
</resources>


===== File: ./app/src/main/res/xml/data_extraction_rules.xml =====
<?xml version="1.0" encoding="utf-8"?>
<data-extraction-rules>
    <cloud-backup>
        <include domain="file" />
    </cloud-backup>
</data-extraction-rules>


===== File: ./app/src/main/res/mipmap-hdpi/ic_launcher.png =====
PNG

   IHDR   H   H   o#!   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  {ܙ,   bKGD-   tIME(`   IDAT(c``   _   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`

===== File: ./app/src/main/res/mipmap-hdpi/ic_launcher_round.png =====
PNG

   IHDR   H   H   o#!   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  ?/O   bKGD-   tIME(`   IDAT(c``   _   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`

===== File: ./app/src/main/res/mipmap-mdpi/ic_launcher.png =====
PNG

   IHDR   0   0   mk   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  {ܙ,   bKGD-   tIME'N|   IDATc` P    %tEXtdate:create 2025-04-27T16:18:39+00:00s   %tEXtdate:modify 2025-04-27T16:18:39+00:00Aq    IENDB`

===== File: ./app/src/main/res/mipmap-mdpi/ic_launcher_round.png =====
PNG

   IHDR   0   0   mk   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  ?/O   bKGD-   tIME(`   IDATc` P    %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`

===== File: ./app/src/main/res/mipmap-xhdpi/ic_launcher.png =====
PNG

   IHDR   `   `   V{   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  {ܙ,   bKGD-   tIME(`   IDAT8c``	  t   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`

===== File: ./app/src/main/res/mipmap-xhdpi/ic_launcher_round.png =====
PNG

   IHDR   `   `   V{   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  ?/O   bKGD-   tIME(`   IDAT8c``	  t   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`

===== File: ./app/src/main/res/mipmap-xxhdpi/ic_launcher.png =====
PNG

   IHDR         ݈p   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  {ܙ,   bKGD-   tIME(`   IDATH1    Om   
 >4   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`

===== File: ./app/src/main/res/mipmap-xxhdpi/ic_launcher_round.png =====
PNG

   IHDR         ݈p   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  ?/O   bKGD-   tIME(`   IDATH1    Om   
 >4   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`

===== File: ./app/src/main/res/mipmap-xxxhdpi/ic_launcher.png =====
PNG

   IHDR         hD   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  {ܙ,   bKGD-   tIME(`   IDATX1    Om      R   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`

===== File: ./app/src/main/res/mipmap-xxxhdpi/ic_launcher_round.png =====
PNG

   IHDR         hD   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  ?/O   bKGD-   tIME)g{   IDATX1    Om      R   %tEXtdate:create 2025-04-27T16:18:41+00:00J6P   %tEXtdate:modify 2025-04-27T16:18:41+00:00;k    IENDB`

===== File: ./build.gradle =====
// Top-level build.gradle (project-level)
buildscript {
    repositories {
        google()
        mavenCentral()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:8.1.0'
    }
}

plugins {
    id 'org.jetbrains.kotlin.android' version '1.9.0' apply false
}

allprojects {
    // Repositories are managed in settings.gradle
}


===== File: ./file_list.txt =====
.
./.git
./.git/branches
./.git/description
./.git/hooks
./.git/hooks/commit-msg.sample
./.git/hooks/fsmonitor-watchman.sample
./.git/hooks/post-update.sample
./.git/hooks/pre-applypatch.sample
./.git/hooks/pre-commit.sample
./.git/hooks/pre-merge-commit.sample
./.git/hooks/pre-push.sample
./.git/hooks/pre-rebase.sample
./.git/hooks/pre-receive.sample
./.git/hooks/prepare-commit-msg.sample
./.git/hooks/push-to-checkout.sample
./.git/hooks/sendemail-validate.sample
./.git/hooks/update.sample
./.git/hooks/applypatch-msg.sample
./.git/info
./.git/info/exclude
./.git/refs
./.git/refs/heads
./.git/refs/heads/main
./.git/refs/tags
./.git/refs/remotes
./.git/refs/remotes/origin
./.git/refs/remotes/origin/HEAD
./.git/refs/remotes/origin/main
./.git/objects
./.git/objects/pack
./.git/objects/pack/pack-b552bc965c86426d18d4468a03710aeff01fcf1a.pack
./.git/objects/pack/pack-b552bc965c86426d18d4468a03710aeff01fcf1a.rev
./.git/objects/pack/pack-b552bc965c86426d18d4468a03710aeff01fcf1a.idx
./.git/objects/info
./.git/objects/74
./.git/objects/74/a2ab7af7428e5deea0a85178d42a2d60794416
./.git/objects/74/0428f4cbce811196316bf50ad1ae3e283ce12d
./.git/objects/35
./.git/objects/35/02acbb0ab2e6421b43ba33229b439deff64b38
./.git/objects/ec
./.git/objects/ec/9edd32fa19d464c076824fa3c35d12ce211106
./.git/objects/1b
./.git/objects/1b/c5213578f9f2c8f83657e564aac7dcff2a0e6e
./.git/objects/03
./.git/objects/03/e3e480dca3ccf31c8a998de46596663939a832
./.git/objects/7e
./.git/objects/7e/b421ea459868ebdf7457b7ace9d60ba4ec9ede
./.git/objects/c9
./.git/objects/c9/0c4e6d5c1e1ce6b60b040a90680b01417d0211
./.git/objects/52
./.git/objects/52/59c60c92b83aa9771befe444e3af8cfb2b53ac
./.git/objects/6b
./.git/objects/6b/7f28f2986f6ef83610cbfcfa04683a82db5dd9
./.git/objects/a4
./.git/objects/a4/b14ebddf30a160864b33e61ecdef91e84eb8e3
./.git/objects/81
./.git/objects/81/4fa7f53d565dfa1cc749e8c0215c2f9f8f50ab
./.git/objects/82
./.git/objects/82/aba5822afc8d8387671a2a68499bd9c6e77eec
./.git/objects/5b
./.git/objects/5b/367b361ebfb9f5992f352cdfabd3c10543ca81
./.git/objects/f5
./.git/objects/f5/41c5fc813146c5bc873f8c21ef9e055f2879a2
./.git/objects/9a
./.git/objects/9a/76d09f344b7bffd9bd29a470304d70c4afd2ec
./.git/objects/59
./.git/objects/59/4f0361409cd436f1d6616655598d7cc9927bab
./.git/objects/eb
./.git/objects/eb/a614126fe8020ce1efdbe2bb66d128d092ef6e
./.git/objects/4a
./.git/objects/4a/3f40cf097f92b721acf19d8196b3904a720da6
./.git/objects/40
./.git/objects/40/60d1f47604213d418cee20702d4abffe117776
./.git/objects/a6
./.git/objects/a6/facec96c60177e105db6b8dc91247b00bb9f7a
./.git/objects/1c
./.git/objects/1c/8d4dcf27b709ea4ec9922ff3b8d79fc2d18d24
./.git/objects/72
./.git/objects/72/644063f1f8a71a684348070e4d11afcf2ab5a5
./.git/objects/1a
./.git/objects/1a/50e1788f303d699b05d149cbc1577e66a51e2a
./.git/objects/54
./.git/objects/54/3d293536ee1d97d99b4570e51e4d6c6acac8bf
./.git/objects/29
./.git/objects/29/6a993966ef8c742cb13d58691f75ff27f93f0e
./.git/objects/9d
./.git/objects/9d/984c92e3b46e21d503d59a00478c4b881cff79
./.git/objects/df
./.git/objects/df/f8304194fb003e43921513400f31ecd0140769
./.git/objects/46
./.git/objects/46/a5e41cfcfc6c99d731f66a826a32f7761179e0
./.git/objects/51
./.git/objects/51/f4b9b339a1f95da6e432a3c2d2511cf0519833
./.git/objects/e1
./.git/objects/e1/2eadc21abc0118ad984c2c5dbf71b4c605504b
./.git/objects/d2
./.git/objects/d2/c4ffea4bc68ce92529746e99a43d94a916e9de
./.git/objects/7c
./.git/objects/7c/2833b690c5f28cad9c5e2349ffd40f034e2c0c
./.git/objects/0a
./.git/objects/0a/e372fe4763b5c8e5ef7e49e09a598f5a0683fa
./.git/objects/69
./.git/objects/69/bae2761a75fe49bb72c9516f08da20b35556b4
./.git/objects/69/5bf2f8857ea2d8b0119a4d67ca0b431ef02f76
./.git/objects/cc
./.git/objects/cc/6b9072d302f5d2aefb57cadaca39e14ba87c51
./.git/objects/cc/fdf386ce489ceb06794a7204640cb524bf0795
./.git/objects/f0
./.git/objects/f0/7197757bd4d1e4cc4f290cb93201ffd12ffc02
./.git/objects/77
./.git/objects/77/5695b7848b3d81b1ae23918ebe8878598c3abd
./.git/objects/ea
./.git/objects/ea/3b0e300f7e357d0c8b098736d6f8d4a921d25a
./.git/objects/00
./.git/objects/00/ed411e6dcb11f7b703ea1c0aba1296e29ebf2a
./.git/objects/67
./.git/objects/67/ab55493ae8b034cabaa155b01b5ea8e43df768
./.git/objects/73
./.git/objects/73/e1d591ae3a6e46f7fd41d5689e7eabc5b4638a
./.git/objects/ce
./.git/objects/ce/5daa66d01161efdbce56e74b0fb6f9821334cf
./.git/objects/0c
./.git/objects/0c/24de2d04f748a3a1a86f7a6af5e7fc07b78186
./.git/objects/48
./.git/objects/48/d9f527e34e975d411cfa4ed290720bb9082002
./.git/objects/c0
./.git/objects/c0/f6d94e0b8b25d62f02d7d1cbb9b4f90452cc35
./.git/HEAD
./.git/config
./.git/logs
./.git/logs/refs
./.git/logs/refs/remotes
./.git/logs/refs/remotes/origin
./.git/logs/refs/remotes/origin/HEAD
./.git/logs/refs/remotes/origin/main
./.git/logs/refs/heads
./.git/logs/refs/heads/main
./.git/logs/HEAD
./.git/COMMIT_EDITMSG
./.git/packed-refs
./.git/index
./.gitattributes
./.gitignore
./README.md
./android-hello-world-app
./android-hello-world-app/.git
./android-hello-world-app/.git/branches
./android-hello-world-app/.git/description
./android-hello-world-app/.git/hooks
./android-hello-world-app/.git/hooks/commit-msg.sample
./android-hello-world-app/.git/hooks/fsmonitor-watchman.sample
./android-hello-world-app/.git/hooks/post-update.sample
./android-hello-world-app/.git/hooks/pre-applypatch.sample
./android-hello-world-app/.git/hooks/pre-commit.sample
./android-hello-world-app/.git/hooks/pre-merge-commit.sample
./android-hello-world-app/.git/hooks/pre-push.sample
./android-hello-world-app/.git/hooks/pre-rebase.sample
./android-hello-world-app/.git/hooks/pre-receive.sample
./android-hello-world-app/.git/hooks/prepare-commit-msg.sample
./android-hello-world-app/.git/hooks/push-to-checkout.sample
./android-hello-world-app/.git/hooks/sendemail-validate.sample
./android-hello-world-app/.git/hooks/update.sample
./android-hello-world-app/.git/hooks/applypatch-msg.sample
./android-hello-world-app/.git/info
./android-hello-world-app/.git/info/exclude
./android-hello-world-app/.git/refs
./android-hello-world-app/.git/refs/heads
./android-hello-world-app/.git/refs/heads/main
./android-hello-world-app/.git/refs/tags
./android-hello-world-app/.git/refs/remotes
./android-hello-world-app/.git/refs/remotes/origin
./android-hello-world-app/.git/refs/remotes/origin/HEAD
./android-hello-world-app/.git/objects
./android-hello-world-app/.git/objects/pack
./android-hello-world-app/.git/objects/pack/pack-8216547e807188c1428d6867229615c8cb953984.pack
./android-hello-world-app/.git/objects/pack/pack-8216547e807188c1428d6867229615c8cb953984.rev
./android-hello-world-app/.git/objects/pack/pack-8216547e807188c1428d6867229615c8cb953984.idx
./android-hello-world-app/.git/objects/info
./android-hello-world-app/.git/HEAD
./android-hello-world-app/.git/config
./android-hello-world-app/.git/logs
./android-hello-world-app/.git/logs/refs
./android-hello-world-app/.git/logs/refs/remotes
./android-hello-world-app/.git/logs/refs/remotes/origin
./android-hello-world-app/.git/logs/refs/remotes/origin/HEAD
./android-hello-world-app/.git/logs/refs/heads
./android-hello-world-app/.git/logs/refs/heads/main
./android-hello-world-app/.git/logs/HEAD
./android-hello-world-app/.git/packed-refs
./android-hello-world-app/.git/index
./android-hello-world-app/.gitattributes
./android-hello-world-app/.github
./android-hello-world-app/.github/workflows
./android-hello-world-app/.github/workflows/android-ci.yml
./android-hello-world-app/.gitignore
./android-hello-world-app/Build
./android-hello-world-app/Could
./android-hello-world-app/Get
./android-hello-world-app/Namespace
./android-hello-world-app/README.md
./android-hello-world-app/Run
./android-hello-world-app/all_files.txt
./android-hello-world-app/app-debug.apk
./android-hello-world-app/app
./android-hello-world-app/app/build.gradle
./android-hello-world-app/app/src
./android-hello-world-app/app/src/main
./android-hello-world-app/app/src/main/AndroidManifest.xml
./android-hello-world-app/app/src/main/java
./android-hello-world-app/app/src/main/java/com
./android-hello-world-app/app/src/main/java/com/example
./android-hello-world-app/app/src/main/java/com/example/helloworld
./android-hello-world-app/app/src/main/java/com/example/helloworld/LayerAdapter.java
./android-hello-world-app/app/src/main/java/com/example/helloworld/MainActivity.java
./android-hello-world-app/app/src/main/res
./android-hello-world-app/app/src/main/res/drawable
./android-hello-world-app/app/src/main/res/drawable/ic_open_arrow.png
./android-hello-world-app/app/src/main/res/layout
./android-hello-world-app/app/src/main/res/layout/activity_main.xml
./android-hello-world-app/app/src/main/res/layout/dialog_layer_selection.xml
./android-hello-world-app/app/src/main/res/layout/item_layer.xml
./android-hello-world-app/app/src/main/res/mipmap-hdpi
./android-hello-world-app/app/src/main/res/mipmap-hdpi/ic_launcher.png
./android-hello-world-app/app/src/main/res/mipmap-hdpi/ic_launcher_round.png
./android-hello-world-app/app/src/main/res/mipmap-mdpi
./android-hello-world-app/app/src/main/res/mipmap-mdpi/ic_launcher.png
./android-hello-world-app/app/src/main/res/mipmap-mdpi/ic_launcher_round.png
./android-hello-world-app/app/src/main/res/mipmap-xhdpi
./android-hello-world-app/app/src/main/res/mipmap-xhdpi/ic_launcher.png
./android-hello-world-app/app/src/main/res/mipmap-xhdpi/ic_launcher_round.png
./android-hello-world-app/app/src/main/res/mipmap-xxhdpi
./android-hello-world-app/app/src/main/res/mipmap-xxhdpi/ic_launcher.png
./android-hello-world-app/app/src/main/res/mipmap-xxhdpi/ic_launcher_round.png
./android-hello-world-app/app/src/main/res/mipmap-xxxhdpi
./android-hello-world-app/app/src/main/res/mipmap-xxxhdpi/ic_launcher.png
./android-hello-world-app/app/src/main/res/mipmap-xxxhdpi/ic_launcher_round.png
./android-hello-world-app/app/src/main/res/values
./android-hello-world-app/app/src/main/res/values/strings.xml
./android-hello-world-app/app/src/main/res/values/themes.xml
./android-hello-world-app/app/src/main/res/xml
./android-hello-world-app/app/src/main/res/xml/backup_rules.xml
./android-hello-world-app/app/src/main/res/xml/data_extraction_rules.xml
./android-hello-world-app/build.gradle
./android-hello-world-app/gradle-wrapper.properties
./android-hello-world-app/gradle.properties
./android-hello-world-app/gradle
./android-hello-world-app/gradle/wrapper
./android-hello-world-app/gradle/wrapper/gradle-wrapper.jar
./android-hello-world-app/gradle/wrapper/gradle-wrapper.properties
./android-hello-world-app/gradlew
./android-hello-world-app/gradlew.bat
./android-hello-world-app/ic_launcher.png
./android-hello-world-app/ic_open_arrow.png
./android-hello-world-app/settings.gradle
./android-hello-world-app/file_list.txt
./app
./app/build.gradle
./app/src
./app/src/main
./app/src/main/AndroidManifest.xml
./app/src/main/java
./app/src/main/java/com
./app/src/main/java/com/example
./app/src/main/java/com/example/helloworld
./app/src/main/java/com/example/helloworld/LayerAdapter.java
./app/src/main/java/com/example/helloworld/MainActivity.java
./app/src/main/res
./app/src/main/res/layout
./app/src/main/res/layout/activity_main.xml
./app/src/main/res/layout/dialog_layer_selection.xml
./app/src/main/res/layout/item_layer.xml
./app/src/main/res/mipmap
./app/src/main/res/mipmap/ic_launcher.png
./app/src/main/res/mipmap/ic_launcher_round.png
./app/src/main/res/values
./app/src/main/res/values/strings.xml
./app/src/main/res/values/themes.xml
./app/src/main/res/xml
./app/src/main/res/xml/data_extraction_rules.xml
./build.gradle
./commandlinetools-linux-13114758_latest.zip
./gradle
./gradle/wrapper
./gradle/wrapper/gradle-wrapper.properties
./settings.gradle
./file_list.txt


===== File: ./gradlew =====
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/subprojects/plugins/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd "${APP_HOME:-./}" > /dev/null && pwd -P ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"


===== File: ./gradle/wrapper/gradle-wrapper.properties =====
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.7-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists


===== File: ./gradle/wrapper/gradle-wrapper.jar =====
PK    !              	 META-INF/LICENSEUT     Z[s6~ϯhfgFI}RcU73>B$(aC,@Z=(Nu=֢swJ|gr]ΩW//e6vn(}g퇡͛0ݛro^X݈wwnas[;|\[7z>!ōuP_ymfD3iDd'8l*QU6VNªޚj,qEổvD[JlbJȷfA{[z{Xiջ ̡SVJPG!ao\Z1 `ӝKj'qKϔ;< i,IJ z1^
jxk0`MSiUА]JӶ⠇=⽱G?@$Fͼŉ+}KAgKBFy)'Np_7{X!{EӾd9h&rAr%պkʖ(pU.H[ՁJHL.Ì3qk7;ν&Qy|x	[<',6[	)՞FZoUך,hMh*8Xwe3) 	EgVGghCpJG~_hFeq7¹;3pP~ִr/;:$DEM4c-`bz@/䘐6Ƅ2?" 'NPn*-pc2(!iL8R@w1tX Hn	RhXJJ2B@70-/k2-dqPOagXaE+	1de#XQ	4F q^ (Q*VF?DcnE\8u 5@̴Q+14>O><0rA%lfJ
Xw]}~I|zw$WZc~^ZUV5Gȃ3nтqV]k "[˒Dh3:}).Ҩ
bL$H2lZN"KQMm7n;<xAEz>h#3ZLjDe}5yu^f^˰H5 腭l(uD>[_`FWPhd!R+% u -+Y
Tr;*,!%H+ȵrL 68n9:cKxi'BTS0!(hFJ&v(rzC(Ȱ#j{K|v':;d)On@dSe
	("$}R:ඥ{sFѷs*]<~`Vb3rqz,GeURd!38@z5eB5A#L<5e3_V'єga`Xq|t	qk}#!ЙK'X}[N#Y>B9'la5sG+XZ!P$PqCt-z>k= l/ѦAP/؁qe
	f죰MӁʈ]^f+ܺ7;^Ք	ҡ审6IdtA8wڂL-PbYc/ 0ScN	|~
V8(͈?hz6jE ,O_8	vS&ñ?Zb 4e
ͨϔh%/*+V|Ѻ Ċ໹X|24[yLvB:p	%Ha@Ċ<m?dEj )Z˵i'Pg5tHۡVGDʩo젒i'Ѱ6ۓ7Jc;u,8e#ŐFغLw. pqfXaRțLP)xqASHş=R2Dh1ќqvHOr^F}㇮ng|O;'Ϯ.dʙe_zJ𡬨LA.AI7ABG(ƮhW
6(鰝ʧ~IV FAMtLND{Qr0Yu,T[[YM|opJImyp>3%	sunDC>!Re-Bd6ˆ*bGd&%-5P8"?S8ި*Uch$bpyid0 3\L&VA<ǆy⢉RWAL N_+P?G24	˽hL}A"MMV$T"yu6K
VMpd8K&*q4N8{jvM x蠊:rzJ/I.H|x"aV6zvt>x:aͧKki`ZG^2.7T_2LwXFH57B9pR|io`?L=2xhviPCXxte9ٍ_1}	ŹYd48Rg#c_A4T='XɥPMӨXxG	MNj!|5PRuKZ|	v9$nR-V"5/i
V$wI+-j6/'νƹ@lL,7=܋Oz_n:{/??;op:I4JISќT:BKȞC,~y ^/W/߮ݯB}`e|\akansՖoY {TӭpW85H5DB79Dx ;S&3{V,?9}r<_b@`a'v6j	7Y@C>2ԮJu]b2ʍ/7zK<"[-9)8	.k4m'ZtWҗ\n=}bW	H`xr^h@h8|gU<j5>mtɚcĘ;3|bpx
؝1A73e	FT-W#c[ r8HOq^FQ%is0kZ! /H:KO{t=,|-roOAi9l+Z ԑ+1G#ŝj;jIY0OAAW-p_造V2	NotMv9!@`%nQIQ~&=196uMjhWx0\ږ(hŔΣO+fx{d#H6dEcF.PK  '  PK    !              	 META-INF/MANIFEST.MFUT     MLK-.K-*ϳR03-IM+I,
dZ)%*%rr PKm>=@   ?   PK    !             1 	 org/gradle/cli/CommandLineArgumentException.classUT     MOJ1^/sRRa"HSO-xO46.n>oIP,(:}~ 3xng_F1K26Йl"$D
:6R}Ȋ<\\y}ۿ,!"D4,NiSnE|2(ncЙgx2e^ʋ`,'¥StUi4=p*M+tqxgY']hnZaИ0U0JRv	@y{GjPK`zX!  p  PK    !             & 	 org/gradle/cli/CommandLineOption.classUT     eR]OA=
(~ʇZB X2fwK4F_ՈMzw3w=ΙϷ ~oyVp-mI3fztx(=Wox/Auf];AhK[	DQkz7uqU'_joAĵ+/]Hn] C|S<`|۰}n90ixw21UQ
|wmRfAbD0ZP:cԫ"$#TۭpõMʔ;,+-yF0zAﵚ23ߓ`K,p9Л˯B&#x+c)d1b $pa#IK$CbmN.HE>\R1xT8Ev
WC#h2:0w5z_VqӸm
r.S*BEiQ8=bn#7,ltmۑAwhLlV='Vh1K~(4	d"_i"Lda%:Uя^/0c3.Cd(OBgxf~bLƇ?T	b_`k+PK×n    PK    !             3 	 org/gradle/cli/CommandLineParser$AfterOptions.classUT     SmOP~.ʺ1@|+6(ILL0ܶw]]n;!?hhGO,=<9O= <Dj5cà<Bi#ȯ/x$(Xiׅ5Xq?F50$V92aU_k>9:7t=)K"EbtāqA<_0rK/J6 ҩP\EBͬbHC?BOJl<2\HЂ;Ҭ1>?av;Y0i`a4 9*nDx-mI
áׅyQ喴kJOk/wY覭gzK=/)FPi_z^5bȉmB_t3ҺREZwp7ۘf`0\-kO1@3qh61$"6%+nK4TudhO{Z5f	r03F(G6>wbډQّ1:x_Z5ʹة+Vq{1挣StiPKd Z    PK    !             < 	 org/gradle/cli/CommandLineParser$BeforeFirstSubCommand.classUT     UkOP~ Zx	S-8%&UzY4F~hb$^oA-k<{rQ`xS%a	U_TSXUؚ0-V/y5S'鉔Z-kjFCϔ5$pm$e52h/³ÙV609\]\3L0t%SuHO;y]OSbqz~VlKha8i{;/$2?͠DaEuWІv삢@n0t86)tP7#&6HĺPL]$t3wg>i2ĢpaS˛z:a	|L^eWs
p;Cצe	gX/V}J&H	dG߶:<H8Ii:+%YCc`
Na PgL9İ[ߢ=7w$RAتBh}MHO߶nf	ۿX2t]	g95Lr"?Ň0w_fx҈8}|o
	d<C^ /NFxup+OO%1+-4乚U]^4Fh~Ia]8M`85z:fJ|dj{"t~!ZB5wxP0D|5$
4|Xț5d
-qpYwK|ąU\:kFK%wM:@JED*u}ItR<c@Vބ_PK1,  ]  PK    !             = 	 org/gradle/cli/CommandLineParser$KnownOptionParserState.classUT     Viwe~^ҡN$aH:iYԐ DD;A:؀KMN
.θ勉(3Lq8~_=s<O}nKW}s7 /wphPMjBPtCuuˌf-WNêMa'uBCH(f\T>තҵۊCy 3F7	3ۺ!m[Zۢ	c&wgٲ3j=me^v}5{s/I%6j\n>ly+2W7`;`oCua
ĐLuvh%	d#Ò!uD]݈uڶ:W(lMpia-~@~X%*%aCUr*5oN)2d\#B2Zv=Uevڙ|.CWϠX湦C3	MTj־%nCuaԢ3Ih%R{wʸA(Űa%lԣGn7 fjLiĽxh/cAA6oh#2n Q}+C˕-)y$u^MB7NSٜ;)TFUGֈqMl}Q|+~*;[k8!JV!*R%cLbxe'.t_YQLU\0WTs:&BCn?G{<ݍ}"OIfKBw!y+?Dpi=5;Ug=Ȑ2ÊƝ{vO\.+%}XAcĐR*j@h[2D+.#oƵeqS2.t-s1kfP)rD:]cETJVeg8T_v,aɰp(8 F̆8ܡEN9$ΏQ1*Bx2fgfƄ%<%iT2B+vhgls4H!.Ob2.8UőY%4
QFͯzBV]fXZ9E^Pޠ
.?1A_ob&8}uxP&	.?0fl+67
do)Q.^Tgp6!qo5BtC,S'1鋴b>8OK]Q= Acm>pQ/9Ջ]=i{OޓIa~}K$6SVMa,OVL`MdkXza!<mƂ1GqG<6֖I@}85NN&}`i/nOūɆ;ZYo3荸%TQ\²;
X$c\_e)Y=/?B\XvB%r\k=Bc_u΄EY>v$z}c-I3Yj70Eo8O:HKp8ҩQhDf%V4&q8Y)"|V{ZƑLp4ӿǣxsq_>)5|bMZ̉xxQ{5F_akI֌̈́q]OtNh$DW]4Rt "ΏN\*ϑ,XYV9ډ]$1(MR=S<MSF&$jO',XVUECկPK  b  PK    !             < 	 org/gradle/cli/CommandLineParser$MissingOptionArgState.classUT     mOP"cOh!:hhb28ww]Kۑ#Mt&3hHڤ~s"/67wh5  \CAwxh;{^tֵw'feDڠ1\7b)DH{")K{CS<q\ppuuqi5f9aHn\nE<
j4"ː
r؃ߑN~@yaXZRQZ198CoۂA97=^w(jyAecYW`$hOCS(p|~	O׬œG)LKv]|#*b+".MF}oՓIʤiyBF*nb.y6#~XZ=u:5{E]|.D<u2";Zy3կ(~F|M]JE3$EJt	F,Yxc/(qZƧ9T62ڇ>Q#٩H*c	~PKC'|L    PK    !             = 	 org/gradle/cli/CommandLineParser$OptionAwareParserState.classUT     TkOP~!PA72nʸ	D_Y{(#BpI4o(%k}罜/ c||'\CRm5Eg߲o])p)l=AiSDZ75kV!
Fa2{]m״\!嚄Q,³CcCYz0Z$uڲDQSrݶ2E᮱DJ+\zB/9>py
7<uݸ&3PX^pp{r-M:zh 9
	L?**T1'v53k~p.JbKjCz']DqO QtZWtEJU%_?jVo29iV]-;-Y?'AS7[Y.
ݧĐ@2gٝJ)r~+{[__X3t]KO
SR]/K)!/g`=5Hx^0hUۦdd剋a*I	Sgh
LSrlSSx0@s<SBB`Hϗփ0!dL)t)ھ!hG%1iЪZ:mfYGkpHe
` u	cd?19Hs|MZo#)Qr^]PK[  J  PK    !             8 	 org/gradle/cli/CommandLineParser$OptionParserState.classUT     PMO1绁PJ9q誇bY =Z$D(ʡ7dlo_TqDo>ߛy~bsyt*hxQBr+2Yk8Ə]"5K;^)}<0|.{BJ"̔.E%B!jbE|c{`	2 "8Ҕx@N\o.rru0h$g:ԎAB5MΧ	U2E>~	Nw6if)*cgȺ=ٱ=ѕF*sU93Xs&"QkԀޤ:!#+ߝvR&,-NfjA1-kX699||x*]=PKu[z?  }  PK    !             3 	 org/gradle/cli/CommandLineParser$OptionString.classUT     uR]OA=Ck[ji+J[4D3;Wf}1?	D?x-59sϙ{?~wɭnn^(]7+
	Ȱ::^o:CC&|67(W5/uPw	[76֚-zC~?*K`04mW4,W6㾽CJ{\EB-IqEax5gaHq0v~_)[` A39Je<olz*u9LO
f4Q!C\:)__6tbP	U4,`1[PEWPY}<pLaHsAOJF[`9xaI*Cz&W]7]u2(Ks9bEķ¨&U:-"E(ZVQc0{=)3K>|7,joKgQO(ڟg2iwRrR PK  C  PK    !             2 	 org/gradle/cli/CommandLineParser$ParserState.classUT     QJ1jW.\q\(
BQ]fv$%3-~%ssɹɽo/ kwσTM:nS)oP"OOܠM҉geU1oz5͎HZ]	h(EP-V7Vkn]~BCwLGB"6J)\ur:&A	,5rOry5irrBtA\-@
em\deӶrǯTps>=jV'Z}tZ%9T!u`&N:KԜ</v9M2g{|}zpO-`A1j&70r83=wboOϝC PKɉ    PK    !             ? 	 org/gradle/cli/CommandLineParser$UnknownOptionParserState.classUT     SNQ=
oWԶt|X ؀@LeY؏5Fg& >qn) Iß{g93 a'ʭ=nmE
mA~)<#A֎܋DQ9k8Du]\Y>o=7fUJกQ-Ka}s7Cf=KK<q=Jt$=aZkBL/z`c4s.1"ud(U:A\:]M)kbM ?b;\L|~!{Ї+ՐAoRԠ:kF:29"~ʣe}~.E0 JL.AfRj	g⍦srBƘN-Q+Kc3+n/i]sȩĶ]ZuWXR~KCQe;bW"V~UW	(Ȫ])Դ%)bӷDI'6&~``CC4qWqGJ~mŮc˶bn~k'q-u6<+hasRwG040 fSBڡΉm	J(AHPKKϖs    PK    !             & 	 org/gradle/cli/CommandLineParser.classUT     U[wU	Lp3XiE酋!mjh̜&C'3afҋ,]G*آ,g_|'?}&<d}/ EañfL3՚arϰTa

ڬp7U6֫noʩ*Czn:=kgISg$*a:'"{OWwWOJs!0p;fArpi4YZ>LF
GA]>&|<G\fd`z43>>0cgiGBz{p~:qS^5\^2n3kbvܭMӞiZoawC ~+8fm>
0#&QJFYUc8pYqݎ]q'"ctВT~ƴd{1ۅ&3(v!5oߕN0N-d0DO\ɝmyܰ!pdsPL%MSMS!O4nSMz	ëlq牌*h:l;q.,M@HQҋ>II\\ƍ,%|߸n4E\
XЄO+YnYr]Wdm6*,\Z梺ʥZSWjFpLm61U*P|;5C5"O%w!ݟbf$1~9y*aho:d!\_Tu1C}(Fɯ{ce/P.1r:{!	oV Ilm^c$F&,[E )i"|IbPgSMlepNNJ nW0Cag!'*hُ2EÉ9G0S⪤L:zv7ʺ+59,}nHeUrjI8RqE^15@4Km'{VI&+
$± !m{(w'A_ 1:й
KϕWN|'X,p#]F?")yo?_"[
8с`-.X8`9!;~]'8i8Rp&{1Ô~g PK  c  PK    !             & 	 org/gradle/cli/ParsedCommandLine.classUT     UvUvvXhP@$DJ{ "ФE@=Lfvi'3qf%ŵjf\yE"?߷w~ǟLdxWᜪqKχ|8b0Uϰx9nrƵϫcR!^TKqC๹Y=7CX'ϗM`X;U>w\Ed209c0LB਺i$UXT-=E$jTBb35OB1$qWe<ѕD,{;i0Xr-oe'`/\=G]v
"eS`%oqG)}exNw<q7>qO1ɐdSI*8݁b8+P2MJ{2"
َxe[Q\K`H5tD+"6~>٬BUN$:	f.D+2Õ5m69QĜY̷#	SL+$;7t]BcP,_۶a1Ld94o6Mʣ۪"gll:'&ޗ&Fhʙtw>MaO,mRZ*ѣٸфI!-l0 <yynSpʤ<3+;ucU_B<o;E2D@\}ŮGHj.*骉/
M-llC7M<[Fݱe{!i }2wk͎*՘ӗ!7$UU=[%M4nWplS0RY#|L2|%r^btb :HX`?v孧G~/Ԙ,KȦ#Ue+_|[XԹXZ	Hp[GCDG->==r	6,~	;Z?%2\ 	Rv{X&?ǧBF+TDK:_yVEu_4,D(_j%XmPK2w:    PK    !             , 	 org/gradle/cli/ParsedCommandLineOption.classUT     mJ@mmmu"Q1 74MN2DA|"( >8)ssoΝ/ {Xexy~Ɣޑ/ӉyyLFW$k2k?Q4e!vI|*`߰*;?,4q[!Y"2"%ĨSR2z1M:s*s!a#WI(K
")+4Ž<MyM夺y=@,	.6j)%i/!3C_ '")u.CƲ&\u4X
|ϼ]3V*oֱ*Ԏaho߽cͻw~fe_PKZvmT    PK    !             3 	 org/gradle/internal/file/PathTraversalChecker.classUT     uSksF=H1n-(DhG`<ǗzuLhve QWb {=w웷pMoNOEq9A(KkIK{\ՂA.sa-Zs©N{reC}wS0JQ*^׽y^Uw2X02XQLyw)wGǍ\;U<'"wE^s'{tҹCTH$}P}XE_U_30NBi.ޭQyzlbaL|`Yy*6z\ĳHQ0|9q^Ҧ}OQ!#BJY(S^JKcاC+-57eRWc?dt,0pfbǖ8ǏĨf&dl'go'UԱϵHע)f8!pT~nmg#jڎfvnˠ
庝IOVaɄk-Qsm<D>kܫ".Up:M;txwx;)lbI7U1zo#"p]#k+>nַ#b/L!]pλq]k@\Ik9NFX~.bܿ_K%e;+B5zNrYupeVJ PK$O    PK    !             A 	 org/gradle/internal/file/locking/ExclusiveFileAccessManager.classUT     ePMO@}[LBRHi"!TBDUH^O%ukG9rȁUulzf4y3;b]0jJ6B5BU3mdEJ;2$=19>RRS_><Ki+eQ.g=(y&{uqe~"Zb3msrg1>E)KݳrN!eqdj(ֶ$gLŦPS?^*Sy=o>(EVfV/\FsrA(x.,llN\^%tl
O_*MX8mLt7Ln?8KVY
kuiV_9@Oyz^@p|ՀbtC~D+_h}aŢ>^3_l|PKywʇ    PK    !             > 	 org/gradle/util/internal/WrapperDistributionUrlConverter.classUT     Q]o0=f2 c᥃CX/CHHCUInSo9N_!=uxEG!u4dY{2|?zH%ކY!$7"W~'dqMxIrK?QWVYm,u=Mu~XIir5EBiRIaw	O`~^^	Ia <TF@(CZq|м(H"w̕l)|Uv)6V)錔Q{X vmM=wom
)2g0\(a^0пwBp>%ӷ٠.q&_9u:5%qm\L5W?@כhìmn3A]tiY8́y٪faa0x&X#:\;	tN5f~PKb    PK    !             / 	 org/gradle/wrapper/BootstrapMainStarter$1.classUT     mQnA!5@$^p0	!Hqiήfȇ\āLi{zCSpyr.Pv6l*km(&eg)'ٌ(}|<%ERR&'#Ѻota~FɰB[fm!쒝^GQ2~߂Rh6Ы\r[Gu.=\@.{05%l96W&Rd'BKa:*u{:hF:R,:(?9cל^+\ZXYKosr-l3֕%BTRW/;kc
OebCS.yMPܶ[+5WPKEҚ    PK    !             A 	 org/gradle/wrapper/Download$DefaultDownloadProgressListener.classUT     SQoV.isKJ(Tգ,	MC)++CJ	ԠH؍}uN썇=3Z*&6iO50:ls{s_/^8ݻVc)|\29kZAz<rlAq)<CA6øKmb9.\CΝ[۱Q Ҽ!]ߡh_Ȑ(^[l71 zHHn{%y'dJ{_m{2púFR CfyS^mm+00#$Td0dQ!>PC=)n`5GFw}7X#RºQdth30a1n@'00CY[#Q.whfHWV
냗HwcΣDV+cVq7)y5`܋j
1Uyt|"Y,MGE|*T~OjF6-QKp9A'de%"GPj;ZGnW|}=u/4|0l%)^rV"*$t80qrmuO:{`
:]onK*Fʤ0$&oL	hEݧT~^UƋmLmLmcY"O~{~~0͟Rvab&{:CT7M?AM?M33_Qʦwp&>ȵ_,>ǹW1Ț~p17Ϩ)@=]ZbU2=J39JA>4RPK%)    PK    !             4 	 org/gradle/wrapper/Download$ProxyAuthenticator.classUT     TRP] Pҋ\RA/Te&m4MI
2|:ZFq|?qVf$'k>+7 X`xK
x!ShFQk[Z6-IT\SP\
[pOP̽QVL۞kR«	+!
Sfa2[_62Od9BH)QtEH(NN$	Sho`C&1oق!R$iԪժ9wձ]n,IL/Ƿ2|ZroE*o	oq_-;uW:Z_g[rev=B atu =oՕf5maX.յ7#!'^քGUizcaӆF*b0tad?!f8{$p~$GqGpI,"R'q*uAm̄p;t}pmb;C?p
5ƈfgkm
:
tqLoIA8/Yl2$Cw*.Jt14"	\~NH%\$ZU0л-c)a;jNF!ܠn匔|C>ͪ4=4[
nb^E?CY1F&OQ<OOm{6DmtWb~F?贃YG.cu}ĉw(u>!	=?l:)Zt#SVOt\_<Q	w}lwoia[mhPKw&    PK    !             ! 	 org/gradle/wrapper/Download.classUT     W	|Ud7nKmKiCBs5MФWA&KufwfAQKU6B7ZZQ<QQTߛM7ox>`=29x@ŀZ":XQ_Փ)5Xz	3a34++R`RIU!l@{`: 9׉-Z\87T-Nn荡`Tc;gX񆸡aPR)n4lG$J+#JCBQKB	CIBǹAt؋Ĝ2MC5-	+14VnJ:a9B9NIZ!FK&iKM4t*)ڴT֨nI-paT+Vx<	kȻs^6(O.BTkCquM˱e(gX^H<\0'˪هҋ .aX2kIjU-n(N.-ۖ /\?]B%D,}k
.&/ \:a,Wn'"Ĺ}X+6`laK\nF/$\N{_I/r4)&ͧ	"*W0^ sĽ_XV}ajah?Z6/c^,Z|XW;%ۃj<mp>65mQnQ)э.
>C5ڧRii+2q	=(&aSI
JT}$taC{C'Gͮ(֐/qvsb}],C`XLOA|9tXs>}\(bzOǢ<%,a?UjLt9&u$jwGӼN5?qRHnȲRzYnNiB\4
N2b`zo+8Z(&47Sӥ܋xa}]X&5DKY[mƭ^܂א@%kQL5:j}>Ѫk6829d({Hou):p;[1Mb.-i5f/D`b2Yf)XoۄSn]x;rĉڴA݇w:.r&iEV/ދ{cu֞rIJ]ݲyv d`YdU3y(X6dbwc)u -n{jlJ3
!>ThvsZ0(>Be$&n#8'"w<F5rNPk.T]È'0[<^܏L6BHBo	2 'gD96R)<4"+kQ')O:ӱ). m<i>H68HgYqS=W,n#1iX|	_ڈ>L<ݗ_W(zw=s)[b>,/=-><,6ƒЀBKSՙ99ES^x--|'jAK-_!7H]yy݁"~pCCj)PX<ZCjʚnf:.9SB
GY6!1"$izppI*;%F䝟eP/I#&iJ{J`Bf,*Ftȃ?Y>'ZLGPeUf__)u#Xs2@Ȩ9oHJ-(6J'+yyL'eb21ِJ|GVK	caPL<@v"퓸0USn
5wa3}N!z6uMa3xXQ,1"w3rѳjAl-YekIPVYٻwWhH{$v5#k'lEuY[GjሐA;nؒK\D6կ
@$cH=bYLo<RfC?VذGjʸԆUPx߬A;w`]h[S<Rfc/(L'	#ӯE5:J.f9;"]6: Ӹ37dp)C:
O]
kٗG?GkOLbOD\!ܟMnEx0nFROU7_+h	op-xeY-6Ǫѳ3g-)nރl8A~QjE^(SxچY:/**9X1Sl0v.M99C`amυMAݥlK\a){jå%uR>.PrUU1PKe	  *  PK    !             - 	 org/gradle/wrapper/GradleUserHomeLookup.classUT     R]OA=C+~XQPTdU(	ۍCEbRZv~ev!cF?xh/3sϜsw_Ǌvޗֈ[ԭ[L00&y$cˡkH(NXH/u=r_FvK?H=x({%p܀HT̵o7æV(uTYz$*t=2_+E̽I؍I>pFfXHVRNswzkoﴚn<k
T[$sH@۲<7pKIOR׳IPޚp+8r	3 PLZ}4\U(N/@١
H`vY˸Rp60K3kEԬV*0Wg%ʔh(qO	wʼhS|`GVp՛@;,r? PKAs	    PK    !             * 	 org/gradle/wrapper/GradleWrapperMain.classUT     Y	|o4Ҍa+N"B$D-C_INr4FG.]z=aD6J!@K/BMOztl˖C{߻oÏ)t7toxCM=lb5h_M}MLz6nI3f`=m$=c`s@Fp&ԄDƨ&`\0z7^"~_.Bf@ x0T?V6cƑ7LZKG-L7Xh<tVu֩S
LsՏ	=߸Z#U$'4??<ߓLlijkBdҘFvŴXl3m5ZFƈPTM,*h6Ӓ*4ijlΟv.WWJǴp&(3Ul،ZƄbDSFqOwOtgB39ih@[Bhh
0qf|$	1Q'kCiFBXU)Pb5NUL.|:jM<TOA9f.=; #^ C@E&Ã5tFi-S}ցi{^ "V6Vz
RQR&Ex2[Ax*lx^fjѨZmF*vADm:p^8@`DpdFFN6tZP23N%4s#b#m;-Pbg/RGqt2ba dB5`ۯ>: 뉄ytOp<9(^0_^&́VpL]%f\٧A#}/86Bz?
v*SRH&(:FV4VT	+2C
CtiE&'1cd6C~ϟ0ۯ-9$vCGDΨmPz32trFzb[7b_]=#xaZQb KY-:]&iTAy;mfZlV(RN}JNa[ BRm5	;.ng>nnZu}ϴaygpik,Nkco
1M~Ťhٮ#k^>Ĥ[L&+|GTJ8ڋ.X
o0[AONzR}pf]}ُ_Ptvg&cYzPsLR0IH 4`pMT<^z5G7ut
!ܻ:Q6[_D5S%;'>IʞbZ+Y]iHxQx)F_ZLmAMTTOŌc;eP^A	]}SrL yMj.qrrzQp][.rwjgD<C<(~R-~j3Q:+f*F4/DCu;iTQZrDL_  ~K5q;,+d ??F%3i^uq0ad;bIEv0?2.xZthO<,vVTY\ƛabgV5v[(\cZ6h/؃.<7 !B+<s)4T^0CN 1Ve$hq;cWN
cpDdr
1كi#Qp=Z7qC-iOf<jL!g^xiZ×L*hǢFZ٬Q\"֣AE]PFƟ2 ?bԐ
&t3{ܠDoi}hkws[ОCvv{oƹA4VmY\R STy;lFꈇ6 fFɴ,P:0z0iU=fH	:m_Lݟ~jm95lCҳ|!ሇDkb/5eH.?ڏќh/ʲZ3QcKҔZ-\Zpt3 aKzLDy,GUa%15ӇwǓ)
wxxsh3#be3ZBYidMk夶mnc^T&T71}q rr7!˚mɬoPue7Kx)to䷠Eٛ[Sf~0aFoAR*.	Ӕ=8ӒeI
P5+k6vt~um>x`mXF[%,-ꙓUy|w1f!Z@?,")7CrǼ"GcŲ6~%ߑVR:ß '>lqEuhs'EϠ*=(2ɘS];VH&GlQ@^5{Qxq,eGkhSbi_!Y:'별=6ψ>_pg:`ZZ'gR/*jef:
5~o]Ҡ>~_s4$UJaPu8d}|F񜽎	ݹT9pRmLAf.4mm?V3~v0_ތe۲/Z׆]SȸV?#'?sZ6;XqQ)ͤmI뮓8}T_hsQo5=2P&]FՌeTk~IiYA4
CJJf"-AG/3mM*[ք1rnmjH/b ̆řIƠ"?M嫌EC=|OJT)ex$S08^URPxzifAĚ1V$&i"ymiĥPNVS.%4n%.N
VpQFi3=W|X&C3=%=ǛI;mZ[eӤyj/d_)dl+%T)]
 ̶({.j`@iɈ:pcv|BPGb7R4v/JB,d|rT'=`VFÜštsQ|V6FX
imɝD)"+02C̗%cAڨI+*b#]*R`>:ۘa݂j폧˓KUocQɧZF?ex-NBRԂAB(f^g2OO$P~,?^Y*!P#(wG|J]8zBKF~uCyD(1RS}'8B	N0]֊\&t22Qn(`d߮}i3鏚1-WҜ`m_},t=C~lJr-]mF3wjf27Y|E4]d-x$*9R^"HV94'OyZpVVb(]mb
S1jtiՇW߷pUWGhOh_:($E"h\e)^UwuX͈սŕVH pn푐<FD'<9BcH#cL!=Χ}N3LtHӉqRbRWy<S<}5>sn7My:Xlj|<}O ,$@'@}kl׃h!vS,2B?? C*yq'hECn嶠sKPoGwyz9O{OC<8yl/ujꃺ^絓>g*_#$V-QCEV-!k3j >5gNNz)S3U hyf{OS,5Fy	y^^EuT)yyq>ŧ8U!"_S09	#WVEx\'SrVE	,V7	_z0&c7Fi/=eL|[z};pi ?cf؝c8AEf0"^뼼k{F9ĂY#]:DSQ:hw<1H~EF86'p'?XbND κ~sp
H	~Oomu±g\ն΅|{qOL0Պe`dF<7zH_{1N$맪U0[
^?Gˇl)x	>*Ы43`J{BO t%BB5	|$}ΰQ+[YsM"tPk	?	 O>V
t ;|-_v+߸V1i߲C^;^C$ӛN)>)SX|ݴmWyEt=EK
V7kä)]<=avhAr:0ۢy%U$HTQD:OGVX9LN?MǤȁ0 Ru-8{FEyiWZ[	;E=^i5/U=M{ezw8 yը&T6y:U1㕶Xi^J;%*_,jkͧJvNJ;'`3 ^U#S8W9"UuO<Utr
Hʳ._/ҵЕ#rt5Xϵsz<;\ayk<2uNT.W[NeVbֳ_Q<D_$.r>@'ϻC'C,fh=GsYJ*y)ŴᧅsyuJ;vb -q[x-u|je
ЅrV^KT'7S| GQ.?FaZ#O/Zt
_Υ6:rnM0]꼖y.w6;fW%RNjs]*6+ԡHە+ЗDPK  )  PK    !             " 	 org/gradle/wrapper/Install$1.classUT     W|[eI{{m}ҽnmڽZ0[R(e%ۤ&ݒrsnDDDQP]Z(0@`<|I|oXqk]V٩pe2UY[fDwL+Zam#bq6{?cxeKčnT\4ܹ2]H=u1ðX7n58ɢeuK+TJ!L3b̰n[G>[5X#y	mַ=]^f#()WYP¶SDdzgPV=2/b7%mb$3zO(3a36mf	z;2J3k.;aK
,haH{
6e%|ǌ[H"J[V19Uw.,ޱX.%5oL^LBpW1])fkPP!G'MZ2>d7&tVQ0c'DQ%006snU[AV=j uQXX_u#iӢ",fiK:kձR8`ܜ#E.
q^qHreo)8wO#u8sbeji$2veg܊$cx:eGO	BF2r!dw13Yqyią|׌5sN<N"璶gYQryX3Lm;FTZaӽ.U{i鐮%a}p.݌$l\M)S+a.DmJMtP+(Cq11L!+:SaQP"z<N"$\$t\YIdW}qCc["h3j]e	ΙV`qz
c{a &+4&q	#lo!
qBy>lӰZaıj2\DCrYiۺd:qH!UWS|ʁ(a:Ѣ$2F:q>[z2}jlsN-"ǘ\	syfc6H\wEn[pk9djNJpTT*.;;|Gv>5|<JHǥ NA&|6LUOgPUwmM͙]K{Q̮XMD!9}9ml5.&aiIZb۠*JD{Ex FCdmFDWaᵆ.#IkY4Gdx\cWMz'`/%/Upd^<PĊSܦiJ&+	W,ekOʦR:ȡL<K]z̬qb7~4h3ל:/qdr܊Hd*\c[}!-']Խx2^%x]fSP9F RQ}*~[md۵$_!:NayTwgV_\?S4:2:=۶n3.IPz1kf,sL;LEaatS^*RE9Fo2b&+/pɁDn< $<+hP׷.٦(ݑ#es&nb	=sictN9QBm4ڡI3k %&29THʦi(1m"kbT1:AX#7ތeLU9[TecrToY9JNU8A,&AMU^+jj@"7
cJ8|+ZE8\T:K蓓X(&b52z(#hb)7
d+[QEq#	dfǚn T,#C:6}%#0dmȚڠ'ڬ3SL:DӰױyh#ST̯-7%!$w]t=j'8:i/o7ƴ(g7fabTbnγdw#lĴ$&X1Z.LbiI#KbV<PDS?f
ʃI9ใ8?غkvlLBO"^ntbZ f,Ĭ` 6ADQo,KjK'	g
qi@@3W>u:m|-ޅ>̻8 .i>t5^1pUP}@F~,/	<J.	hW!>)_$a|}Г_ )ø$3R{YASZy*P$;{ǇꈔS}?
¬r71c~<}II<S ZO>^StƯxQk2jGik["5eweꎃg"OάSE` Za$&~z%5u?wA#.9ԖW*D1?);چ*IQ܏-l|(ha('G3u{Q/jPOi#$\
܁ѯỴ)aQDaQ*eAmuMR,n%LV}#bi3H4TKIR<HBz*.'~;ie8$|$O×M	ƻ~ C걚T		+r	Ok%^<a$^ 6	o>$	8 gĳ? ^guq\H!㷺%ΐ]H!;]J!\%ΐ!דgӮ$ΐ]/K!㯺ސ8Cr'qt%ΐpMT7<CյnlD=DǵTaob~h
jxE7&(&0u\PڀE(u9>e1ŽS1}!|MR[Vq PK"    PK    !             - 	 org/gradle/wrapper/Install$InstallCheck.classUT     eJ1XZjm܍V;^AAApΜNɴ.Dķp!TED;B`s;%JBwn8SZ*M8uC%H
nl7N[jK7Xf*<65͟vWklGzD*!2*X푱|͵͵RϽ\]С$ȏ5Ff8z;+cP`Zegk
2k(ٯzgT,]Cd:uȋ25,,5/JK1`BAcE5-0xun3W,8:<J&W1xGK}'PKJj    PK    !               	 org/gradle/wrapper/Install.classUT     X|Su?I|"bp%06$1bU !ҵ}A׽
pn#nڦhl-SZثɖuudֽH|lˤӹ|;_Χ&1]8{'ZIʶtd[[2v~i[ɼ509Cw,n23jdN=\el$ǒ0ߝ^g[ep!Ä;'7
5bZfO0csǶd8dINƸL+mgsѳ9󴣏Ngzz.$?)3[#N/HuLu9{dpVjOL}ziM-]e4dr<dݫ[:ͦ:ؙ3'qn{Lv2=԰q]#?|´jԤ2jSS)Du[4Z(_+N]Za,;tGJ9Ӵ;Hvhue'0ߎ^_Nw]X[,5#Lb(S !\eôZ5ZKw15+ւg:\x Ř7>ʉSp`Q;XspBC{:<ث馔ѕ mho2(a;aRr+ֳts,5;8vmvʹxA)h"aI^ɣY09PA.]ꮏfmÍZؖVTV4܎3c٨gGM+5/787\wa\@qù\aMk`Z="(HLkcoHN57hô 5_j.cGWđ@xmEt* rP&8m5kBAOwmQ	f<I05ptiϛ#H45v:rsxʵiK{lJFx^/d]!A2Z782`Nh4J'VTko<0|f*_Ec쀵PBĎ
=*h)DSa,{9~wEٮғ`*}!Y7Lw
Wqoe*F(79QZT!γ4ΔAtKwK)GGiaJb~c}swO.cJyv~@v>2]j!~DtA2.=~aZvRHXK?<̨6,j
$dlZ4:<y}<:2CaE==F9mzVmN>~̓:a_sllƣq9,dQ^GJ5]#	 +[a
ۣÎG{N,窾C.U}N;Zx쒍Jyңv1ўYO̓3cLgf	B{QkjkLH2L?G?]`=n"Y{nvt>l]4,OSdF;*G:LҔ4C^Kx cwC* Yi>CЖq+/
+s5ǃ%L/KH|^AۢJrtyH襢-)7Ϲ
-tPJ-'˟D]_B©80<,UecM3W__"7=[PheCfL2uRMW:1OZ (O0_Hs<)5E	\~~IWB.jbo$"RCwL:ϙ }K{$Lߖx'gdۃxpJT_+MШcև`rA
T
?zH<(/3:_`Yy`
E yJoХYǀ/\ 14J! |]&nnr=`/x=Lfi3sXEJڼoUI%p/<w2=TEK)5n3| /*=PgI+y^Io)-+O"o;x5BmapzF 1-@2T!n$9B\;*@0oK90p5qӶs]@^0':uVc7͐ѳe0o)-!5MxÙ#NZ(ށ
xk!N ͪ45;fɷpq/6vSC.dJ[J#8Vya֜?̎ua*~#v Eͫ&xxo5Tgxc?xl8Q;B<t"D2F0eչA5?!>ԕ[Wru4GWGcxn[3L[Cu:jЛCbF`feME2\2-c_!?d8DmDU>jAhŴ9F]Oƫ,=0I+"q"Wh%zZMkJl]#EZ)JL}"mLBu7JөINVs&ߔ<i>v9%/[SY
|탍)zp*I8>I{'簍}/ёub~m:7'a({b	utL|ҩiIYO6M_>bh $>1o<|t
z/f'`oÜ7WOʖZu_!)JV۟7,τXtzk3Ԙ|uEzb֦4-(fZ2/" Izʷ5H^{:́t'ݍ?.n(@<>x\ R9WJt.ϥbn/>O뒃?,|J@3-jgm2m^^wetb5q:߽jl<z;E.Pup^|\4Keo-GsWJ:jiu9|2K0}H1E_PyZ"#78AGۓWxf	Lk,}Tčo&e'79I_o/_^Pګ,LUZVENEwES_уtLct%iXQ-{_{?}Dђ_4oTlSח%7~s?T)&7b8:doVA r{<By Qd_D`Ȱ$JAǛ8xq*:'FbP,+ xW?-qwy]uyCV]E4Ew+TߥE
aD7}E=\[j?u+wS2~ _)\k?Z\.FW20\+HDB@$ L&>4ɇ'"H yj!b8y%d-M6#(74q|&8[t|GWK~B|+ǯSFmΨP'xBWcz^'Dej,ToP2VTܥBe᧕h
>J8E>`*K- wPK?>g    PK    !              	 org/gradle/wrapper/Logger.classUT     kOAB)B	[[XVĄQcFM^^0Wњ2EHچ9?	SM^!}[5
	|\dSF$0JHޗnDkz6<2O7[K~Pv|mSK[%AQt-HB^8.	,mڡld~eEYlBSXmUXCJ`"	!.i9JĞ@;3^aW`(_ ih 1 3n`ykZGYqj}b41$3A|)^9X<f4
~˘Mc	dyGk4eX|ʅjŗ̫"W+߻ٝWC},(ˇ|e`s}UUjwd7īSVj'b3y\HTB]Y`u5>Enq\;]a+vw/X1oHa*f:؄Cg`a_^wPK]o;    PK    !             & 	 org/gradle/wrapper/PathAssembler.classUT     UJ@gMZE@S+MC 'AQ}&n6a7[x< >8=8Y N`fs=X%OE^*-*U /$nQpHpP.*w|:ဗi2P'I<+	L:bRe2)5ZGoa$>0be%^+
ъDމ*tXmCBEIxjCA\U]08T[ϺCmaи/dbt|ئK#mA7P-PK)>$  j  PK    !             0 	 org/gradle/wrapper/SystemPropertiesHandler.classUT     T[wUM;qB	knE-xP/x29INfLZX]W^y,Z}Rڦf}oW `|dpkUtʪ)klM*$lp߰ZM?5]/Vha+rr2Ec_k;~[]!	]ҧX'&FU~1e--qvC֓B]#
뒷ZBʏ@4oK-9Xj0?kp^X<Vaa.V=m+`3c;5pAgjv1@:s/8xOäjŐ8F08N0s:ƕ~O%ʁ4u0^oHm*é=>;8$-E)UB)U,'.&{4dv $<prmNrǐ0rXţ }\\e;^FL>/!exT%q6JE\ѡa!rb2س&b=c>T?g:>uvXtdcViߤ^;1JJ%jفy,,!xtu_)./3$m7b%Zpg}]oNU=ZY)=\o7HdkZ_KK{tcPDh?ڱ/*;|\<PxH}ȝyew*:¢cw꧅ܠ.r'#J:Il1s7Cmb0q\T	s1o΄8BL2ʾSLGbk!n<ˠX/H[?o;Dg[?C/kvbf|<A%'eAwOnaPK%  N  PK    !             - 	 org/gradle/wrapper/WrapperConfiguration.classUT     }mOAgR*r}RA'Ŵm\kI4A~ ?qw=lٝovwf?`	|f>yZ`jQ\%qF,hPSdE+2י¨0XFPfV1ĕU6#VdV2|zK5E	Ls\Jʘ.֙nZ8MfEV?級^`ejtZTXR*S,%Y={C xN4PUJYB/(.k\G TLfVjo	eʙ|7,nʕRV!}/WLܳ\R/LdH*rl%ѡ`@:XH!nV^d7wwsٳv}0*nAwJg /@0`y Aq a#3w.^;)q}t]o`(w+&ujGfG۴"@u4Dx?q7ZVZƎXF^{Oljڏ4^1?O섧lk9<_8 M+ض߶ߴzAwGiJFǧa$|so{hSD q;AЛn$AqǮϹ>/8;K?q'<O:;>+O}k`w|6\?M7n,KvAPK  P  PK    !             ( 	 org/gradle/wrapper/WrapperExecutor.classUT     VwU]BX6MvJ7S:M^ҡ83i
JQTPV*f&iS{~w{0vtoj"-OBȊdʚNk	N:WdpZp|ǇllKJCL*2aY[7%6ޜ'BƠ^/TԔrjfn/onN)7'e8#+!HJ
R&!G.T2,<&KERSc<nPM2F%N֔Hv-|GS"bLqMM)iu͡ Ȫl>PW_j|*z1=pͅEԢ/Ax抯8\XEAQ0uVO((E <d!y:kt@:#\5~yFh@P8ndh.HVM,dE䟈D*.qg8Ma]"GIf@o;:aK,2ԗjm&Q͔`Hΐ0,JZ^l4b\Aq~f]|vi-2fdX\ƴHqNKG253''fzsObAi-lڍeLOzfzO>I/2fu	 r&Jͅ;;D"3NbNL}4mM?';	O%!.nh~9͵iv/R:2Ce}hȌx1$*40 %ENH&vJ!p}! +ΘhQ](AoV5)ݣqq6-$fE纛ЊI]KuMn.NQ]xWRӒY~o~+?//^«aumD=87hT<˰紫IFvBɷ$;U.GdhEm+CGJU\*hb~&.Oq\n|ΰ\(.d٥%%#9*I'ZA_&v
vH-n|=t'E3k/%\Ex.]WŏTsHG*~'B.ݸ&{%&B$VMgm%r3ApXJFO+*U錺WqWmIO.X@ sa*i`c07XkobM,<`86GPi!D,l5`{c|idnIPix8x,Q1iY0-X8y:'q*VyXWEcBxquJ-V\hC-{pĖG1dK'lyglyQȓQRAr$:Cq𱅱$\^'E5#%x},|uޠlia*~w!Ziq!YŶk<gߟM&$5n"m/	\	~Zi%O2넽ޚ"lݗqF"!.W^EU1TltR5m2Bp}PKYaS    PK     !   '   	               META-INF/LICENSEUT     PK     ! m>=@   ?    	           0  META-INF/MANIFEST.MFUT     PK     ! `zX!  p  1 	             org/gradle/cli/CommandLineArgumentException.classUT     PK     ! ×n    & 	           D  org/gradle/cli/CommandLineOption.classUT     PK     ! d Z    3 	             org/gradle/cli/CommandLineParser$AfterOptions.classUT     PK     ! 1,  ]  < 	             org/gradle/cli/CommandLineParser$BeforeFirstSubCommand.classUT     PK     !   b  = 	           r  org/gradle/cli/CommandLineParser$KnownOptionParserState.classUT     PK     ! C'|L    < 	              org/gradle/cli/CommandLineParser$MissingOptionArgState.classUT     PK     ! [  J  = 	           #  org/gradle/cli/CommandLineParser$OptionAwareParserState.classUT     PK     ! u[z?  }  8 	           &  org/gradle/cli/CommandLineParser$OptionParserState.classUT     PK     !   C  3 	           (  org/gradle/cli/CommandLineParser$OptionString.classUT     PK     ! ɉ    2 	           W+  org/gradle/cli/CommandLineParser$ParserState.classUT     PK     ! Kϖs    ? 	           g-  org/gradle/cli/CommandLineParser$UnknownOptionParserState.classUT     PK     !   c  & 	           P0  org/gradle/cli/CommandLineParser.classUT     PK     ! 2w:    & 	           \5  org/gradle/cli/ParsedCommandLine.classUT     PK     ! ZvmT    , 	           9  org/gradle/cli/ParsedCommandLineOption.classUT     PK     ! $O    3 	           ;  org/gradle/internal/file/PathTraversalChecker.classUT     PK     ! ywʇ    A 	           ?  org/gradle/internal/file/locking/ExclusiveFileAccessManager.classUT     PK     ! b    > 	           A  org/gradle/util/internal/WrapperDistributionUrlConverter.classUT     PK     ! EҚ    / 	           HC  org/gradle/wrapper/BootstrapMainStarter$1.classUT     PK     ! %)    A 	           <E  org/gradle/wrapper/Download$DefaultDownloadProgressListener.classUT     PK     ! w&    4 	           H  org/gradle/wrapper/Download$ProxyAuthenticator.classUT     PK     ! e	  *  ! 	           -L  org/gradle/wrapper/Download.classUT     PK     ! As	    - 	           U  org/gradle/wrapper/GradleUserHomeLookup.classUT     PK     !   )  * 	           'X  org/gradle/wrapper/GradleWrapperMain.classUT     PK     ! "    " 	           m  org/gradle/wrapper/Install$1.classUT     PK     ! Jj    - 	           y  org/gradle/wrapper/Install$InstallCheck.classUT     PK     ! ?>g      	           {  org/gradle/wrapper/Install.classUT     PK     ! ]o;     	           ~  org/gradle/wrapper/Logger.classUT     PK     ! )>$  j  & 	             org/gradle/wrapper/PathAssembler.classUT     PK     ! %  N  0 	             org/gradle/wrapper/SystemPropertiesHandler.classUT     PK     !   P  - 	             org/gradle/wrapper/WrapperConfiguration.classUT     PK     ! YaS    ( 	             org/gradle/wrapper/WrapperExecutor.classUT     PK    ! !       

===== File: ./settings.gradle =====
// settings.gradle
pluginManagement {
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
        // ВОТ ЭТА СТРОКА КРИТИЧНА:
        maven { url 'https://jitpack.io' }
    }
}
rootProject.name = "android-hello-world-app" // Убедитесь, что остальное тоже на месте
include ':app' // Убедитесь, что остальное тоже на месте


===== File: ./gradlew.bat =====
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega


===== File: ./all_files.txt =====
# app/build.gradle
plugins {
    id 'com.android.application'
    id 'org.jetbrains.kotlin.android'
}

android {
    namespace 'com.example.helloworld' // Added namespace
    compileSdk 34

    defaultConfig {
        applicationId "com.example.helloworld"
        minSdk 24
        targetSdk 34
        versionCode 1
        versionName "1.0"
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_17
        targetCompatibility JavaVersion.VERSION_17
    }
    kotlinOptions {
        jvmTarget = '17'
    }
}

dependencies {
    implementation 'androidx.core:core-ktx:1.12.0'
    implementation 'androidx.appcompat:appcompat:1.6.1'
    implementation 'com.google.android.material:material:1.10.0'
    implementation 'androidx.constraintlayout:constraintlayout:2.1.4'
}

# app/src/main/AndroidManifest.xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.helloworld">

    <uses-permission android:name="android.permission.CAMERA"/>
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
    <uses-permission android:name="android.permission.READ_MEDIA_IMAGES"/>

    <uses-feature android:name="android.hardware.camera" android:required="true"/>

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.HelloWorld">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:configChanges="orientation|screenSize">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>

# app/src/main/java/com/example/helloworld/LayerAdapter.java
package com.example.helloworld;

import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.CheckBox;
import android.widget.TextView;
import androidx.annotation.NonNull;
import androidx.recyclerview.widget.RecyclerView;

public class LayerAdapter extends RecyclerView.Adapter<LayerAdapter.ViewHolder> {

    private final String[] layers;
    private final boolean[] visibility;
    private final OnLayerVisibilityChangedListener listener;

    public interface OnLayerVisibilityChangedListener {
        void onLayerVisibilityChanged(int position, boolean isVisible);
    }

    public LayerAdapter(String[] layers, boolean[] visibility, OnLayerVisibilityChangedListener listener) {
        this.layers = layers;
        this.visibility = visibility;
        this.listener = listener;
    }

    @NonNull
    @Override
    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(parent.getContext())
                .inflate(android.R.layout.simple_list_item_2, parent, false);
        return new ViewHolder(view);
    }

    @Override
    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
        holder.text1.setText(layers[position]);
        holder.checkBox.setChecked(visibility[position]);
        holder.checkBox.setOnCheckedChangeListener((buttonView, isChecked) -> {
            visibility[position] = isChecked;
            if (listener != null) {
                listener.onLayerVisibilityChanged(position, isChecked);
            }
        });
    }

    @Override
    public int getItemCount() {
        return layers.length;
    }

    static class ViewHolder extends RecyclerView.ViewHolder {
        TextView text1;
        CheckBox checkBox;

        ViewHolder(View itemView) {
            super(itemView);
            text1 = itemView.findViewById(android.R.id.text1);
            checkBox = new CheckBox(itemView.getContext());
            ViewGroup parent = (ViewGroup) text1.getParent();
            parent.addView(checkBox);
        }
    }
}

# app/src/main/java/com/example/helloworld/MainActivity.java
package com.example.helloworld;

import android.Manifest;
import android.app.Dialog;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.res.Configuration;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.ColorMatrix;
import android.graphics.ColorMatrixColorFilter;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.hardware.camera2.CameraAccessException;
import android.hardware.camera2.CameraCaptureSession;
import android.hardware.camera2.CameraCharacteristics;
import android.hardware.camera2.CameraDevice;
import android.hardware.camera2.CameraManager;
import android.hardware.camera2.CaptureRequest;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.HandlerThread;
import android.provider.MediaStore;
import android.util.Log;
import android.util.Size;
import android.view.MotionEvent;
import android.view.ScaleGestureDetector;
import android.view.Surface;
import android.view.SurfaceHolder;
import android.view.SurfaceView;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.ImageView;
import android.widget.SeekBar;
import android.widget.Switch;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.app.ActivityCompat;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Arrays;
import java.util.concurrent.Semaphore;

public class MainActivity extends AppCompatActivity implements LayerAdapter.OnLayerVisibilityChangedListener {

    private static final String TAG = "MainActivity";
    private static final int REQUEST_CAMERA_PERMISSION = 100;
    private static final int REQUEST_STORAGE_PERMISSION = 101;
    private static final int PICK_IMAGE_REQUEST = 1;

    private SurfaceView cameraSurfaceView;
    private ImageView imageView;
    private SeekBar transparencySeekBar;
    private Button pickImageButton;
    private Switch pencilModeSwitch;
    private Button layerSelectButton;
    private CheckBox controlsVisibilityCheckbox;
    private CheckBox hideImageCheckbox;
    private Button saveParametersButton;
    private Button loadParametersButton;
    private Button switchCameraButton;

    private CameraDevice cameraDevice;
    private CameraCaptureSession cameraCaptureSession;
    private CaptureRequest.Builder previewRequestBuilder;
    private String cameraId;
    private Size previewSize;
    private HandlerThread backgroundThread;
    private Handler backgroundHandler;
    private final Semaphore cameraOpenCloseLock = new Semaphore(1);
    private volatile boolean isSurfaceAvailable = false;
    private volatile boolean isCameraPendingOpen = false;
    private volatile boolean isCameraOpen = false;

    private Bitmap originalBitmap;
    private Bitmap pencilBitmap;
    private Bitmap[] layerBitmaps;
    private boolean[] layerVisibility;
    private Matrix matrix = new Matrix();
    private float scaleFactor = 1.0f;
    private float rotationAngle = 0.0f;
    private boolean isPencilMode = false;
    private boolean isImageVisible = true;
    private ScaleGestureDetector scaleGestureDetector;
    private float lastTouchX, lastTouchY;
    private boolean isDragging = false;

    private String[] cameraIds;
    private int currentCameraIndex = 0;

    private static final String[] PENCIL_HARDNESS = {
            "9H", "8H", "7H", "6H", "5H", "4H", "3H", "2H", "H", "F",
            "HB", "B", "2B", "3B", "4B", "5B", "6B", "7B", "8B", "9B"
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        cameraSurfaceView = findViewById(R.id.cameraSurfaceView);
        imageView = findViewById(R.id.imageView);
        transparencySeekBar = findViewById(R.id.transparencySeekBar);
        pickImageButton = findViewById(R.id.pickImageButton);
        pencilModeSwitch = findViewById(R.id.pencilModeSwitch);
        layerSelectButton = findViewById(R.id.layerSelectButton);
        controlsVisibilityCheckbox = findViewById(R.id.controlsVisibilityCheckbox);
        hideImageCheckbox = findViewById(R.id.hideImageCheckbox);
        saveParametersButton = findViewById(R.id.saveParametersButton);
        loadParametersButton = findViewById(R.id.loadParametersButton);
        switchCameraButton = findViewById(R.id.switchCameraButton);

        scaleGestureDetector = new ScaleGestureDetector(this, new ScaleGestureDetector.SimpleOnScaleGestureListener() {
            @Override
            public boolean onScale(ScaleGestureDetector detector) {
                scaleFactor *= detector.getScaleFactor();
                scaleFactor = Math.max(0.1f, Math.min(scaleFactor, 5.0f));
                matrix.postScale(detector.getScaleFactor(), detector.getScaleFactor(), detector.getFocusX(), detector.getFocusY());
                applyTransformations();
                return true;
            }
        });

        imageView.setOnTouchListener((v, event) -> {
            scaleGestureDetector.onTouchEvent(event);
            switch (event.getAction()) {
                case MotionEvent.ACTION_DOWN:
                    lastTouchX = event.getX();
                    lastTouchY = event.getY();
                    isDragging = true;
                    break;
                case MotionEvent.ACTION_MOVE:
                    if (isDragging) {
                        float dx = event.getX() - lastTouchX;
                        float dy = event.getY() - lastTouchY;
                        matrix.postTranslate(dx, dy);
                        applyTransformations();
                        lastTouchX = event.getX();
                        lastTouchY = event.getY();
                    }
                    break;
                case MotionEvent.ACTION_UP:
                case MotionEvent.ACTION_CANCEL:
                    isDragging = false;
                    break;
            }
            return true;
        });

        cameraSurfaceView.getHolder().addCallback(new SurfaceHolder.Callback() {
            @Override
            public void surfaceCreated(SurfaceHolder holder) {
                Log.d(TAG, "Surface created");
                isSurfaceAvailable = true;
                if (isCameraPendingOpen && !isCameraOpen) {
                    openCamera();
                    isCameraPendingOpen = false;
                }
            }

            @Override
            public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
                Log.d(TAG, "Surface changed: " + width + "x" + height);
                adjustSurfaceViewAspectRatioWithCropping(width, height);
                if (cameraDevice != null && isSurfaceAvailable) {
                    closeCameraPreviewSession();
                    previewSize = chooseOptimalPreviewSize(getPreviewSizes(), width, height);
                    createCameraPreviewSession();
                }
            }

            @Override
            public void surfaceDestroyed(SurfaceHolder holder) {
                Log.d(TAG, "Surface destroyed");
                isSurfaceAvailable = false;
                closeCamera();
            }
        });

        transparencySeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
            @Override
            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
                setImageAlpha(progress);
            }

            @Override
            public void onStartTrackingTouch(SeekBar seekBar) {}

            @Override
            public void onStopTrackingTouch(SeekBar seekBar) {}
        });

        pickImageButton.setOnClickListener(v -> pickImage());

        pencilModeSwitch.setOnCheckedChangeListener((buttonView, isChecked) -> {
            isPencilMode = isChecked;
            layerSelectButton.setVisibility(isChecked ? View.VISIBLE : View.GONE);
            if (isPencilMode) {
                processPencilEffect();
            }
            updateImageDisplay();
        });

        layerSelectButton.setOnClickListener(v -> showLayerSelectionDialog());

        controlsVisibilityCheckbox.setOnCheckedChangeListener((buttonView, isChecked) -> {
            int visibility = isChecked ? View.VISIBLE : View.GONE;
            transparencySeekBar.setVisibility(visibility);
            pickImageButton.setVisibility(visibility);
            pencilModeSwitch.setVisibility(visibility);
            layerSelectButton.setVisibility(isPencilMode && isChecked ? View.VISIBLE : View.GONE);
            hideImageCheckbox.setVisibility(visibility);
            saveParametersButton.setVisibility(visibility);
            loadParametersButton.setVisibility(visibility);
            switchCameraButton.setVisibility(visibility);
        });

        hideImageCheckbox.setOnCheckedChangeListener((buttonView, isChecked) -> {
            isImageVisible = !isChecked;
            updateImageDisplay();
        });

        saveParametersButton.setOnClickListener(v -> saveParameters());

        loadParametersButton.setOnClickListener(v -> loadParameters());

        switchCameraButton.setOnClickListener(v -> switchCamera());

        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.CAMERA}, REQUEST_CAMERA_PERMISSION);
        } else {
            isCameraPendingOpen = true;
        }

        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED ||
                ActivityCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE}, REQUEST_STORAGE_PERMISSION);
        }

        // Инициализация списка камер
        CameraManager manager = (CameraManager) getSystemService(CAMERA_SERVICE);
        try {
            cameraIds = manager.getCameraIdList();
            if (cameraIds.length > 0) {
                cameraId = cameraIds[0];
            }
        } catch (CameraAccessException e) {
            Log.e(TAG, "Error accessing camera list", e);
            Toast.makeText(this, "Cannot access cameras", Toast.LENGTH_LONG).show();
        }

        // Инициализация layerVisibility
        layerVisibility = new boolean[20];
        Arrays.fill(layerVisibility, true);
    }

    private void adjustSurfaceViewAspectRatioWithCropping(int width, int height) {
        if (previewSize == null) {
            return;
        }

        float previewRatio = (float) previewSize.getWidth() / previewSize.getHeight();
        float viewRatio = (float) width / height;

        int newWidth, newHeight;
        if (previewRatio > viewRatio) {
            newWidth = width;
            newHeight = (int) (width / previewRatio);
        } else {
            newHeight = height;
            newWidth = (int) (height * previewRatio);
        }

        ViewGroup.LayoutParams params = cameraSurfaceView.getLayoutParams();
        params.width = width;
        params.height = height;
        cameraSurfaceView.setLayoutParams(params);

        float scaleX = (float) width / newWidth;
        float scaleY = (float) height / newHeight;
        float scale = Math.max(scaleX, scaleY);

        cameraSurfaceView.setScaleX(scale);
        cameraSurfaceView.setScaleY(scale);

        cameraSurfaceView.setPivotX(width / 2f);
        cameraSurfaceView.setPivotY(height / 2f);

        cameraSurfaceView.requestLayout();
        Log.d(TAG, "Adjusted SurfaceView with cropping to " + width + "x" + height + " (preview ratio: " + previewRatio + ")");
    }

    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
        if (requestCode == REQUEST_CAMERA_PERMISSION) {
            if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                if (isSurfaceAvailable && !isCameraOpen) {
                    openCamera();
                } else {
                    isCameraPendingOpen = true;
                }
            } else {
                Toast.makeText(this, "Camera permission is required", Toast.LENGTH_LONG).show();
                finish();
            }
        } else if (requestCode == REQUEST_STORAGE_PERMISSION) {
            if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                // Разрешение получено
            } else {
                Toast.makeText(this, "Storage permission is required", Toast.LENGTH_LONG).show();
            }
        }
    }

    private void startBackgroundThread() {
        if (backgroundThread == null) {
            backgroundThread = new HandlerThread("CameraBackground");
            backgroundThread.start();
            backgroundHandler = new Handler(backgroundThread.getLooper());
        }
    }

    private void stopBackgroundThread() {
        if (backgroundThread != null) {
            backgroundThread.quitSafely();
            try {
                backgroundThread.join();
                backgroundThread = null;
                backgroundHandler = null;
            } catch (InterruptedException e) {
                Log.e(TAG, "Error stopping background thread", e);
            }
        }
    }

    private void openCamera() {
        if (!isSurfaceAvailable || isCameraOpen) {
            Log.d(TAG, "Surface not available or camera already open, setting pending open");
            isCameraPendingOpen = true;
            return;
        }

        startBackgroundThread();
        CameraManager manager = (CameraManager) getSystemService(CAMERA_SERVICE);
        try {
            if (cameraId == null) {
                cameraId = manager.getCameraIdList()[0];
            }
            CameraCharacteristics characteristics = manager.getCameraCharacteristics(cameraId);
            Size[] previewSizes = characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP)
                    .getOutputSizes(SurfaceHolder.class);
            previewSize = chooseOptimalPreviewSize(previewSizes, cameraSurfaceView.getWidth(), cameraSurfaceView.getHeight());

            if (ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {
                return;
            }
            cameraOpenCloseLock.acquire();
            isCameraOpen = true;
            manager.openCamera(cameraId, new CameraDevice.StateCallback() {
                @Override
                public void onOpened(@NonNull CameraDevice camera) {
                    cameraDevice = camera;
                    if (isSurfaceAvailable) {
                        createCameraPreviewSession();
                    } else {
                        Log.d(TAG, "Surface not available after camera opened, closing camera");
                        closeCamera();
                    }
                    cameraOpenCloseLock.release();
                }

                @Override
                public void onDisconnected(@NonNull CameraDevice camera) {
                    cameraOpenCloseLock.release();
                    camera.close();
                    cameraDevice = null;
                    isCameraOpen = false;
                }

                @Override
                public void onError(@NonNull CameraDevice camera, int error) {
                    cameraOpenCloseLock.release();
                    camera.close();
                    cameraDevice = null;
                    isCameraOpen = false;
                    Toast.makeText(MainActivity.this, "Camera error: " + error, Toast.LENGTH_LONG).show();
                }
            }, backgroundHandler);
        } catch (CameraAccessException e) {
            Log.e(TAG, "Cannot access camera", e);
            Toast.makeText(this, "Cannot access camera", Toast.LENGTH_LONG).show();
            isCameraOpen = false;
        } catch (InterruptedException e) {
            Log.e(TAG, "Interrupted while opening camera", e);
            cameraOpenCloseLock.release();
            isCameraOpen = false;
        }
    }

    private Size[] getPreviewSizes() {
        try {
            CameraManager manager = (CameraManager) getSystemService(CAMERA_SERVICE);
            CameraCharacteristics characteristics = manager.getCameraCharacteristics(cameraId);
            return characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP)
                    .getOutputSizes(SurfaceHolder.class);
        } catch (CameraAccessException e) {
            Log.e(TAG, "Error getting preview sizes", e);
            return new Size[]{new Size(1280, 720)};
        }
    }

    private Size chooseOptimalPreviewSize(Size[] choices, int viewWidth, int viewHeight) {
        if (choices == null || choices.length == 0) {
            Log.e(TAG, "No preview sizes available, using default");
            return new Size(1280, 720);
        }

        double targetRatio;
        if (viewWidth > 0 && viewHeight > 0) {
            targetRatio = (double) viewWidth / viewHeight;
        } else {
            targetRatio = 4.0 / 3.0;
        }

        Size optimalSize = null;
        double minDiff = Double.MAX_VALUE;
        int maxArea = 0;

        for (Size size : choices) {
            double ratio = (double) size.getWidth() / size.getHeight();
            int area = size.getWidth() * size.getHeight();
            double ratioDiff = Math.abs(ratio - targetRatio);
            if (ratioDiff < minDiff || (ratioDiff == minDiff && area > maxArea)) {
                optimalSize = size;
                minDiff = ratioDiff;
                maxArea = area;
            }
        }

        if (optimalSize == null) {
            optimalSize = choices[0];
        }

        Log.d(TAG, "Chosen preview size: " + optimalSize.getWidth() + "x" + optimalSize.getHeight());
        return optimalSize;
    }

    private void createCameraPreviewSession() {
        if (!isSurfaceAvailable || cameraDevice == null || !isCameraOpen) {
            Log.d(TAG, "Cannot create preview session: Surface not available, cameraDevice is null, or camera is closed");
            return;
        }

        try {
            SurfaceHolder holder = cameraSurfaceView.getHolder();
            Surface surface = holder.getSurface();
            if (!surface.isValid()) {
                Log.d(TAG, "Surface is not valid, aborting preview session creation");
                return;
            }

            previewRequestBuilder = cameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
            previewRequestBuilder.addTarget(surface);

            cameraDevice.createCaptureSession(Arrays.asList(surface), new CameraCaptureSession.StateCallback() {
                @Override
                public void onConfigured(@NonNull CameraCaptureSession session) {
                    if (cameraDevice == null || !isSurfaceAvailable || !isCameraOpen) {
                        Log.d(TAG, "Camera device closed, surface not available, or camera not open during session configuration");
                        session.close();
                        return;
                    }
                    cameraCaptureSession = session;
                    try {
                        previewRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);
                        cameraCaptureSession.setRepeatingRequest(previewRequestBuilder.build(), null, backgroundHandler);
                        Log.d(TAG, "Camera preview session started");
                    } catch (CameraAccessException e) {
                        Log.e(TAG, "Error setting up camera preview", e);
                    } catch (IllegalStateException e) {
                        Log.e(TAG, "Session already closed during setRepeatingRequest", e);
                    }
                }

                @Override
                public void onConfigureFailed(@NonNull CameraCaptureSession session) {
                    Toast.makeText(MainActivity.this, "Failed to configure camera preview", Toast.LENGTH_LONG).show();
                }
            }, backgroundHandler);
        } catch (CameraAccessException e) {
            Log.e(TAG, "Error creating camera preview session", e);
        }
    }

    private void closeCameraPreviewSession() {
        if (cameraCaptureSession != null) {
            cameraCaptureSession.close();
            cameraCaptureSession = null;
        }
    }

    private void closeCamera() {
        try {
            cameraOpenCloseLock.acquire();
            closeCameraPreviewSession();
            if (cameraDevice != null) {
                cameraDevice.close();
                cameraDevice = null;
            }
            isCameraOpen = false;
        } catch (InterruptedException e) {
            Log.e(TAG, "Error closing camera", e);
        } finally {
            cameraOpenCloseLock.release();
        }
        stopBackgroundThread();
    }

    private void switchCamera() {
        CameraManager manager = (CameraManager) getSystemService(CAMERA_SERVICE);
        try {
            closeCamera();
            currentCameraIndex = (currentCameraIndex + 1) % cameraIds.length;
            cameraId = cameraIds[currentCameraIndex];
            if (isSurfaceAvailable && !isCameraOpen) {
                openCamera();
            } else {
                isCameraPendingOpen = true;
            }
        } catch (Exception e) {
            Log.e(TAG, "Error switching camera", e);
            Toast.makeText(this, "Error switching camera", Toast.LENGTH_LONG).show();
        }
    }

    private void pickImage() {
        Intent intent = new Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI);
        startActivityForResult(intent, PICK_IMAGE_REQUEST);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if (requestCode == PICK_IMAGE_REQUEST && resultCode == RESULT_OK && data != null) {
            Uri imageUri = data.getData();
            try {
                if (originalBitmap != null && !originalBitmap.isRecycled()) {
                    originalBitmap.recycle();
                }
                originalBitmap = MediaStore.Images.Media.getBitmap(getContentResolver(), imageUri);
                resetTransformationsAndFit();
                layerVisibility = new boolean[20];
                Arrays.fill(layerVisibility, true);
                if (isPencilMode) {
                    processPencilEffect();
                }
                updateImageDisplay();
            } catch (IOException e) {
                Log.e(TAG, "Error loading image", e);
                Toast.makeText(this, "Error loading image", Toast.LENGTH_LONG).show();
            }
        }
    }

    private void resetTransformationsAndFit() {
        if (originalBitmap == null || imageView.getWidth() == 0 || imageView.getHeight() == 0) {
            matrix.reset();
            scaleFactor = 1.0f;
            rotationAngle = 0.0f;
            imageView.setImageMatrix(matrix);
            return;
        }

        matrix.reset();

        float viewWidth = imageView.getWidth();
        float viewHeight = imageView.getHeight();
        float bmpWidth = originalBitmap.getWidth();
        float bmpHeight = originalBitmap.getHeight();

        float scaleX = viewWidth / bmpWidth;
        float scaleY = viewHeight / bmpHeight;
        float initialScale = Math.min(scaleX, scaleY);

        float scaledBmpWidth = bmpWidth * initialScale;
        float scaledBmpHeight = bmpHeight * initialScale;
        float initialTranslateX = (viewWidth - scaledBmpWidth) / 2f;
        float initialTranslateY = (viewHeight - scaledBmpHeight) / 2f;

        matrix.postScale(initialScale, initialScale);
        matrix.postTranslate(initialTranslateX, initialTranslateY);

        imageView.post(() -> {
            imageView.setImageMatrix(matrix);
            imageView.invalidate();
            scaleFactor = initialScale;
            rotationAngle = 0.0f;
        });
    }

    private void applyTransformations() {
        imageView.setImageMatrix(matrix);
        imageView.invalidate();
        Log.d(TAG, "Transformations applied: scale=" + scaleFactor);
    }

    private void setImageAlpha(int progress) {
        float alpha = progress / 100.0f;
        imageView.setAlpha(alpha);
        imageView.invalidate();
        Log.d(TAG, "Image alpha set to: " + alpha);
    }

    private void processPencilEffect() {
        Log.d(TAG, "Processing pencil effect");
        if (originalBitmap == null) {
            Log.d(TAG, "Original bitmap is null, cannot process pencil effect");
            return;
        }

        if (pencilBitmap != null && !pencilBitmap.isRecycled()) {
            pencilBitmap.recycle();
            pencilBitmap = null;
        }
        if (layerBitmaps != null) {
            for (Bitmap layer : layerBitmaps) {
                if (layer != null && !layer.isRecycled()) {
                    layer.recycle();
                }
            }
            layerBitmaps = null;
        }

        try {
            pencilBitmap = Bitmap.createBitmap(originalBitmap.getWidth(), originalBitmap.getHeight(), Bitmap.Config.ARGB_8888);
            if (pencilBitmap == null) {
                Log.e(TAG, "Failed to create pencilBitmap");
                return;
            }
            Canvas canvas = new Canvas(pencilBitmap);
            Paint paint = new Paint();
            ColorMatrix colorMatrix = new ColorMatrix();
            colorMatrix.setSaturation(0);
            ColorMatrixColorFilter filter = new ColorMatrixColorFilter(colorMatrix);
            paint.setColorFilter(filter);
            canvas.drawBitmap(originalBitmap, 0, 0, paint);

            layerBitmaps = new Bitmap[20];
            for (int i = 0; i < 20; i++) {
                layerBitmaps[i] = Bitmap.createBitmap(originalBitmap.getWidth(), originalBitmap.getHeight(), Bitmap.Config.ARGB_8888);
                if (layerBitmaps[i] == null) {
                    Log.e(TAG, "Failed to create layerBitmap[" + i + "]");
                    return;
                }
                layerBitmaps[i].eraseColor(Color.TRANSPARENT);
            }

            int[] pixels = new int[originalBitmap.getWidth() * originalBitmap.getHeight()];
            pencilBitmap.getPixels(pixels, 0, originalBitmap.getWidth(), 0, 0, originalBitmap.getWidth(), originalBitmap.getHeight());

            for (int i = 0; i < pixels.length; i++) {
                int gray = Color.red(pixels[i]);
                int layerIndex = getLayerIndex(gray);
                if (layerIndex >= 0 && layerIndex < 20 && layerBitmaps[layerIndex] != null) {
                    layerBitmaps[layerIndex].setPixel(i % originalBitmap.getWidth(), i / originalBitmap.getWidth(), pixels[i]);
                }
            }
            Log.d(TAG, "Pencil effect processed successfully");
        } catch (OutOfMemoryError e) {
            Log.e(TAG, "OutOfMemoryError in processPencilEffect", e);
            Toast.makeText(this, "Not enough memory for pencil effect", Toast.LENGTH_LONG).show();
            pencilBitmap = null;
            layerBitmaps = null;
        }
    }

    private int getLayerIndex(int grayValue) {
        return grayValue / (256 / 20);
    }

    private void updateImageDisplay() {
        Log.d(TAG, "updateImageDisplay: isPencilMode=" + isPencilMode + ", isImageVisible=" + isImageVisible);
        if (originalBitmap == null || !isImageVisible) {
            Log.d(TAG, "updateImageDisplay: originalBitmap is null or image is not visible");
            imageView.setImageBitmap(null);
            imageView.setVisibility(View.INVISIBLE);
            imageView.invalidate();
            return;
        }

        if (isPencilMode) {
            Log.d(TAG, "updateImageDisplay: Processing pencil mode");
            if (pencilBitmap == null || layerBitmaps == null) {
                processPencilEffect();
            }

            if (pencilBitmap == null || layerBitmaps == null) {
                Log.d(TAG, "updateImageDisplay: pencilBitmap or layerBitmaps is null");
                imageView.setImageBitmap(null);
                imageView.setVisibility(View.INVISIBLE);
                imageView.invalidate();
                return;
            }

            Bitmap resultBitmap = Bitmap.createBitmap(originalBitmap.getWidth(), originalBitmap.getHeight(), Bitmap.Config.ARGB_8888);
            if (resultBitmap == null) {
                Log.d(TAG, "updateImageDisplay: Failed to create resultBitmap");
                imageView.setImageBitmap(null);
                imageView.setVisibility(View.INVISIBLE);
                imageView.invalidate();
                return;
            }
            Canvas canvas = new Canvas(resultBitmap);
            canvas.drawColor(Color.TRANSPARENT);

            for (int i = 0; i < layerBitmaps.length; i++) {
                if (layerVisibility[i] && layerBitmaps[i] != null && !layerBitmaps[i].isRecycled()) {
                    canvas.drawBitmap(layerBitmaps[i], 0, 0, null);
                }
            }

            imageView.setImageBitmap(resultBitmap);
            setImageAlpha(transparencySeekBar.getProgress());
            imageView.setVisibility(View.VISIBLE);
            imageView.post(() -> {
                imageView.setImageMatrix(matrix);
                imageView.invalidate();
            });
            Log.d(TAG, "updateImageDisplay: Pencil mode applied");
        } else {
            Log.d(TAG, "updateImageDisplay: Displaying original bitmap");
            imageView.setImageBitmap(originalBitmap);
            setImageAlpha(transparencySeekBar.getProgress());
            imageView.setVisibility(View.VISIBLE);
            imageView.post(() -> {
                imageView.setImageMatrix(matrix);
                imageView.invalidate();
            });
            Log.d(TAG, "updateImageDisplay: Original bitmap displayed");
        }
    }

    private void showLayerSelectionDialog() {
        Dialog dialog = new Dialog(this);
        dialog.setContentView(R.layout.dialog_layer_selection);
        dialog.setTitle(R.string.layer_selection_title);

        RecyclerView recyclerView = dialog.findViewById(R.id.layerRecyclerView);
        recyclerView.setLayoutManager(new LinearLayoutManager(this));
        LayerAdapter adapter = new LayerAdapter(PENCIL_HARDNESS, layerVisibility, this);
        recyclerView.setAdapter(adapter);

        dialog.show();
    }

    @Override
    public void onLayerVisibilityChanged(int position, boolean isVisible) {
        layerVisibility[position] = isVisible;
        updateImageDisplay();
    }

    private void saveParameters() {
        try {
            File file = new File(getFilesDir(), "parameters.dat");
            FileOutputStream fos = new FileOutputStream(file);
            fos.write(Float.toString(scaleFactor).getBytes());
            fos.write("\n".getBytes());
            fos.write(Float.toString(rotationAngle).getBytes());
            fos.write("\n".getBytes());
            float[] matrixValues = new float[9];
            matrix.getValues(matrixValues);
            for (float value : matrixValues) {
                fos.write(Float.toString(value).getBytes());
                fos.write(" ".getBytes());
            }
            fos.write("\n".getBytes());
            fos.write(String.valueOf(isPencilMode).getBytes());
            fos.write("\n".getBytes());
            for (boolean visible : layerVisibility) {
                fos.write(String.valueOf(visible).getBytes());
                fos.write(" ".getBytes());
            }
            fos.close();
            Toast.makeText(this, "Parameters saved", Toast.LENGTH_SHORT).show();
        } catch (IOException e) {
            Log.e(TAG, "Error saving parameters", e);
            Toast.makeText(this, "Error saving parameters", Toast.LENGTH_LONG).show();
        }
    }

    private void loadParameters() {
        try {
            File file = new File(getFilesDir(), "parameters.dat");
            if (!file.exists()) {
                Toast.makeText(this, "No saved parameters found", Toast.LENGTH_SHORT).show();
                return;
            }
            FileInputStream fis = new FileInputStream(file);
            byte[] buffer = new byte[(int) file.length()];
            fis.read(buffer);
            fis.close();
            String[] lines = new String(buffer).split("\n");
            if (lines.length < 4) {
                Toast.makeText(this, "Invalid parameters file", Toast.LENGTH_LONG).show();
                return;
            }
            scaleFactor = Float.parseFloat(lines[0]);
            rotationAngle = Float.parseFloat(lines[1]);
            String[] matrixValues = lines[2].split(" ");
            float[] values = new float[9];
            for (int i = 0; i < 9; i++) {
                values[i] = Float.parseFloat(matrixValues[i]);
            }
            matrix.setValues(values);
            isPencilMode = Boolean.parseBoolean(lines[3]);
            pencilModeSwitch.setChecked(isPencilMode);
            String[] visibilityValues = lines[4].split(" ");
            for (int i = 0; i < layerVisibility.length; i++) {
                layerVisibility[i] = Boolean.parseBoolean(visibilityValues[i]);
            }
            applyTransformations();
            updateImageDisplay();
            Toast.makeText(this, "Parameters loaded", Toast.LENGTH_SHORT).show();
        } catch (IOException | NumberFormatException e) {
            Log.e(TAG, "Error loading parameters", e);
            Toast.makeText(this, "Error loading parameters", Toast.LENGTH_LONG).show();
        }
    }

    @Override
    protected void onResume() {
        super.onResume();
        if (isSurfaceAvailable && !isCameraOpen) {
            openCamera();
        } else {
            isCameraPendingOpen = true;
        }
    }

    @Override
    protected void onPause() {
        closeCamera();
        super.onPause();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        if (originalBitmap != null && !originalBitmap.isRecycled()) {
            originalBitmap.recycle();
            originalBitmap = null;
        }
        if (pencilBitmap != null && !pencilBitmap.isRecycled()) {
            pencilBitmap.recycle();
            pencilBitmap = null;
        }
        if (layerBitmaps != null) {
            for (Bitmap layer : layerBitmaps) {
                if (layer != null && !layer.isRecycled()) {
                    layer.recycle();
                }
            }
            layerBitmaps = null;
        }
    }

    @Override
    public void onConfigurationChanged(@NonNull Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        resetTransformationsAndFit();
        updateImageDisplay();
    }
}

# app/src/main/res/drawable/ic_open_arrow.png
PNG

   IHDR         \rf   sRGB    gAMA  a   	pHYs    od  xIDATx^+I˕HJ$D"H$D"HJ$9=UsGnVfWDt<z'>J&Z7D$O_=oI3~I_%7/?% Xg[?
t,?ϒ"7Hn J|;
OT2K]]_ ĕ-X-J9 ѯ/QI:G7nq+sTQ*H7$7%/~K$
[-,9t+ῢݗ!_)yGC AşY ]yT$o8
3}.Z4?S5F]hY%&x{sc{IR oI(E7MiP*%Q 0;w`|[,ޤ2CUxCsH@.K[1q=xSF6PRz(18qTvޥ$tBF\*c`BpE,QD*kmxQ}2
C/,p@AF(T~t+_5{51\1T~tR6k:ʏp@GPhZ I5#4
sҵnOal?J<w	D¬>4t-y!K5Ļ T>/-΋ V/1Ȋ6,/zDt3'hEY:forqWʌd|
j+x||W?.}ĎDg 	ZK|=Uz/.QpCȳw'I?}wui6|ggk?'&d%BxȜg8㛽ҟoQYxac	o{v7i^;9D!XP׹XE=Uch|kp%f߷Os?`!O6qz?[n7Nd%?* {9{KξQe݄$/=.03#çJ㥞|O!H5Gn[Ugs6gW;Gawx-q7pC2gedXiq xS4N/+qzVַ$d.ǽ#_"oy;yr]}zgr6$`+J1LBr^4XEsFI-\ Fz"3^}^_ȬA0Qk7&wNYqwf$'Jܹx ٯspITm(Enj/*=ʿ-4$t7q\*h&H^y)p8OϣF`N0j?=]}T|pggA3-DtF\&yoOİ;'zpvCf_7#@<+=[oA[گ1Ńs	1.;? S~tȘq2mCɟ>8Org	ɛ3=䅡dXPɟ̰I F
)jЃ~}c]z}J>9GZ.y-vɾa@'cq.@ R"3[^K{}̎G'u=xvęWf/]o*zojua۱#ɓn'}}ual嘀{~w]B>[:@mmwJ~xW[=
?p+Itx﫿pC+K~t5.`fYd8fԲU$?|0W1DD%?!;h7?\ɏ.{o2p{ʒ])F`\ɏW:K}p~AS;ca,$/"|rv*v&tӻ Lqe*yd|;G`4VʒMNwx`@I>4FnO8`2+CEmj_ y~"T[開- ɇfqO2T|hjn~A򢉻]s|h"O6`SQI>41`'}\OC95ZhҳWRYDcܰN$R>ˍ`Sm,SQ!7	@a0IH׋v1`y{7	vN v9l%Ö `InW*yr nWSHGCA)N ,M݃Az Ҕ_$D\"I63$Rvk#4O&k9$RmeI ZL6'sSQxUJ9OւD`ݶ|0, kRzX#}{r X3uf2MT1HkoC' [; ڔ1HXzA ][->-(8?E?lEIA:9)U*h ST1翷a[<`b	~(bT?Eja(E | fV&Wh  X ⯨bTΟ4OQE: (@[QzF?V UJl IT)*i&QD jUJl IT)*i&QD jUJl IT)*i&QD jUJl IT)*i&QD jUJl IT)*i&QD jUJl IT)*i&Qx&=JQȓy]?/ΗAJevx{хps%]A>sAt*-q?|@Rht&'q?L|@'RYEh\*C~KeGWC>Q܈a4&q?
F"!ЀTFKCB> T6
IeBA> T:H@@>`caSl$yOC>`s~H%!V&XXB>`A[~H$_	,yJMA>`&K~h3HCR|w&JC7 yEA>`q?t	3G5NHC$O$?~(I|< ܉<e:o~ Q.s&C|Ε #q?	|΍`tN #*s!H7 q?49\A ;q?41Ds /q?4б,@|`!Rtl 6"Xt q?XV&E>@@ Y>@ML~$g$c|> ! Y,&H" 'q?@#̞4l q?@\{4U q.u 09t|Kzq?@q~9c p Ÿ'q?@AJ??lb    IENDB`
# app/src/main/res/layout/activity_main.xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <SurfaceView
        android:id="@+id/cameraSurfaceView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_centerInParent="true" />

    <ImageView
        android:id="@+id/imageView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_centerInParent="true" />

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_alignParentBottom="true"
        android:orientation="vertical"
        android:padding="10dp">

        <SeekBar
            android:id="@+id/transparencySeekBar"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:max="100"
            android:progress="100" />

        <Button
            android:id="@+id/pickImageButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/pick_image" />

        <Switch
            android:id="@+id/pencilModeSwitch"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/pencil_mode" />

        <Button
            android:id="@+id/layerSelectButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/select_layers"
            android:visibility="gone" />

        <CheckBox
            android:id="@+id/controlsVisibilityCheckbox"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/show_controls"
            android:checked="true" />

        <CheckBox
            android:id="@+id/hideImageCheckbox"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/hide_image" />

        <Button
            android:id="@+id/saveParametersButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/save_parameters" />

        <Button
            android:id="@+id/loadParametersButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/load_parameters" />

        <Button
            android:id="@+id/switchCameraButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/switch_camera" />
    </LinearLayout>

</RelativeLayout>

# app/src/main/res/layout/dialog_layer_selection.xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="wrap_content">
<!-- Это тестовое изменение -->
    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/recyclerView"
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />

</androidx.constraintlayout.widget.ConstraintLayout>

# app/src/main/res/layout/item_layer.xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:padding="8dp">

    <TextView
        android:id="@+id/layerText"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:textSize="16sp" />

    <CheckBox
        android:id="@+id/layerCheckBox"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" />
</LinearLayout>

# app/src/main/res/mipmap-hdpi/ic_launcher.png
PNG

   IHDR   H   H   o#!   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  {ܙ,   bKGD-   tIME(`   IDAT(c``   _   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`
# app/src/main/res/mipmap-hdpi/ic_launcher_round.png
PNG

   IHDR   H   H   o#!   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  ?/O   bKGD-   tIME(`   IDAT(c``   _   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`
# app/src/main/res/mipmap-mdpi/ic_launcher.png
PNG

   IHDR   0   0   mk   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  {ܙ,   bKGD-   tIME'N|   IDATc` P    %tEXtdate:create 2025-04-27T16:18:39+00:00s   %tEXtdate:modify 2025-04-27T16:18:39+00:00Aq    IENDB`
# app/src/main/res/mipmap-mdpi/ic_launcher_round.png
PNG

   IHDR   0   0   mk   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  ?/O   bKGD-   tIME(`   IDATc` P    %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`
# app/src/main/res/mipmap-xhdpi/ic_launcher.png
PNG

   IHDR   `   `   V{   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  {ܙ,   bKGD-   tIME(`   IDAT8c``	  t   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`
# app/src/main/res/mipmap-xhdpi/ic_launcher_round.png
PNG

   IHDR   `   `   V{   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  ?/O   bKGD-   tIME(`   IDAT8c``	  t   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`
# app/src/main/res/mipmap-xxhdpi/ic_launcher.png
PNG

   IHDR         ݈p   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  {ܙ,   bKGD-   tIME(`   IDATH1    Om   
 >4   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`
# app/src/main/res/mipmap-xxhdpi/ic_launcher_round.png
PNG

   IHDR         ݈p   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  ?/O   bKGD-   tIME(`   IDATH1    Om   
 >4   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`
# app/src/main/res/mipmap-xxxhdpi/ic_launcher.png
PNG

   IHDR         hD   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  {ܙ,   bKGD-   tIME(`   IDATX1    Om      R   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`
# app/src/main/res/mipmap-xxxhdpi/ic_launcher_round.png
PNG

   IHDR         hD   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  ?/O   bKGD-   tIME)g{   IDATX1    Om      R   %tEXtdate:create 2025-04-27T16:18:41+00:00J6P   %tEXtdate:modify 2025-04-27T16:18:41+00:00;k    IENDB`
# app/src/main/res/values/strings.xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">HelloWorld</string>
    <string name="pick_image">Pick Image</string>
    <string name="show_controls">Show Controls</string>
    <string name="pencil_mode">Pencil Mode</string>
    <string name="select_layers">Select Layers</string>
    <string name="hide_image">Hide Image</string>
    <string name="save_parameters">Save Parameters</string>
    <string name="load_parameters">Load Parameters</string>
    <string name="switch_camera">Switch Camera</string>
    <string name="layer_selection_title">Select Pencil Layers</string>
</resources>

# app/src/main/res/values/themes.xml
<?xml version="1.0" encoding="utf-8"?>
<resources xmlns:tools="http://schemas.android.com/tools">
    <style name="Theme.HelloWorld" parent="Theme.AppCompat.Light.DarkActionBar">
        <item name="colorPrimary">@android:color/black</item>
        <item name="colorPrimaryDark">@android:color/black</item>
        <item name="colorAccent">@android:color/holo_blue_light</item>
    </style>
</resources>

# app/src/main/res/xml/backup_rules.xml
<?xml version="1.0" encoding="utf-8"?>
<full-backup-content>
    <include domain="file" path="." />
</full-backup-content>

# app/src/main/res/xml/data_extraction_rules.xml
<?xml version="1.0" encoding="utf-8"?>
<data-extraction-rules>
    <cloud-backup>
        <include domain="file" />
    </cloud-backup>
</data-extraction-rules>

# app/src/main/AndroidManifest.xml:
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">

    <!-- Разрешения -->
    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.READ_MEDIA_IMAGES" />

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.HelloWorld">
        <activity
            android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>

# app/build.gradle
plugins {
    id 'com.android.application'
    id 'org.jetbrains.kotlin.android'
}

android {
    namespace 'com.example.helloworld' // Added namespace
    compileSdk 34

    defaultConfig {
        applicationId "com.example.helloworld"
        minSdk 24
        targetSdk 34
        versionCode 1
        versionName "1.0"
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_17
        targetCompatibility JavaVersion.VERSION_17
    }
    kotlinOptions {
        jvmTarget = '17'
    }
}

dependencies {
    implementation 'androidx.core:core-ktx:1.12.0'
    implementation 'androidx.appcompat:appcompat:1.6.1'
    implementation 'com.google.android.material:material:1.10.0'
    implementation 'androidx.constraintlayout:constraintlayout:2.1.4'
}

# app/src/main/AndroidManifest.xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.helloworld">

    <uses-permission android:name="android.permission.CAMERA"/>
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
    <uses-permission android:name="android.permission.READ_MEDIA_IMAGES"/>

    <uses-feature android:name="android.hardware.camera" android:required="true"/>

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.HelloWorld">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:configChanges="orientation|screenSize">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>

# app/src/main/java/com/example/helloworld/LayerAdapter.java
package com.example.helloworld;

import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.CheckBox; // Используем CheckBox
import android.widget.TextView;  // Используем TextView
import androidx.annotation.NonNull;
import androidx.recyclerview.widget.RecyclerView;

public class LayerAdapter extends RecyclerView.Adapter<LayerAdapter.ViewHolder> {

    private final String[] layers;
    private final boolean[] visibility;
    private final OnLayerVisibilityChangedListener listener;

    // Интерфейс для обратного вызова при изменении видимости слоя
    public interface OnLayerVisibilityChangedListener {
        void onLayerVisibilityChanged(int position, boolean isVisible);
    }

    // Конструктор адаптера
    public LayerAdapter(String[] layers, boolean[] visibility, OnLayerVisibilityChangedListener listener) {
        this.layers = layers;
        this.visibility = visibility;
        this.listener = listener;
    }

    // Создание нового ViewHolder (используем item_layer.xml)
    @NonNull
    @Override
    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        // Используем ваш кастомный макет item_layer.xml
        View view = LayoutInflater.from(parent.getContext())
                .inflate(R.layout.item_layer, parent, false); // *** ИЗМЕНЕНО ЗДЕСЬ ***
        return new ViewHolder(view);
    }

    // Привязка данных к ViewHolder
    @Override
    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
        // Устанавливаем текст слоя в TextView
        holder.layerText.setText(layers[position]); // *** ИЗМЕНЕНО ЗДЕСЬ ***

        // Сначала удаляем слушатель, чтобы он не сработал при установке состояния
        holder.layerCheckBox.setOnCheckedChangeListener(null);
        // Устанавливаем состояние CheckBox
        holder.layerCheckBox.setChecked(visibility[position]); // *** ИЗМЕНЕНО ЗДЕСЬ ***

        // Устанавливаем слушатель изменения состояния CheckBox
        holder.layerCheckBox.setOnCheckedChangeListener((buttonView, isChecked) -> { // *** ИЗМЕНЕНО ЗДЕСЬ ***
            // Обновляем массив видимости
            int currentPosition = holder.getAdapterPosition(); // Получаем актуальную позицию
             if (currentPosition != RecyclerView.NO_POSITION) { // Проверяем, что позиция валидна
                 visibility[currentPosition] = isChecked;
                 // Уведомляем MainActivity через интерфейс
                 if (listener != null) {
                     listener.onLayerVisibilityChanged(currentPosition, isChecked);
                 }
             }
        });
    }

    // Возвращаем общее количество элементов
    @Override
    public int getItemCount() {
        // Проверяем на null на всякий случай
        return (layers != null) ? layers.length : 0;
    }

    // Класс ViewHolder, хранящий ссылки на View одного элемента списка
    static class ViewHolder extends RecyclerView.ViewHolder {
        TextView layerText;     // *** ИЗМЕНЕНО ЗДЕСЬ *** Ссылка на TextView из item_layer.xml
        CheckBox layerCheckBox; // *** ИЗМЕНЕНО ЗДЕСЬ *** Ссылка на CheckBox из item_layer.xml

        ViewHolder(View itemView) {
            super(itemView);
            // Находим View по их ID из item_layer.xml
            layerText = itemView.findViewById(R.id.layerText);       // *** ИЗМЕНЕНО ЗДЕСЬ ***
            layerCheckBox = itemView.findViewById(R.id.layerCheckBox); // *** ИЗМЕНЕНО ЗДЕСЬ ***
        }
    }
}

# app/src/main/java/com/example/helloworld/MainActivity.java
package com.example.helloworld;

import android.Manifest;
import android.app.Activity;
import android.app.Dialog;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.res.Configuration;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.ColorMatrix;
import android.graphics.ColorMatrixColorFilter;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.graphics.PointF;
// import android.graphics.SurfaceTexture; // Не используется напрямую
import android.hardware.camera2.CameraAccessException;
import android.hardware.camera2.CameraCaptureSession;
import android.hardware.camera2.CameraCharacteristics;
import android.hardware.camera2.CameraDevice;
import android.hardware.camera2.CameraManager;
import android.hardware.camera2.CaptureRequest;
import android.hardware.camera2.params.StreamConfigurationMap;
import android.hardware.display.DisplayManager;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.os.HandlerThread;
import android.provider.MediaStore;
import android.util.Log;
import android.util.Size;
import android.view.Display;
import android.view.MotionEvent;
import android.view.ScaleGestureDetector;
import android.view.Surface;
import android.view.SurfaceHolder;
import android.view.SurfaceView;
import android.view.View;
// import android.view.ViewGroup;
import android.view.WindowInsets;
import android.view.WindowInsetsController;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.ImageView;
import android.widget.SeekBar;
import android.widget.Switch;
import android.widget.Toast;

import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.contract.ActivityResultContracts;
import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import org.json.JSONArray;
import org.json.JSONObject;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

public class MainActivity extends AppCompatActivity implements SurfaceHolder.Callback, LayerAdapter.OnLayerVisibilityChangedListener {

    private static final String TAG = "MainActivity";
    private static final int CAMERA_PERMISSION_CODE = 100;
    private static final int STORAGE_PERMISSION_CODE = 101;
    private static final int WRITE_STORAGE_PERMISSION_CODE = 102;

    // Ключи для сохранения состояния
    private static final String KEY_IMAGE_URI = "imageUri";
    private static final String KEY_MATRIX_VALUES = "matrixValues";
    private static final String KEY_CONTROLS_VISIBLE = "controlsVisible";
    private static final String KEY_IMAGE_VISIBLE = "imageVisible";
    private static final String KEY_PENCIL_MODE = "isPencilMode";
    private static final String KEY_LAYER_VISIBILITY = "layerVisibility";
    private static final String KEY_CURRENT_CAMERA_ID = "currentCameraId";


    // UI элементы
    private ImageView imageView;
    private SeekBar transparencySeekBar;
    private Button pickImageButton;
    private SurfaceView cameraSurfaceView;
    private SurfaceHolder cameraSurfaceHolder;
    private CheckBox controlsVisibilityCheckbox;
    private Switch pencilModeSwitch;
    private Button layerSelectButton;
    private CheckBox hideImageCheckbox;
    private Button saveParametersButton;
    private Button loadParametersButton;
    private Button switchCameraButton;

    // Camera2 API
    private CameraManager cameraManager;
    private CameraDevice cameraDevice;
    private CameraCaptureSession cameraCaptureSession;
    private CaptureRequest.Builder previewRequestBuilder;
    private String[] cameraIds;
    private String currentCameraId;
    private List<String> rearCameraIds = new ArrayList<>();
    private int currentRearCameraIndex = 0;
    private final ExecutorService cameraExecutor = Executors.newSingleThreadExecutor();
    private HandlerThread backgroundThread;
    private Handler backgroundHandler;
    private final Semaphore cameraOpenCloseLock = new Semaphore(1, true);
    private volatile boolean isSurfaceAvailable = false;
    private volatile boolean isCameraOpen = false;
    private Size previewSize;

    // Манипуляции с изображением
    private Bitmap originalBitmap = null;
    private Matrix matrix = new Matrix();
    private float scaleFactor = 1.0f; // Глобальный масштаб для ScaleListener
    private Uri currentImageUri;

    // Карандашный режим
    private boolean isPencilMode = false;
    private Bitmap pencilBitmap;
    private Bitmap[] layerBitmaps;
    private boolean[] layerVisibility = new boolean[20];
    private static final String[] PENCIL_HARDNESS = {
            "9H", "8H", "7H", "6H", "5H", "4H", "3H", "2H", "H", "F",
            "HB", "B", "2B", "3B", "4B", "5B", "6B", "7B", "8B", "9B"
    };

    // Управление видимостью изображения
    private boolean isImageVisible = true;

    // Распознавание жестов
    private ScaleGestureDetector scaleGestureDetector;
    private static final int NONE = 0;
    private static final int DRAG = 1;
    private static final int ZOOM = 2;
    private int touchMode = NONE;
    private final PointF lastTouchPoint = new PointF();
    private final PointF midPoint = new PointF();
    private float initialAngle = 0f;
    private final Matrix savedMatrix = new Matrix();


    // Activity Result API
    private ActivityResultLauncher<Intent> imagePickerLauncher;
    private ActivityResultLauncher<Intent> saveFileLauncher;
    private ActivityResultLauncher<Intent> loadFileLauncher;

    private final ExecutorService imageLoadExecutor = Executors.newSingleThreadExecutor();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        hideSystemUI();

        initializeUI();
        setupListeners();

        scaleGestureDetector = new ScaleGestureDetector(this, new ScaleListener());
        imageView.setOnTouchListener(new TouchAndGestureListener());

        cameraSurfaceHolder = cameraSurfaceView.getHolder();
        cameraSurfaceHolder.addCallback(this);

        cameraManager = (CameraManager) getSystemService(Context.CAMERA_SERVICE);
        if (cameraManager == null) {
            Log.e(TAG, "CameraManager is null! Cannot proceed.");
            Toast.makeText(this, "Camera service not available.", Toast.LENGTH_LONG).show();
            finish();
            return;
        }
        setupCameraSelector();

        checkAndRequestPermissions();

        if (savedInstanceState != null) {
            restoreInstanceState(savedInstanceState);
        } else {
            Arrays.fill(layerVisibility, true);
            updateControlsVisibility(controlsVisibilityCheckbox.isChecked());
            updateImageDisplay();
        }
    }

    // --- Инициализация UI и Слушателей ---
    private void initializeUI() {
        imageView = findViewById(R.id.imageView);
        transparencySeekBar = findViewById(R.id.transparencySeekBar);
        pickImageButton = findViewById(R.id.pickImageButton);
        cameraSurfaceView = findViewById(R.id.cameraSurfaceView);
        controlsVisibilityCheckbox = findViewById(R.id.controlsVisibilityCheckbox);
        pencilModeSwitch = findViewById(R.id.pencilModeSwitch);
        layerSelectButton = findViewById(R.id.layerSelectButton);
        hideImageCheckbox = findViewById(R.id.hideImageCheckbox);
        saveParametersButton = findViewById(R.id.saveParametersButton);
        loadParametersButton = findViewById(R.id.loadParametersButton);
        switchCameraButton = findViewById(R.id.switchCameraButton);
        imageView.setScaleType(ImageView.ScaleType.MATRIX);
    }

    private void setupListeners() {
        imagePickerLauncher = registerForActivityResult(
                new ActivityResultContracts.StartActivityForResult(),
                result -> {
                    if (result.getResultCode() == Activity.RESULT_OK && result.getData() != null) {
                        Uri selectedImageUri = result.getData().getData();
                        if (selectedImageUri != null) {
                            currentImageUri = selectedImageUri;
                            Log.d(TAG, "Image selected: " + currentImageUri);
                            loadImage(currentImageUri);
                        }
                    } else {
                        Log.w(TAG, "Image selection cancelled or failed. ResultCode: " + result.getResultCode());
                    }
                }
        );

        saveFileLauncher = registerForActivityResult(
                new ActivityResultContracts.StartActivityForResult(),
                result -> {
                    if (result.getResultCode() == Activity.RESULT_OK && result.getData() != null) {
                        Uri uri = result.getData().getData();
                        if (uri != null) {
                            saveParametersToFile(uri);
                        }
                    }
                }
        );

        loadFileLauncher = registerForActivityResult(
                new ActivityResultContracts.StartActivityForResult(),
                result -> {
                    if (result.getResultCode() == Activity.RESULT_OK && result.getData() != null) {
                        Uri uri = result.getData().getData();
                        if (uri != null) {
                            loadParametersFromFile(uri);
                        }
                    }
                }
        );

        pickImageButton.setOnClickListener(v -> checkPermissionAndPickImage());
        transparencySeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
            @Override
            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
                setImageAlpha(progress);
            }
            @Override public void onStartTrackingTouch(SeekBar seekBar) {}
            @Override public void onStopTrackingTouch(SeekBar seekBar) {}
        });
        controlsVisibilityCheckbox.setOnCheckedChangeListener((buttonView, isChecked) -> updateControlsVisibility(isChecked));
        pencilModeSwitch.setOnCheckedChangeListener((buttonView, isChecked) -> {
            isPencilMode = isChecked;
            layerSelectButton.setVisibility(isChecked ? View.VISIBLE : View.GONE);
            if (isPencilMode && originalBitmap != null && !originalBitmap.isRecycled()) {
                imageLoadExecutor.submit(this::processPencilEffect);
            } else {
                recyclePencilBitmaps();
                updateImageDisplay();
            }
        });
        layerSelectButton.setOnClickListener(v -> showLayerSelectionDialog());
        hideImageCheckbox.setOnCheckedChangeListener((buttonView, isChecked) -> {
            isImageVisible = !isChecked;
            updateImageDisplay();
        });
        saveParametersButton.setOnClickListener(v -> checkPermissionAndSaveParameters());
        loadParametersButton.setOnClickListener(v -> checkPermissionAndLoadParameters());
        switchCameraButton.setOnClickListener(v -> switchCamera());
    }

    // --- Управление UI ---
    private void hideSystemUI() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            getWindow().setDecorFitsSystemWindows(false);
            WindowInsetsController controller = getWindow().getInsetsController();
            if (controller != null) {
                controller.hide(WindowInsets.Type.statusBars() | WindowInsets.Type.navigationBars());
                controller.setSystemBarsBehavior(WindowInsetsController.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE);
            } else {
                // Fallback
                //noinspection deprecation
                getWindow().getDecorView().setSystemUiVisibility(
                        View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY
                                | View.SYSTEM_UI_FLAG_LAYOUT_STABLE
                                | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
                                | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
                                | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
                                | View.SYSTEM_UI_FLAG_FULLSCREEN);
            }
        } else {
            //noinspection deprecation
            getWindow().getDecorView().setSystemUiVisibility(
                    View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY
                            | View.SYSTEM_UI_FLAG_LAYOUT_STABLE
                            | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
                            | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
                            | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
                            | View.SYSTEM_UI_FLAG_FULLSCREEN);
        }
        if (getSupportActionBar() != null) {
            getSupportActionBar().hide();
        }
    }

    private void updateControlsVisibility(boolean show) {
        int visibility = show ? View.VISIBLE : View.GONE;
        pickImageButton.setVisibility(visibility);
        transparencySeekBar.setVisibility(visibility);
        pencilModeSwitch.setVisibility(visibility);
        layerSelectButton.setVisibility(show && isPencilMode ? View.VISIBLE : View.GONE);
        saveParametersButton.setVisibility(visibility);
        loadParametersButton.setVisibility(visibility);
        hideImageCheckbox.setVisibility(visibility);
        switchCameraButton.setVisibility(show && rearCameraIds != null && rearCameraIds.size() > 1 ? View.VISIBLE : View.GONE);
        controlsVisibilityCheckbox.setVisibility(View.VISIBLE);
        Log.d(TAG, "Controls visibility updated: " + (show ? "VISIBLE" : "GONE"));
    }

    // --- Управление Разрешениями ---
    private void checkAndRequestPermissions() {
        List<String> permissionsNeeded = new ArrayList<>();
        if (ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {
            permissionsNeeded.add(Manifest.permission.CAMERA);
        }
        String storagePermission = null;
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            storagePermission = Manifest.permission.READ_MEDIA_IMAGES;
        } else {
            storagePermission = Manifest.permission.READ_EXTERNAL_STORAGE;
        }
        if (storagePermission != null && ContextCompat.checkSelfPermission(this, storagePermission) != PackageManager.PERMISSION_GRANTED) {
            permissionsNeeded.add(storagePermission);
        }

        if (!permissionsNeeded.isEmpty()) {
            Log.d(TAG, "Requesting permissions: " + permissionsNeeded);
            ActivityCompat.requestPermissions(this, permissionsNeeded.toArray(new String[0]), CAMERA_PERMISSION_CODE);
        } else {
            Log.d(TAG, "All necessary permissions already granted.");
            if (cameraIds == null) setupCameraSelector();
            if (!isCameraOpen && cameraSurfaceHolder != null && cameraSurfaceHolder.getSurface() != null && cameraSurfaceHolder.getSurface().isValid()) {
                openCamera();
            }
        }
    }
    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
        boolean cameraGranted = ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED;
        boolean storageGranted = false;
        String storagePermission = Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU ? Manifest.permission.READ_MEDIA_IMAGES : Manifest.permission.READ_EXTERNAL_STORAGE;
        if (ContextCompat.checkSelfPermission(this, storagePermission) == PackageManager.PERMISSION_GRANTED) {
            storageGranted = true;
        }

        if (requestCode == CAMERA_PERMISSION_CODE) {
            if (cameraGranted) {
                Log.d(TAG, "Camera permission granted via request result.");
                if (cameraIds == null) setupCameraSelector();
                openCamera();
            } else {
                Toast.makeText(this, "Camera Permission is Required", Toast.LENGTH_SHORT).show();
            }
            if (!storageGranted) {
                Log.d(TAG, "Storage permission still denied after request.");
            }
        }
    }

    // --- Логика Камеры (Camera2 API) ---
    private void setupCameraSelector() {
        if (cameraManager == null) return;
        try {
            cameraIds = cameraManager.getCameraIdList();
            rearCameraIds.clear();
            String firstBackCameraId = null;

            for (String id : cameraIds) {
                CameraCharacteristics characteristics = cameraManager.getCameraCharacteristics(id);
                Integer facing = characteristics.get(CameraCharacteristics.LENS_FACING);
                if (facing != null && facing == CameraCharacteristics.LENS_FACING_BACK) {
                    rearCameraIds.add(id);
                    if (firstBackCameraId == null) firstBackCameraId = id;
                    logCameraCharacteristics(id);
                }
            }

            if (!rearCameraIds.isEmpty()) {
                currentCameraId = firstBackCameraId;
                currentRearCameraIndex = rearCameraIds.indexOf(currentCameraId);
                Log.d(TAG, "Found " + rearCameraIds.size() + " rear cameras. Defaulting to: " + currentCameraId);
            } else if (cameraIds.length > 0) {
                currentCameraId = cameraIds[0];
                currentRearCameraIndex = -1;
                Log.w(TAG, "No rear cameras found, defaulting to first available camera: " + currentCameraId);
            } else {
                Log.e(TAG, "No cameras available.");
                Toast.makeText(this, "No cameras found on this device", Toast.LENGTH_LONG).show();
                currentCameraId = null;
            }

            // Обновляем видимость кнопки переключения
            runOnUiThread(() -> switchCameraButton.setVisibility(rearCameraIds != null && rearCameraIds.size() > 1 ? View.VISIBLE : View.GONE));

        } catch (CameraAccessException e) {
            Log.e(TAG, "Error accessing camera characteristics during setup", e);
            Toast.makeText(this, "Cannot access cameras: " + e.getMessage(), Toast.LENGTH_LONG).show();
        }
    }

    private void logCameraCharacteristics(String camId) {
        try {
            CameraCharacteristics characteristics = cameraManager.getCameraCharacteristics(camId);
            StreamConfigurationMap map = characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
            if (map != null) {
                Size[] outputSizes = map.getOutputSizes(SurfaceHolder.class);
                Log.d(TAG, "Camera " + camId + ": Preview Sizes (SurfaceHolder): " + Arrays.toString(outputSizes));
            } else {
                Log.w(TAG, "Camera " + camId + ": StreamConfigurationMap is null");
            }
            Integer facing = characteristics.get(CameraCharacteristics.LENS_FACING);
            float[] focalLengths = characteristics.get(CameraCharacteristics.LENS_INFO_AVAILABLE_FOCAL_LENGTHS);
            Log.d(TAG, "Camera " + camId + ": Facing: " + (facing == null ? "Unknown" : (facing == CameraCharacteristics.LENS_FACING_BACK ? "BACK" : "FRONT")));
            if (focalLengths != null && focalLengths.length > 0) {
                Log.d(TAG, "Camera " + camId + ": Focal Lengths: " + Arrays.toString(focalLengths));
            } else {
                Log.d(TAG, "Camera " + camId + ": Focal Lengths: Not available");
            }
        } catch (CameraAccessException e) {
            Log.e(TAG, "Error logging camera characteristics for camera " + camId, e);
        }
    }

    private void startBackgroundThread() {
        if (backgroundThread == null || !backgroundThread.isAlive()) {
            stopBackgroundThread();
            backgroundThread = new HandlerThread("CameraBackground");
            backgroundThread.start();
            backgroundHandler = new Handler(backgroundThread.getLooper());
            Log.d(TAG, "Background thread started");
        }
    }

    private void stopBackgroundThread() {
        if (backgroundThread != null) {
            backgroundThread.quitSafely();
            try {
                backgroundThread.join(500);
                if (backgroundThread.isAlive()) {
                    Log.w(TAG, "Background thread did not stop in time.");
                }
                backgroundThread = null;
                backgroundHandler = null;
                Log.d(TAG, "Background thread stopped");
            } catch (InterruptedException e) {
                Log.e(TAG, "Error stopping background thread", e);
                Thread.currentThread().interrupt();
            }
        }
    }

    private void openCamera() {
        if (ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) { Log.w(TAG, "openCamera called without permission."); checkAndRequestPermissions(); return; }
        if (currentCameraId == null) { Log.e(TAG, "Cannot open camera, no valid camera ID selected."); return; }
        if (cameraManager == null) { Log.e(TAG, "Cannot open camera, CameraManager is null."); return; }
        if (isCameraOpen) { Log.d(TAG, "Camera already open."); return; }

        startBackgroundThread();

        cameraExecutor.submit(() -> {
            try {
                if (!cameraOpenCloseLock.tryAcquire(2500, TimeUnit.MILLISECONDS)) { Log.e(TAG, "Time out waiting to lock camera opening."); return; }
                try {
                    if (ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) { Log.e(TAG, "Permission lost before opening camera."); cameraOpenCloseLock.release(); return; }
                    isCameraOpen = true;
                    cameraManager.openCamera(currentCameraId, cameraStateCallback, backgroundHandler);
                } catch (CameraAccessException | SecurityException | IllegalArgumentException e) {
                    Log.e(TAG, "Failed to open camera " + currentCameraId, e);
                    isCameraOpen = false;
                    cameraOpenCloseLock.release();
                    runOnUiThread(() -> Toast.makeText(this, "Failed to open camera", Toast.LENGTH_SHORT).show());
                }
            } catch (InterruptedException e) { Log.e(TAG, "Interrupted while waiting for camera lock", e); Thread.currentThread().interrupt(); }
        });
    }

    private final CameraDevice.StateCallback cameraStateCallback = new CameraDevice.StateCallback() {
        @Override
        public void onOpened(@NonNull CameraDevice camera) {
            Log.d(TAG, "Camera " + camera.getId() + " opened.");
            cameraDevice = camera;
            cameraOpenCloseLock.release();
            startCameraPreview();
        }

        @Override
        public void onDisconnected(@NonNull CameraDevice camera) {
            Log.w(TAG, "Camera " + camera.getId() + " disconnected.");
            cameraOpenCloseLock.release();
            camera.close();
            cameraDevice = null;
            isCameraOpen = false;
        }

        @Override
        public void onError(@NonNull CameraDevice camera, int error) {
            Log.e(TAG, "Camera " + camera.getId() + " error: " + error);
            cameraOpenCloseLock.release();
            camera.close();
            cameraDevice = null;
            isCameraOpen = false;
            runOnUiThread(() -> Toast.makeText(MainActivity.this, "Camera error: " + error, Toast.LENGTH_SHORT).show());
        }
    };

    private void closeCameraPreviewSession() {
        if (cameraCaptureSession != null) {
            try {
                cameraCaptureSession.close();
                Log.d(TAG, "Camera preview session closed.");
            } catch (IllegalStateException e) {
                Log.e(TAG, "IllegalStateException closing preview session (already closed?)", e);
            } catch (Exception e) {
                Log.e(TAG, "Exception closing preview session", e);
            } finally {
                cameraCaptureSession = null;
            }
        }
    }

    private void closeCamera() {
        Log.d(TAG, "Attempting to close camera...");
        try {
            if (!cameraOpenCloseLock.tryAcquire(1000, TimeUnit.MILLISECONDS)) { Log.w(TAG, "Timeout waiting for camera lock to close."); return; }
            try {
                closeCameraPreviewSession();
                if (cameraDevice != null) { cameraDevice.close(); cameraDevice = null; Log.d(TAG,"CameraDevice closed."); }
                isCameraOpen = false;
            } finally {
                cameraOpenCloseLock.release(); Log.d(TAG,"Camera close lock released.");
            }
        } catch (InterruptedException e) { Log.e(TAG, "Interrupted while waiting for camera lock to close.", e); Thread.currentThread().interrupt(); }
        finally { stopBackgroundThread(); }
    }

    private void switchCamera() {
        if (cameraManager == null || rearCameraIds == null || rearCameraIds.size() < 2) { Log.w(TAG, "Cannot switch camera: Not enough rear cameras available."); runOnUiThread(()->Toast.makeText(this, "Only one rear camera available", Toast.LENGTH_SHORT).show()); return; }
        Log.d(TAG, "Switching camera...");
        closeCamera();
        currentRearCameraIndex = (currentRearCameraIndex + 1) % rearCameraIds.size();
        currentCameraId = rearCameraIds.get(currentRearCameraIndex);
        Log.d(TAG, "Switched to camera ID: " + currentCameraId);
        openCamera();
    }

    private Size[] getPreviewSizes() {
        try {
            if (cameraManager == null || currentCameraId == null) return new Size[]{new Size(1280, 720)};
            CameraCharacteristics characteristics = cameraManager.getCameraCharacteristics(currentCameraId);
            StreamConfigurationMap map = characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
            if (map != null) { return map.getOutputSizes(SurfaceHolder.class); }
            else { return new Size[]{new Size(1280, 720)}; }
        } catch (CameraAccessException | IllegalArgumentException e) {
            Log.e(TAG, "Error getting preview sizes for camera " + currentCameraId, e);
            return new Size[]{new Size(1280, 720)};
        }
    }

    private Size chooseOptimalPreviewSize(Size[] choices, int viewWidth, int viewHeight) {
        if (choices == null || choices.length == 0) { Log.e(TAG, "No preview sizes available, using default"); return new Size(1280, 720); }
        int targetWidth = viewWidth > 0 ? viewWidth : 1280; int targetHeight = viewHeight > 0 ? viewHeight : 720;
        List<Size> sortedChoices = new ArrayList<>(Arrays.asList(choices));
        Collections.sort(sortedChoices, (a, b) -> Long.compare((long)b.getWidth() * b.getHeight(), (long)a.getWidth() * a.getHeight()));
        Size optimalSize = null; double targetRatio = (double) targetWidth / targetHeight;
        for (Size size : sortedChoices) {
            if (size.getWidth() * size.getHeight() > 4000 * 3000) continue;
            double ratio = (double) size.getWidth() / size.getHeight();
            if (Math.abs(ratio - targetRatio) < 0.05) { optimalSize = size; break; }
        }
        if (optimalSize == null) {
            for (Size size : sortedChoices) { if (size.getWidth() * size.getHeight() <= 4000*3000) { optimalSize = size; break; } }
        }
        if (optimalSize == null) optimalSize = choices[0];
        Log.d(TAG, "Chosen preview size: " + optimalSize.getWidth() + "x" + optimalSize.getHeight() + " for view size " + targetWidth + "x" + targetHeight);
        return optimalSize;
    }


    private void startCameraPreview() {
        if (cameraDevice == null || cameraSurfaceHolder == null || !cameraSurfaceHolder.getSurface().isValid() || !isCameraOpen) { Log.w(TAG, "Cannot start preview..."); return; }
        if (backgroundHandler == null) { startBackgroundThread(); if(backgroundHandler == null) { Log.e(TAG, "Cannot start preview, background handler is null."); return;} }

        backgroundHandler.post(() -> {
            try {
                closeCameraPreviewSession();
                if (previewSize == null) { previewSize = chooseOptimalPreviewSize(getPreviewSizes(), cameraSurfaceView.getWidth(), cameraSurfaceView.getHeight()); if (previewSize == null) { Log.e(TAG, "Failed to select preview size"); return; } }

                Surface surface = cameraSurfaceHolder.getSurface();
                final Size finalPreviewSize = previewSize;
                runOnUiThread(() -> {
                     if (cameraSurfaceHolder != null && cameraSurfaceHolder.getSurface() != null && cameraSurfaceHolder.getSurface().isValid()) {
                         try {
                             cameraSurfaceHolder.setFixedSize(finalPreviewSize.getWidth(), finalPreviewSize.getHeight());
                             Log.d(TAG, "Set SurfaceHolder fixed size for preview (UI Thread): " + finalPreviewSize.getWidth() + "x" + finalPreviewSize.getHeight());
                         } catch(Exception e) { Log.e(TAG, "Error setting fixed size in startCameraPreview", e); }
                     } else { Log.w(TAG, "Surface became invalid before setting fixed size."); }
                 });

                previewRequestBuilder = cameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
                previewRequestBuilder.addTarget(surface);
                previewRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);

                cameraDevice.createCaptureSession(Collections.singletonList(surface), new CameraCaptureSession.StateCallback() {
                    @Override
                    public void onConfigured(@NonNull CameraCaptureSession session) {
                        if (cameraDevice == null || !isCameraOpen) { Log.w(TAG, "Camera closed or null during preview session config."); session.close(); return; }
                        cameraCaptureSession = session;
                        try {
                            cameraCaptureSession.setRepeatingRequest(previewRequestBuilder.build(), null, backgroundHandler);
                            Log.d(TAG, "Camera preview repeating request started.");
                        } catch (CameraAccessException | IllegalStateException e) { Log.e(TAG, "Error starting preview repeating request", e); }
                    }
                    @Override
                    public void onConfigureFailed(@NonNull CameraCaptureSession session) {
                        Log.e(TAG, "Failed to configure camera preview session.");
                        runOnUiThread(() -> Toast.makeText(MainActivity.this, "Failed to configure camera", Toast.LENGTH_SHORT).show());
                    }
                }, backgroundHandler);

            } catch (CameraAccessException | IllegalStateException | IllegalArgumentException e) {
                Log.e(TAG, "Error starting camera preview", e);
                 runOnUiThread(() -> Toast.makeText(MainActivity.this, "Error starting preview", Toast.LENGTH_SHORT).show());
            }
        });
    }

    // --- SurfaceHolder.Callback ---
    @Override
    public void surfaceCreated(@NonNull SurfaceHolder holder) {
        Log.d(TAG, "Surface created.");
        isSurfaceAvailable = true;
        if (ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED && !isCameraOpen) {
            openCamera();
        }
    }
    @Override
    public void surfaceChanged(@NonNull SurfaceHolder holder, int format, int width, int height) {
        Log.d(TAG, "Surface changed. New dimensions: " + width + "x" + height);
        if (isCameraOpen && cameraDevice != null) {
            previewSize = chooseOptimalPreviewSize(getPreviewSizes(), width, height);
            startCameraPreview();
        }
    }
    @Override
    public void surfaceDestroyed(@NonNull SurfaceHolder holder) {
        Log.d(TAG, "Surface destroyed.");
        isSurfaceAvailable = false;
        closeCamera();
    }

    // --- Image Loading and Processing ---
    private void checkPermissionAndPickImage() {
        String permission = Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU ? Manifest.permission.READ_MEDIA_IMAGES : Manifest.permission.READ_EXTERNAL_STORAGE;
        if (ContextCompat.checkSelfPermission(this, permission) != PackageManager.PERMISSION_GRANTED) { Log.d(TAG, "Requesting storage permission for picking image."); ActivityCompat.requestPermissions(this, new String[]{permission}, STORAGE_PERMISSION_CODE); }
        else { Log.d(TAG, "Storage permission already granted."); openImagePicker(); }
    }
    private void openImagePicker() {
        Intent intent = new Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI);
        intent.setType("image/*");
        try { imagePickerLauncher.launch(intent); Log.d(TAG, "Launching image picker."); }
        catch (Exception ex) { Log.e(TAG, "No activity found to handle image picking.", ex); Toast.makeText(this, "Cannot open image picker: " + ex.getMessage(), Toast.LENGTH_LONG).show(); }
    }
    private void loadImage(Uri uri) {
        if (uri == null) { Log.e(TAG, "Cannot load image, URI is null."); return; }
        Log.d(TAG, "Requesting image load for URI: " + uri);
        imageLoadExecutor.submit(() -> {
            Bitmap loadedBitmap = null; InputStream inputStream = null;
            try {
                ContentResolver resolver = getContentResolver();
                BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true;
                inputStream = resolver.openInputStream(uri); BitmapFactory.decodeStream(inputStream, null, options);
                if (inputStream != null) inputStream.close();
                int reqWidth = 1920; int reqHeight = 1080;
                options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight); options.inJustDecodeBounds = false;
                inputStream = resolver.openInputStream(uri); loadedBitmap = BitmapFactory.decodeStream(inputStream, null, options);
                Log.d(TAG, "Bitmap loaded in background: " + (loadedBitmap != null ? loadedBitmap.getWidth() + "x" + loadedBitmap.getHeight() : "null"));
            } catch (IOException e) { Log.e(TAG, "IOException loading bitmap", e);
            } catch (OutOfMemoryError oom) { Log.e(TAG, "OutOfMemoryError loading bitmap", oom); runOnUiThread(()-> Toast.makeText(this, "Image too large - Out of Memory", Toast.LENGTH_LONG).show());
            } catch (Exception e) { Log.e(TAG, "Exception loading bitmap", e);
            } finally { if (inputStream != null) { try { inputStream.close(); } catch (IOException e) { /* ignore */ } } }
            final Bitmap finalBitmap = loadedBitmap;
            runOnUiThread(() -> {
                if (finalBitmap != null) {
                    recycleBitmaps(); originalBitmap = finalBitmap; currentImageUri = uri;
                    resetTransformationsAndFit();
                    if (isPencilMode) { imageLoadExecutor.submit(this::processPencilEffect); } else { updateImageDisplay(); }
                } else { Toast.makeText(this, "Failed to load image", Toast.LENGTH_SHORT).show(); }
            });
        });
    }

    private int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) {
        final int height = options.outHeight; final int width = options.outWidth; int inSampleSize = 1;
        if (height > reqHeight || width > reqWidth) {
            final int halfHeight = height / 2; final int halfWidth = width / 2;
            while ((halfHeight / inSampleSize) >= reqHeight && (halfWidth / inSampleSize) >= reqWidth) { inSampleSize *= 2; }
        }
        Log.d(TAG, "Calculated inSampleSize: " + inSampleSize);
        return inSampleSize;
    }

    private void recycleBitmaps() {
        Bitmap ob = originalBitmap; Bitmap pb = pencilBitmap; Bitmap[] lb = layerBitmaps;
        originalBitmap = null; pencilBitmap = null; layerBitmaps = null;
        if (ob != null && !ob.isRecycled()) { ob.recycle(); Log.d(TAG, "Recycled originalBitmap"); }
        if (pb != null && !pb.isRecycled()) { pb.recycle(); Log.d(TAG, "Recycled pencilBitmap"); }
        if (lb != null) { for (int i = 0; i < lb.length; i++) { if (lb[i] != null && !lb[i].isRecycled()) { lb[i].recycle(); Log.d(TAG, "Recycled layerBitmap[" + i + "]"); } } }
    }

    private void recyclePencilBitmaps() {
        Bitmap pb = pencilBitmap; Bitmap[] lb = layerBitmaps;
        pencilBitmap = null; layerBitmaps = null;
        if (pb != null && !pb.isRecycled()) { pb.recycle(); Log.d(TAG, "Recycled pencilBitmap"); }
        if (lb != null) { for (int i = 0; i < lb.length; i++) { if (lb[i] != null && !lb[i].isRecycled()) { lb[i].recycle(); Log.d(TAG, "Recycled layerBitmap[" + i + "]"); } } }
    }

    private void resetTransformationsAndFit() {
        matrix.reset();
        if (originalBitmap == null || originalBitmap.isRecycled() || imageView.getWidth() == 0 || imageView.getHeight() == 0) {
            scaleFactor = 1.0f;
            // rotationAngle = 0.0f; // Угол сбрасывается при reset() матрицы
            if (imageView != null) runOnUiThread(() -> { imageView.setImageMatrix(matrix); imageView.invalidate(); });
            return;
        }
        final float viewWidth = imageView.getWidth(); final float viewHeight = imageView.getHeight();
        final float bmpWidth = originalBitmap.getWidth(); final float bmpHeight = originalBitmap.getHeight();
        float scale = Math.min(viewWidth / bmpWidth, viewHeight / bmpHeight); // Используем fitCenter по умолчанию
        float dx = (viewWidth - bmpWidth * scale) / 2f;
        float dy = (viewHeight - bmpHeight * scale) / 2f;
        matrix.setScale(scale, scale);
        matrix.postTranslate(dx, dy);
        scaleFactor = scale; // Сохраняем начальный масштаб
        // rotationAngle = 0.0f;
        if (imageView != null) runOnUiThread(() -> { imageView.setImageMatrix(matrix); imageView.invalidate(); });
        Log.d(TAG, "Image reset and fit CENTER. Scale: " + scaleFactor);
    }

    private void applyTransformations() {
        if (imageView != null) {
            runOnUiThread(() -> {
                imageView.setImageMatrix(matrix);
                imageView.invalidate();
            });
        }
    }

    private void setImageAlpha(int progress) {
        if (imageView != null) {
            float alpha = Math.max(0.0f, Math.min(1.0f, progress / 100.0f));
            runOnUiThread(() -> {
                imageView.setAlpha(alpha);
                imageView.invalidate();
            });
        }
    }

    private void processPencilEffect() {
        Log.d(TAG, "Processing pencil effect...");
        if (originalBitmap == null || originalBitmap.isRecycled()) { Log.w(TAG, "Original bitmap unavailable."); return; }
        final Bitmap sourceBitmap = originalBitmap.copy(originalBitmap.getConfig(), false);
        imageLoadExecutor.submit(() -> {
            recyclePencilBitmaps();
            Bitmap grayBitmap = null; Bitmap[] newLayerBitmaps = new Bitmap[PENCIL_HARDNESS.length]; boolean success = false;
            try {
                int width = sourceBitmap.getWidth(); int height = sourceBitmap.getHeight();
                grayBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
                Canvas canvasGray = new Canvas(grayBitmap); Paint paintGray = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.FILTER_BITMAP_FLAG);
                ColorMatrix cmGray = new ColorMatrix(); cmGray.setSaturation(0); paintGray.setColorFilter(new ColorMatrixColorFilter(cmGray));
                canvasGray.drawBitmap(sourceBitmap, 0, 0, paintGray);
                int[] pixels = new int[width * height]; grayBitmap.getPixels(pixels, 0, width, 0, 0, width, height);
                int numLayers = newLayerBitmaps.length; int step = 256 / numLayers;
                int[][] layerPixels = new int[numLayers][width * height];
                for (int i = 0; i < numLayers; i++) Arrays.fill(layerPixels[i], Color.TRANSPARENT);
                for (int i = 0; i < pixels.length; i++) { int gray = Color.red(pixels[i]); int layerIndex = getLayerIndex(gray); if (layerIndex >= 0) { layerPixels[layerIndex][i] = pixels[i]; } }
                pixels = null;
                for (int i = 0; i < numLayers; i++) { newLayerBitmaps[i] = Bitmap.createBitmap(layerPixels[i], width, height, Bitmap.Config.ARGB_8888); layerPixels[i] = null; }
                layerPixels = null; success = true; Log.d(TAG, "Pencil effect processing successful.");
            } catch (OutOfMemoryError e) { Log.e(TAG, "OutOfMemoryError processing pencil effect", e); runOnUiThread(()-> Toast.makeText(this, "Not enough memory for pencil effect", Toast.LENGTH_LONG).show()); if (grayBitmap != null && !grayBitmap.isRecycled()) grayBitmap.recycle(); for (int i = 0; i < newLayerBitmaps.length; i++) { if (newLayerBitmaps[i] != null && !newLayerBitmaps[i].isRecycled()) newLayerBitmaps[i].recycle(); }
            } catch (Exception e) { Log.e(TAG, "Error processing pencil effect", e); runOnUiThread(() -> Toast.makeText(this, "Error processing pencil effect", Toast.LENGTH_SHORT).show()); }
            finally { if (sourceBitmap != null && !sourceBitmap.isRecycled()) { sourceBitmap.recycle(); } if (grayBitmap != null && !grayBitmap.isRecycled()) { grayBitmap.recycle(); } }
            final boolean finalSuccess = success; final Bitmap[] finalLayerBitmaps = newLayerBitmaps;
            runOnUiThread(() -> {
                if (finalSuccess) { layerBitmaps = finalLayerBitmaps; pencilBitmap = null; }
                else { layerBitmaps = null; pencilBitmap = null; isPencilMode = false; pencilModeSwitch.setChecked(false); layerSelectButton.setVisibility(View.GONE); }
                updateImageDisplay();
            });
        });
    }

    private int getLayerIndex(int grayValue) {
        int numLayers = PENCIL_HARDNESS.length;
        int index = (int) (((float) grayValue / 256.0f) * numLayers);
        return Math.max(0, Math.min(index, numLayers - 1));
    }

    private void updateImageDisplay() {
        Log.d(TAG, "Updating image display: isPencilMode=" + isPencilMode + ", isImageVisible=" + isImageVisible);
        if (!isImageVisible || originalBitmap == null || originalBitmap.isRecycled()) {
            Log.d(TAG, "Hiding ImageView or originalBitmap is unavailable.");
            runOnUiThread(() -> { if (imageView != null) { imageView.setImageBitmap(null); imageView.setVisibility(View.INVISIBLE); imageView.invalidate(); } });
            return;
        }
        Bitmap bitmapToDisplay = null; boolean isPencilBitmapReady = isPencilMode && layerBitmaps != null;
        if (isPencilBitmapReady) {
            Log.d(TAG, "Updating display for Pencil mode");
            try {
                bitmapToDisplay = Bitmap.createBitmap(originalBitmap.getWidth(), originalBitmap.getHeight(), Bitmap.Config.ARGB_8888);
                Canvas canvas = new Canvas(bitmapToDisplay); canvas.drawColor(Color.TRANSPARENT);
                Paint layerPaint = new Paint(Paint.FILTER_BITMAP_FLAG); boolean drawnSomething = false;
                for (int i = 0; i < layerBitmaps.length; i++) { if (layerVisibility[i] && layerBitmaps[i] != null && !layerBitmaps[i].isRecycled()) { canvas.drawBitmap(layerBitmaps[i], 0, 0, layerPaint); drawnSomething = true; } }
                Log.d(TAG, "Drew visible pencil layers. Drawn something: " + drawnSomething);
                if (!drawnSomething && bitmapToDisplay != null && !bitmapToDisplay.isRecycled()) { bitmapToDisplay.recycle(); bitmapToDisplay = Bitmap.createBitmap(1, 1, Bitmap.Config.ARGB_8888); bitmapToDisplay.eraseColor(Color.TRANSPARENT); }
            } catch (OutOfMemoryError e) {
                Log.e(TAG, "OOM Error creating result bitmap for pencil mode", e); bitmapToDisplay = originalBitmap;
                isPencilMode = false;
                runOnUiThread(() -> { pencilModeSwitch.setChecked(false); layerSelectButton.setVisibility(View.GONE); Toast.makeText(this, "Out of memory displaying layers", Toast.LENGTH_SHORT).show(); });
                recyclePencilBitmaps();
            } catch (Exception e) { Log.e(TAG, "Error composing pencil layers", e); bitmapToDisplay = originalBitmap; }
        } else { Log.d(TAG, "Displaying original bitmap"); bitmapToDisplay = originalBitmap; }
        final Bitmap finalBitmap = bitmapToDisplay;
        runOnUiThread(() -> {
            if (imageView != null) {
                if (finalBitmap != null && !finalBitmap.isRecycled()) { imageView.setImageBitmap(finalBitmap); imageView.setVisibility(View.VISIBLE); imageView.setImageMatrix(matrix); setImageAlpha(transparencySeekBar.getProgress()); imageView.invalidate(); Log.d(TAG, "ImageView updated."); }
                else { Log.w(TAG, "Bitmap to display is null or recycled."); imageView.setImageBitmap(null); imageView.setVisibility(View.INVISIBLE); }
            }
        });
    }

    // --- Диалог выбора слоев ---
    private void showLayerSelectionDialog() {
        final Dialog dialog = new Dialog(this);
        dialog.setContentView(R.layout.dialog_layer_selection);
        dialog.setTitle(R.string.layer_selection_title);
        // *** ИСПРАВЛЕНО ID ЗДЕСЬ ***
        RecyclerView recyclerView = dialog.findViewById(R.id.recyclerView);
        if (recyclerView == null) { Log.e(TAG, "RecyclerView (R.id.recyclerView) not found!"); Toast.makeText(this, "Error dialog", Toast.LENGTH_SHORT).show(); return; }
        recyclerView.setLayoutManager(new LinearLayoutManager(this));
        LayerAdapter adapter = new LayerAdapter(PENCIL_HARDNESS, layerVisibility, this);
        recyclerView.setAdapter(adapter);
        dialog.show();
    }
    @Override
    public void onLayerVisibilityChanged(int position, boolean isVisible) {
        if (position >= 0 && position < layerVisibility.length) {
            layerVisibility[position] = isVisible;
            Log.d(TAG, "Layer " + position + " (" + PENCIL_HARDNESS[position] + ") visibility changed to: " + isVisible);
            updateImageDisplay();
        } else {
            Log.w(TAG, "Invalid position received from LayerAdapter: " + position);
        }
    }

    // --- Сохранение/Загрузка параметров ---
    private void checkPermissionAndSaveParameters() { openSaveFilePicker(); }
    private void checkPermissionAndLoadParameters() { openLoadFilePicker(); }
    private void openSaveFilePicker() {
        Intent intent = new Intent(Intent.ACTION_CREATE_DOCUMENT);
        intent.addCategory(Intent.CATEGORY_OPENABLE);
        intent.setType("application/json");
        intent.putExtra(Intent.EXTRA_TITLE, "camera_overlay_params.json");
        try { saveFileLauncher.launch(intent); }
        catch (Exception e) { Log.e(TAG, "Could not launch save file picker", e); Toast.makeText(this, "Error opening save dialog", Toast.LENGTH_SHORT).show(); }
    }
    private void openLoadFilePicker() {
        Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);
        intent.addCategory(Intent.CATEGORY_OPENABLE);
        intent.setType("application/json");
        try { loadFileLauncher.launch(intent); }
        catch (Exception e) { Log.e(TAG, "Could not launch load file picker", e); Toast.makeText(this, "Error opening load dialog", Toast.LENGTH_SHORT).show(); }
    }
    private void saveParametersToFile(Uri uri) {
        if (originalBitmap == null || originalBitmap.isRecycled()) { Toast.makeText(this, "Load an image first to save parameters", Toast.LENGTH_SHORT).show(); return; }
        if (uri == null) { Log.e(TAG, "Save URI is null"); return; }
        try {
            JSONObject json = new JSONObject();
            if (currentImageUri != null) { json.put("imageUri", currentImageUri.toString()); }
            JSONArray matrixArray = new JSONArray(); float[] matrixValues = new float[9]; matrix.getValues(matrixValues); for (float value : matrixValues) matrixArray.put(value);
            json.put("matrix", matrixArray);
            json.put("transparency", transparencySeekBar.getProgress());
            json.put("isPencilMode", isPencilMode);
            json.put("isImageVisible", isImageVisible);
            json.put("controlsVisible", controlsVisibilityCheckbox.isChecked());
            JSONArray visibilityArray = new JSONArray(); for (boolean visible : layerVisibility) visibilityArray.put(visible);
            json.put("layerVisibility", visibilityArray);
            ContentResolver resolver = getContentResolver();
            try (OutputStream outputStream = resolver.openOutputStream(uri)) {
                if (outputStream != null) { outputStream.write(json.toString(2).getBytes()); Toast.makeText(this, "Parameters saved", Toast.LENGTH_SHORT).show(); Log.d(TAG, "Parameters saved to " + uri); }
                else { throw new IOException("OutputStream is null"); }
            }
        } catch (Exception e) { Log.e(TAG, "Error saving parameters to file", e); Toast.makeText(this, "Failed to save parameters", Toast.LENGTH_LONG).show(); }
    }

    private void loadParametersFromFile(Uri uri) {
        if (uri == null) { Log.e(TAG, "Load URI is null"); return; }
        Log.d(TAG, "Loading parameters from URI: " + uri);
        try {
            ContentResolver resolver = getContentResolver();
            try (InputStream inputStream = resolver.openInputStream(uri)) {
                if (inputStream != null) {
                    StringBuilder jsonString = new StringBuilder(); byte[] buffer = new byte[4096]; int bytesRead;
                    while ((bytesRead = inputStream.read(buffer)) != -1) { jsonString.append(new String(buffer, 0, bytesRead)); }
                    JSONObject json = new JSONObject(jsonString.toString());
                    Uri loadedImageUri = null; if (json.has("imageUri")) { loadedImageUri = Uri.parse(json.getString("imageUri")); }
                    if (loadedImageUri != null && !loadedImageUri.equals(currentImageUri)) {
                        Log.d(TAG, "Loading image specified in parameters: " + loadedImageUri);
                        currentImageUri = loadedImageUri;
                        final JSONObject finalJson = json;
                        loadImageAndApplyParams(currentImageUri, finalJson);
                    } else {
                        applyLoadedParameters(json);
                    }
                } else { throw new IOException("InputStream is null"); }
            }
        } catch (Exception e) { Log.e(TAG, "Error loading parameters from file", e); Toast.makeText(this, "Failed to load parameters", Toast.LENGTH_LONG).show(); }
    }

    private void loadImageAndApplyParams(Uri uri, JSONObject paramsToApply) {
        if (uri == null) { return; }
        Log.d(TAG, "Requesting image load for URI (with params): " + uri);
        imageLoadExecutor.submit(() -> {
            Bitmap loadedBitmap = null; InputStream inputStream = null;
            try {
                ContentResolver resolver = getContentResolver();
                BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true;
                inputStream = resolver.openInputStream(uri); BitmapFactory.decodeStream(inputStream, null, options);
                if (inputStream != null) inputStream.close();
                int reqWidth = 1920; int reqHeight = 1080;
                options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight); options.inJustDecodeBounds = false;
                inputStream = resolver.openInputStream(uri); loadedBitmap = BitmapFactory.decodeStream(inputStream, null, options);
            } catch (Exception e) { Log.e(TAG, "Exception loading bitmap for params", e); }
            finally { if (inputStream != null) { try { inputStream.close(); } catch (IOException e) { /* ignore */ } } }
            final Bitmap finalBitmap = loadedBitmap;
            runOnUiThread(() -> {
                if (finalBitmap != null) {
                    recycleBitmaps(); originalBitmap = finalBitmap; currentImageUri = uri;
                    try { applyLoadedParameters(paramsToApply); }
                    catch (Exception e) { Log.e(TAG, "Error applying loaded parameters after image load", e); Toast.makeText(this, "Error applying parameters", Toast.LENGTH_SHORT).show(); resetTransformationsAndFit(); updateImageDisplay(); }
                } else { Toast.makeText(this, "Failed to load image specified in parameters", Toast.LENGTH_SHORT).show(); }
            });
        });
    }

    private void applyLoadedParameters(JSONObject json) throws Exception {
        Log.d(TAG, "Applying loaded parameters...");
        if (json.has("matrix")) {
            JSONArray matrixArray = json.getJSONArray("matrix");
            if (matrixArray.length() >= 9) {
                float[] matrixValues = new float[9];
                for (int i = 0; i < 9; i++) matrixValues[i] = (float) matrixArray.getDouble(i);
                matrix.setValues(matrixValues);
                scaleFactor = getMatrixScale(matrix); // Восстанавливаем масштаб из матрицы
            }
        } else { matrix.reset(); scaleFactor = 1.0f; }

        if (json.has("transparency")) transparencySeekBar.setProgress(json.getInt("transparency"));
        if (json.has("isPencilMode")) isPencilMode = json.getBoolean("isPencilMode");
        if (json.has("isImageVisible")) isImageVisible = json.getBoolean("isImageVisible");
        boolean controlsVisible = true; if (json.has("controlsVisible")) controlsVisible = json.getBoolean("controlsVisible");

        if (json.has("layerVisibility")) {
            JSONArray visibilityArray = json.getJSONArray("layerVisibility");
            for (int i = 0; i < visibilityArray.length() && i < layerVisibility.length; i++) { layerVisibility[i] = visibilityArray.getBoolean(i); }
        }
        final boolean finalControlsVisible = controlsVisible;
        runOnUiThread(() -> {
            pencilModeSwitch.setChecked(isPencilMode);
            hideImageCheckbox.setChecked(!isImageVisible);
            controlsVisibilityCheckbox.setChecked(finalControlsVisible);
            updateControlsVisibility(finalControlsVisible);
            applyTransformations();
             if (isPencilMode && originalBitmap != null && !originalBitmap.isRecycled()) { imageLoadExecutor.submit(this::processPencilEffect); }
             else { updateImageDisplay(); }
            Toast.makeText(this, "Parameters applied", Toast.LENGTH_SHORT).show();
            Log.d(TAG, "Parameters applied successfully.");
        });
    }

    // --- Жизненный цикл Activity ---
    @Override
    protected void onResume() {
        super.onResume();
        Log.d(TAG, "onResume");
        hideSystemUI();
        startBackgroundThread();
        if (isSurfaceAvailable && ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED && !isCameraOpen) {
            Log.d(TAG, "Opening camera from onResume");
            openCamera();
        }
        updateImageDisplay();
    }
    @Override
    protected void onPause() {
        Log.d(TAG, "onPause");
        closeCamera();
        super.onPause();
    }
    @Override
    protected void onDestroy() {
        Log.d(TAG, "onDestroy");
        closeCamera();
        cameraExecutor.shutdown();
        imageLoadExecutor.shutdown();
        recycleBitmaps();
        super.onDestroy();
    }
    @Override
    protected void onSaveInstanceState(@NonNull Bundle outState) {
        super.onSaveInstanceState(outState);
        Log.d(TAG, "Saving instance state...");
        if (currentImageUri != null) { outState.putString(KEY_IMAGE_URI, currentImageUri.toString()); }
        if (originalBitmap != null) { float[] matrixValues = new float[9]; matrix.getValues(matrixValues); outState.putFloatArray(KEY_MATRIX_VALUES, matrixValues); }
        if (controlsVisibilityCheckbox != null) { outState.putBoolean(KEY_CONTROLS_VISIBLE, controlsVisibilityCheckbox.isChecked()); }
        outState.putBoolean(KEY_PENCIL_MODE, isPencilMode);
        outState.putBooleanArray(KEY_LAYER_VISIBILITY, layerVisibility);
        outState.putBoolean(KEY_IMAGE_VISIBLE, isImageVisible);
        if (currentCameraId != null) { outState.putString(KEY_CURRENT_CAMERA_ID, currentCameraId); }
    }
    private void restoreInstanceState(@NonNull Bundle savedInstanceState) {
        Log.d(TAG, "Restoring instance state...");
        String savedUriString = savedInstanceState.getString(KEY_IMAGE_URI);
        boolean imageNeedsLoading = false;
        if (savedUriString != null) {
             Uri savedUri = Uri.parse(savedUriString);
             if (!savedUri.equals(currentImageUri)) { currentImageUri = savedUri; imageNeedsLoading = true; }
             Log.d(TAG, "Restored Image URI: " + currentImageUri);
        }
        float[] savedMatrixValues = savedInstanceState.getFloatArray(KEY_MATRIX_VALUES);
        if (savedMatrixValues != null) {
            matrix.setValues(savedMatrixValues);
            scaleFactor = getMatrixScale(matrix);
            Log.d(TAG, "Restored Matrix, Scale");
        }
        isPencilMode = savedInstanceState.getBoolean(KEY_PENCIL_MODE, false);
        boolean[] savedLayerVisibility = savedInstanceState.getBooleanArray(KEY_LAYER_VISIBILITY);
        if (savedLayerVisibility != null && savedLayerVisibility.length == layerVisibility.length) { System.arraycopy(savedLayerVisibility, 0, layerVisibility, 0, layerVisibility.length); }
        isImageVisible = savedInstanceState.getBoolean(KEY_IMAGE_VISIBLE, true);
        boolean restoredControlsVisible = savedInstanceState.getBoolean(KEY_CONTROLS_VISIBLE, true);
        pencilModeSwitch.setChecked(isPencilMode);
        hideImageCheckbox.setChecked(!isImageVisible);
        controlsVisibilityCheckbox.setChecked(restoredControlsVisible);
        updateControlsVisibility(restoredControlsVisible);
        setImageAlpha(transparencySeekBar.getProgress());
        currentCameraId = savedInstanceState.getString(KEY_CURRENT_CAMERA_ID, currentCameraId);
        if (imageNeedsLoading) { loadImage(currentImageUri); }
        else if (originalBitmap != null) { applyTransformations(); updateImageDisplay(); }
    }

    // --- Обработка Касаний и Жестов ---
    private class TouchAndGestureListener implements View.OnTouchListener {
        PointF startDragPoint = new PointF(); Matrix savedMatrix = new Matrix();
        @Override
        public boolean onTouch(View v, MotionEvent event) {
            if (originalBitmap == null || originalBitmap.isRecycled()) return false;
            scaleGestureDetector.onTouchEvent(event);
            int action = event.getActionMasked(); int pointerCount = event.getPointerCount();
            switch (action) {
                case MotionEvent.ACTION_DOWN: savedMatrix.set(matrix); startDragPoint.set(event.getX(), event.getY()); touchMode = DRAG; Log.d(TAG, "Touch Mode: DRAG"); break;
                case MotionEvent.ACTION_POINTER_DOWN: if (pointerCount >= 2) { savedMatrix.set(matrix); initialAngle = rotation(event); midPoint(midPoint, event); touchMode = ZOOM; Log.d(TAG, "Touch Mode: ZOOM/ROTATE"); } break;
                case MotionEvent.ACTION_MOVE:
                    if (touchMode == DRAG && pointerCount == 1 && !scaleGestureDetector.isInProgress()) { matrix.set(savedMatrix); float dx = event.getX() - startDragPoint.x; float dy = event.getY() - startDragPoint.y; matrix.postTranslate(dx, dy); applyTransformations(); }
                    else if (touchMode == ZOOM && pointerCount >= 2) { float currentAngle = rotation(event); float deltaAngle = currentAngle - initialAngle; float initialScaleFactor = getMatrixScale(savedMatrix); float scaleChange = (initialScaleFactor > 0.001f) ? scaleFactor / initialScaleFactor : 1f; matrix.set(savedMatrix); midPoint(midPoint, event); matrix.postScale(scaleChange, scaleChange, midPoint.x, midPoint.y); matrix.postRotate(deltaAngle, midPoint.x, midPoint.y); applyTransformations(); }
                    break;
                case MotionEvent.ACTION_POINTER_UP: if (pointerCount == 2) { int remainingPointerIndex = (event.getActionIndex() == 0) ? 1 : 0; startDragPoint.set(event.getX(remainingPointerIndex), event.getY(remainingPointerIndex)); savedMatrix.set(matrix); touchMode = DRAG; Log.d(TAG, "Touch Mode changed to DRAG after POINTER_UP"); } else if (pointerCount < 2) { touchMode = NONE; Log.d(TAG, "Touch Mode: NONE (Pointer Up)"); } break;
                case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: touchMode = NONE; Log.d(TAG, "Touch Mode: NONE (Up/Cancel)"); break;
            }
            return true;
        }
        private void midPoint(PointF point, MotionEvent event) { if (event.getPointerCount() < 2) { point.set(event.getX(), event.getY()); return; } float x = event.getX(0) + event.getX(1); float y = event.getY(0) + event.getY(1); point.set(x / 2f, y / 2f); }
        private float rotation(MotionEvent event) { if (event.getPointerCount() < 2) return 0f; double delta_x = (event.getX(0) - event.getX(1)); double delta_y = (event.getY(0) - event.getY(1)); return (float) Math.toDegrees(Math.atan2(delta_y, delta_x)); }
        // getMatrixScale удален отсюда
    }

    private class ScaleListener extends ScaleGestureDetector.SimpleOnScaleGestureListener {
        @Override public boolean onScaleBegin(@NonNull ScaleGestureDetector detector) { if (originalBitmap == null || originalBitmap.isRecycled()) return false; touchMode = ZOOM; return true; }
        @Override public boolean onScale(@NonNull ScaleGestureDetector detector) { if (originalBitmap == null || touchMode != ZOOM) return false; scaleFactor *= detector.getScaleFactor(); scaleFactor = Math.max(0.1f, Math.min(scaleFactor, 10.0f)); return true; }
        // getMatrixScale удален отсюда
    }

    // --- Вспомогательные методы ---

    // Метод getMatrixScale (ПЕРЕМЕЩЕН ИЗ TouchAndGestureListener)
    private float getMatrixScale(Matrix mat) {
        float[] values = new float[9]; mat.getValues(values);
        float scaleX = values[Matrix.MSCALE_X]; float skewY = values[Matrix.MSKEW_Y];
        // Используем более точный расчет масштаба, учитывая возможный поворот/наклон
        return (float) Math.sqrt(scaleX * scaleX + skewY * skewY);
    }

    public Display getDisplay() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            DisplayManager displayManager = (DisplayManager) getSystemService(Context.DISPLAY_SERVICE);
            if (displayManager != null) { return displayManager.getDisplay(Display.DEFAULT_DISPLAY); }
            else { Log.e(TAG, "DisplayManager service not found!"); /* Fallback */ }
        }
        //noinspection deprecation
        return getWindowManager().getDefaultDisplay();
    }
}

# app/src/main/res/drawable/ic_open_arrow.png
PNG

   IHDR         \rf   sRGB    gAMA  a   	pHYs    od  xIDATx^+I˕HJ$D"H$D"HJ$9=UsGnVfWDt<z'>J&Z7D$O_=oI3~I_%7/?% Xg[?
t,?ϒ"7Hn J|;
OT2K]]_ ĕ-X-J9 ѯ/QI:G7nq+sTQ*H7$7%/~K$
[-,9t+ῢݗ!_)yGC AşY ]yT$o8
3}.Z4?S5F]hY%&x{sc{IR oI(E7MiP*%Q 0;w`|[,ޤ2CUxCsH@.K[1q=xSF6PRz(18qTvޥ$tBF\*c`BpE,QD*kmxQ}2
C/,p@AF(T~t+_5{51\1T~tR6k:ʏp@GPhZ I5#4
sҵnOal?J<w	D¬>4t-y!K5Ļ T>/-΋ V/1Ȋ6,/zDt3'hEY:forqWʌd|
j+x||W?.}ĎDg 	ZK|=Uz/.QpCȳw'I?}wui6|ggk?'&d%BxȜg8㛽ҟoQYxac	o{v7i^;9D!XP׹XE=Uch|kp%f߷Os?`!O6qz?[n7Nd%?* {9{KξQe݄$/=.03#çJ㥞|O!H5Gn[Ugs6gW;Gawx-q7pC2gedXiq xS4N/+qzVַ$d.ǽ#_"oy;yr]}zgr6$`+J1LBr^4XEsFI-\ Fz"3^}^_ȬA0Qk7&wNYqwf$'Jܹx ٯspITm(Enj/*=ʿ-4$t7q\*h&H^y)p8OϣF`N0j?=]}T|pggA3-DtF\&yoOİ;'zpvCf_7#@<+=[oA[گ1Ńs	1.;? S~tȘq2mCɟ>8Org	ɛ3=䅡dXPɟ̰I F
)jЃ~}c]z}J>9GZ.y-vɾa@'cq.@ R"3[^K{}̎G'u=xvęWf/]o*zojua۱#ɓn'}}ual嘀{~w]B>[:@mmwJ~xW[=
?p+Itx﫿pC+K~t5.`fYd8fԲU$?|0W1DD%?!;h7?\ɏ.{o2p{ʒ])F`\ɏW:K}p~AS;ca,$/"|rv*v&tӻ Lqe*yd|;G`4VʒMNwx`@I>4FnO8`2+CEmj_ y~"T[開- ɇfqO2T|hjn~A򢉻]s|h"O6`SQI>41`'}\OC95ZhҳWRYDcܰN$R>ˍ`Sm,SQ!7	@a0IH׋v1`y{7	vN v9l%Ö `InW*yr nWSHGCA)N ,M݃Az Ҕ_$D\"I63$Rvk#4O&k9$RmeI ZL6'sSQxUJ9OւD`ݶ|0, kRzX#}{r X3uf2MT1HkoC' [; ڔ1HXzA ][->-(8?E?lEIA:9)U*h ST1翷a[<`b	~(bT?Eja(E | fV&Wh  X ⯨bTΟ4OQE: (@[QzF?V UJl IT)*i&QD jUJl IT)*i&QD jUJl IT)*i&QD jUJl IT)*i&QD jUJl IT)*i&QD jUJl IT)*i&Qx&=JQȓy]?/ΗAJevx{хps%]A>sAt*-q?|@Rht&'q?L|@'RYEh\*C~KeGWC>Q܈a4&q?
F"!ЀTFKCB> T6
IeBA> T:H@@>`caSl$yOC>`s~H%!V&XXB>`A[~H$_	,yJMA>`&K~h3HCR|w&JC7 yEA>`q?t	3G5NHC$O$?~(I|< ܉<e:o~ Q.s&C|Ε #q?	|΍`tN #*s!H7 q?49\A ;q?41Ds /q?4б,@|`!Rtl 6"Xt q?XV&E>@@ Y>@ML~$g$c|> ! Y,&H" 'q?@#̞4l q?@\{4U q.u 09t|Kzq?@q~9c p Ÿ'q?@AJ??lb    IENDB`
# app/src/main/res/layout/activity_main.xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <SurfaceView
        android:id="@+id/cameraSurfaceView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_centerInParent="true" />

    <ImageView
        android:id="@+id/imageView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_centerInParent="true" />

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_alignParentBottom="true"
        android:orientation="vertical"
        android:padding="10dp">

        <SeekBar
            android:id="@+id/transparencySeekBar"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:max="100"
            android:progress="100" />

        <Button
            android:id="@+id/pickImageButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/pick_image" />

        <Switch
            android:id="@+id/pencilModeSwitch"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/pencil_mode" />

        <Button
            android:id="@+id/layerSelectButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/select_layers"
            android:visibility="gone" />

        <CheckBox
            android:id="@+id/controlsVisibilityCheckbox"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/show_controls"
            android:checked="true" />

        <CheckBox
            android:id="@+id/hideImageCheckbox"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/hide_image" />

        <Button
            android:id="@+id/saveParametersButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/save_parameters" />

        <Button
            android:id="@+id/loadParametersButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/load_parameters" />

        <Button
            android:id="@+id/switchCameraButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="@string/switch_camera" />
    </LinearLayout>

</RelativeLayout>

# app/src/main/res/layout/dialog_layer_selection.xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="wrap_content">
<!-- Это тестовое изменение -->
    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/recyclerView"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent" /> <!-- <<<=== УБЕДИТЕСЬ, ЧТО ЗДЕСЬ ЕСТЬ СЛЭШ '/' ПЕРЕД '>' -->

</androidx.constraintlayout.widget.ConstraintLayout>

# app/src/main/res/layout/item_layer.xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:padding="8dp">

    <TextView
        android:id="@+id/layerText"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:textSize="16sp" />

    <CheckBox
        android:id="@+id/layerCheckBox"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" />
</LinearLayout>

# app/src/main/res/mipmap-hdpi/ic_launcher.png
PNG

   IHDR   H   H   o#!   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  {ܙ,   bKGD-   tIME(`   IDAT(c``   _   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`
# app/src/main/res/mipmap-hdpi/ic_launcher_round.png
PNG

   IHDR   H   H   o#!   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  ?/O   bKGD-   tIME(`   IDAT(c``   _   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`
# app/src/main/res/mipmap-mdpi/ic_launcher.png
PNG

   IHDR   0   0   mk   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  {ܙ,   bKGD-   tIME'N|   IDATc` P    %tEXtdate:create 2025-04-27T16:18:39+00:00s   %tEXtdate:modify 2025-04-27T16:18:39+00:00Aq    IENDB`
# app/src/main/res/mipmap-mdpi/ic_launcher_round.png
PNG

   IHDR   0   0   mk   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  ?/O   bKGD-   tIME(`   IDATc` P    %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`
# app/src/main/res/mipmap-xhdpi/ic_launcher.png
PNG

   IHDR   `   `   V{   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  {ܙ,   bKGD-   tIME(`   IDAT8c``	  t   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`
# app/src/main/res/mipmap-xhdpi/ic_launcher_round.png
PNG

   IHDR   `   `   V{   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  ?/O   bKGD-   tIME(`   IDAT8c``	  t   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`
# app/src/main/res/mipmap-xxhdpi/ic_launcher.png
PNG

   IHDR         ݈p   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  {ܙ,   bKGD-   tIME(`   IDATH1    Om   
 >4   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`
# app/src/main/res/mipmap-xxhdpi/ic_launcher_round.png
PNG

   IHDR         ݈p   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  ?/O   bKGD-   tIME(`   IDATH1    Om   
 >4   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`
# app/src/main/res/mipmap-xxxhdpi/ic_launcher.png
PNG

   IHDR         hD   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  {ܙ,   bKGD-   tIME(`   IDATX1    Om      R   %tEXtdate:create 2025-04-27T16:18:40+00:00A[   %tEXtdate:modify 2025-04-27T16:18:40+00:00    IENDB`
# app/src/main/res/mipmap-xxxhdpi/ic_launcher_round.png
PNG

   IHDR         hD   gAMA  a    cHRM  z&         u0  `  :  pQ<   PLTE  ?/O   bKGD-   tIME)g{   IDATX1    Om      R   %tEXtdate:create 2025-04-27T16:18:41+00:00J6P   %tEXtdate:modify 2025-04-27T16:18:41+00:00;k    IENDB`
# app/src/main/res/values/strings.xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">HelloWorld</string>
    <string name="pick_image">Pick Image</string>
    <string name="show_controls">Show Controls</string>
    <string name="pencil_mode">Pencil Mode</string>
    <string name="select_layers">Select Layers</string>
    <string name="hide_image">Hide Image</string>
    <string name="save_parameters">Save Parameters</string>
    <string name="load_parameters">Load Parameters</string>
    <string name="switch_camera">Switch Camera</string>
    <string name="layer_selection_title">Select Pencil Layers</string>
</resources>

# app/src/main/res/values/themes.xml
<?xml version="1.0" encoding="utf-8"?>
<resources xmlns:tools="http://schemas.android.com/tools">
    <style name="Theme.HelloWorld" parent="Theme.AppCompat.Light.DarkActionBar">
        <item name="colorPrimary">@android:color/black</item>
        <item name="colorPrimaryDark">@android:color/black</item>
        <item name="colorAccent">@android:color/holo_blue_light</item>
    </style>
</resources>

# app/src/main/res/xml/backup_rules.xml
<?xml version="1.0" encoding="utf-8"?>
<full-backup-content>
    <include domain="file" path="." />
</full-backup-content>

# app/src/main/res/xml/data_extraction_rules.xml
<?xml version="1.0" encoding="utf-8"?>
<data-extraction-rules>
    <cloud-backup>
        <include domain="file" />
    </cloud-backup>
</data-extraction-rules>

# app/src/main/AndroidManifest.xml:
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">

    <!-- Разрешения -->
    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.READ_MEDIA_IMAGES" />

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.HelloWorld">
        <activity
            android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>



===== File: ./fix_build.sh =====
#!/bin/bash

# Убедимся, что мы в корневой директории проекта
PROJECT_DIR="/root/android-hello-world-app"
cd $PROJECT_DIR || { echo "Директория проекта не найдена!"; exit 1; }

# Создание или обновление dialog_layer_selection.xml
echo "Создание/обновление dialog_layer_selection.xml..."
mkdir -p app/src/main/res/layout
cat > app/src/main/res/layout/dialog_layer_selection.xml << 'EOL'
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="16dp">

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/layerRecyclerView"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

</LinearLayout>
EOL

# Создание или обновление strings.xml
echo "Создание/обновление strings.xml..."
mkdir -p app/src/main/res/values
cat > app/src/main/res/values/strings.xml << 'EOL'
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">HelloWorld</string>
    <string name="layer_selection_title">Select Pencil Layers</string>
    <string name="pick_image">Pick Image</string>
    <string name="pencil_mode">Pencil Mode</string>
    <string name="select_layers">Select Layers</string>
    <string name="show_controls">Show Controls</string>
    <string name="hide_image">Hide Image</string>
    <string name="save_parameters">Save Parameters</string>
    <string name="load_parameters">Load Parameters</string>
    <string name="switch_camera">Switch Camera</string>
    <string name="capture_image">Capture Image</string>
</resources>
EOL

# Замена MainActivity.java с добавленными импортами
echo "Замена MainActivity.java..."
cat > app/src/main/java/com/example/helloworld/MainActivity.java << 'EOL'
package com.example.helloworld;

import android.Manifest;
import android.app.Dialog;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.res.Configuration;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.ColorMatrix;
import android.graphics.ColorMatrixColorFilter;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.hardware.camera2.CameraAccessException;
import android.hardware.camera2.CameraCaptureSession;
import android.hardware.camera2.CameraCharacteristics;
import android.hardware.camera2.CameraDevice;
import android.hardware.camera2.CameraManager;
import android.hardware.camera2.CaptureRequest;
import android.hardware.camera2.TotalCaptureResult;
import android.media.Image;
import android.media.ImageReader;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.HandlerThread;
import android.provider.MediaStore;
import android.util.Log;
import android.util.Size;
import android.view.MotionEvent;
import android.view.ScaleGestureDetector;
import android.view.Surface;
import android.view.SurfaceHolder;
import android.view.SurfaceView;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.ImageView;
import android.widget.SeekBar;
import android.widget.Switch;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.app.ActivityCompat;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class MainActivity extends AppCompatActivity implements LayerAdapter.OnLayerVisibilityChangedListener {

    private static final String TAG = "MainActivity";
    private static final int REQUEST_CAMERA_PERMISSION = 100;
    private static final int REQUEST_STORAGE_PERMISSION = 101;
    private static final int PICK_IMAGE_REQUEST = 1;

    private SurfaceView cameraSurfaceView;
    private ImageView imageView;
    private SeekBar transparencySeekBar;
    private Button pickImageButton;
    private Switch pencilModeSwitch;
    private Button layerSelectButton;
    private CheckBox controlsVisibilityCheckbox;
    private CheckBox hideImageCheckbox;
    private Button saveParametersButton;
    private Button loadParametersButton;
    private Button switchCameraButton;
    private Button captureButton;

    private CameraDevice cameraDevice;
    private CameraCaptureSession cameraCaptureSession;
    private CaptureRequest.Builder previewRequestBuilder;
    private String cameraId;
    private Size previewSize;
    private HandlerThread backgroundThread;
    private Handler backgroundHandler;
    private final Object cameraOpenCloseLock = new Object();
    private volatile boolean isSurfaceAvailable = false;
    private volatile boolean isCameraPendingOpen = false;
    private volatile boolean isCameraOpen = false;

    private Bitmap originalBitmap;
    private Bitmap pencilBitmap;
    private Bitmap[] layerBitmaps;
    private boolean[] layerVisibility;
    private Matrix matrix = new Matrix();
    private float scaleFactor = 1.0f;
    private float rotationAngle = 0.0f;
    private boolean isPencilMode = false;
    private boolean isImageVisible = true;
    private ScaleGestureDetector scaleGestureDetector;
    private float lastTouchX, lastTouchY;
    private boolean isDragging = false;

    private String[] cameraIds;
    private int currentCameraIndex = 0;

    private ImageReader imageReader;
    private static final int CAPTURE_WIDTH = 1280;
    private static final int CAPTURE_HEIGHT = 720;

    private static final String[] PENCIL_HARDNESS = {
            "9H", "8H", "7H", "6H", "5H", "4H", "3H", "2H", "H", "F",
            "HB", "B", "2B", "3B", "4B", "5B", "6B", "7B", "8B", "9B"
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        cameraSurfaceView = findViewById(R.id.cameraSurfaceView);
        imageView = findViewById(R.id.imageView);
        transparencySeekBar = findViewById(R.id.transparencySeekBar);
        pickImageButton = findViewById(R.id.pickImageButton);
        pencilModeSwitch = findViewById(R.id.pencilModeSwitch);
        layerSelectButton = findViewById(R.id.layerSelectButton);
        controlsVisibilityCheckbox = findViewById(R.id.controlsVisibilityCheckbox);
        hideImageCheckbox = findViewById(R.id.hideImageCheckbox);
        saveParametersButton = findViewById(R.id.saveParametersButton);
        loadParametersButton = findViewById(R.id.loadParametersButton);
        switchCameraButton = findViewById(R.id.switchCameraButton);
        captureButton = findViewById(R.id.captureButton);

        scaleGestureDetector = new ScaleGestureDetector(this, new ScaleGestureDetector.SimpleOnScaleGestureListener() {
            @Override
            public boolean onScale(ScaleGestureDetector detector) {
                scaleFactor *= detector.getScaleFactor();
                scaleFactor = Math.max(0.1f, Math.min(scaleFactor, 5.0f));
                matrix.postScale(detector.getScaleFactor(), detector.getScaleFactor(), detector.getFocusX(), detector.getFocusY());
                applyTransformations();
                return true;
            }
        });

        imageView.setOnTouchListener((v, event) -> {
            scaleGestureDetector.onTouchEvent(event);
            switch (event.getAction()) {
                case MotionEvent.ACTION_DOWN:
                    lastTouchX = event.getX();
                    lastTouchY = event.getY();
                    isDragging = true;
                    break;
                case MotionEvent.ACTION_MOVE:
                    if (isDragging) {
                        float dx = event.getX() - lastTouchX;
                        float dy = event.getY() - lastTouchY;
                        matrix.postTranslate(dx, dy);
                        applyTransformations();
                        lastTouchX = event.getX();
                        lastTouchY = event.getY();
                    }
                    break;
                case MotionEvent.ACTION_UP:
                case MotionEvent.ACTION_CANCEL:
                    isDragging = false;
                    break;
            }
            return true;
        });

        cameraSurfaceView.getHolder().addCallback(new SurfaceHolder.Callback() {
            @Override
            public void surfaceCreated(SurfaceHolder holder) {
                Log.d(TAG, "Surface created");
                isSurfaceAvailable = true;
                if (isCameraPendingOpen && !isCameraOpen) {
                    openCamera();
                    isCameraPendingOpen = false;
                }
            }

            @Override
            public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
                Log.d(TAG, "Surface changed: " + width + "x" + height);
                adjustSurfaceViewAspectRatioWithCropping(width, height);
                if (cameraDevice != null && isSurfaceAvailable) {
                    closeCameraPreviewSession();
                    previewSize = chooseOptimalPreviewSize(getPreviewSizes(), width, height);
                    createCameraPreviewSession();
                }
            }

            @Override
            public void surfaceDestroyed(SurfaceHolder holder) {
                Log.d(TAG, "Surface destroyed");
                isSurfaceAvailable = false;
                closeCamera();
            }
        });

        transparencySeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
            @Override
            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
                setImageAlpha(progress);
            }

            @Override
            public void onStartTrackingTouch(SeekBar seekBar) {}

            @Override
            public void onStopTrackingTouch(SeekBar seekBar) {}
        });

        pickImageButton.setOnClickListener(v -> pickImage());

        pencilModeSwitch.setOnCheckedChangeListener((buttonView, isChecked) -> {
            isPencilMode = isChecked;
            layerSelectButton.setVisibility(isChecked ? View.VISIBLE : View.GONE);
            if (isPencilMode) {
                processPencilEffect();
            }
            updateImageDisplay();
        });

        layerSelectButton.setOnClickListener(v -> showLayerSelectionDialog());

        controlsVisibilityCheckbox.setOnCheckedChangeListener((buttonView, isChecked) -> {
            int visibility = isChecked ? View.VISIBLE : View.GONE;
            transparencySeekBar.setVisibility(visibility);
            pickImageButton.setVisibility(visibility);
            pencilModeSwitch.setVisibility(visibility);
            layerSelectButton.setVisibility(isPencilMode && isChecked ? View.VISIBLE : View.GONE);
            hideImageCheckbox.setVisibility(visibility);
            saveParametersButton.setVisibility(visibility);
            loadParametersButton.setVisibility(visibility);
            switchCameraButton.setVisibility(visibility);
            captureButton.setVisibility(visibility);
        });

        hideImageCheckbox.setOnCheckedChangeListener((buttonView, isChecked) -> {
            isImageVisible = !isChecked;
            updateImageDisplay();
        });

        saveParametersButton.setOnClickListener(v -> saveParameters());

        loadParametersButton.setOnClickListener(v -> loadParameters());

        switchCameraButton.setOnClickListener(v -> switchCamera());

        captureButton.setOnClickListener(v -> captureImage());

        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.CAMERA}, REQUEST_CAMERA_PERMISSION);
        } else {
            isCameraPendingOpen = true;
        }

        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED ||
                ActivityCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE}, REQUEST_STORAGE_PERMISSION);
        }

        CameraManager manager = (CameraManager) getSystemService(CAMERA_SERVICE);
        try {
            cameraIds = manager.getCameraIdList();
            if (cameraIds.length > 0) {
                cameraId = cameraIds[0];
            }
        } catch (CameraAccessException e) {
            Log.e(TAG, "Error accessing camera list", e);
            Toast.makeText(this, "Cannot access cameras", Toast.LENGTH_LONG).show();
        }

        layerVisibility = new boolean[20];
        Arrays.fill(layerVisibility, true);
    }

    private void adjustSurfaceViewAspectRatioWithCropping(int width, int height) {
        if (previewSize == null) {
            Log.e(TAG, "Preview size is null, cannot adjust aspect ratio");
            return;
        }

        float previewRatio = (float) previewSize.getWidth() / previewSize.getHeight();
        float viewRatio = (float) width / height;

        cameraSurfaceView.setScaleX(1.0f);
        cameraSurfaceView.setScaleY(1.0f);

        float scaleX, scaleY;
        if (previewRatio > viewRatio) {
            scaleY = 1.0f;
            scaleX = previewRatio / viewRatio;
        } else {
            scaleX = 1.0f;
            scaleY = viewRatio / previewRatio;
        }

        cameraSurfaceView.setScaleX(scaleX);
        cameraSurfaceView.setScaleY(scaleY);

        cameraSurfaceView.setPivotX(width / 2f);
        cameraSurfaceView.setPivotY(height / 2f);

        ViewGroup.LayoutParams params = cameraSurfaceView.getLayoutParams();
        params.width = width;
        params.height = height;
        cameraSurfaceView.setLayoutParams(params);

        cameraSurfaceView.requestLayout();
        Log.d(TAG, "Adjusted SurfaceView: width=" + width + ", height=" + height +
                ", previewRatio=" + previewRatio + ", scaleX=" + scaleX + ", scaleY=" + scaleY);
    }

    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
        if (requestCode == REQUEST_CAMERA_PERMISSION) {
            if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                if (isSurfaceAvailable && !isCameraOpen) {
                    openCamera();
                } else {
                    isCameraPendingOpen = true;
                }
            } else {
                Toast.makeText(this, "Camera permission is required", Toast.LENGTH_LONG).show();
                finish();
            }
        } else if (requestCode == REQUEST_STORAGE_PERMISSION) {
            if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                // Permission granted
            } else {
                Toast.makeText(this, "Storage permission is required", Toast.LENGTH_LONG).show();
            }
        }
    }

    private void startBackgroundThread() {
        if (backgroundThread == null) {
            backgroundThread = new HandlerThread("CameraBackground");
            backgroundThread.start();
            backgroundHandler = new Handler(backgroundThread.getLooper());
        }
    }

    private void stopBackgroundThread() {
        if (backgroundThread != null) {
            backgroundThread.quitSafely();
            try {
                backgroundThread.join();
                backgroundThread = null;
                backgroundHandler = null;
            } catch (InterruptedException e) {
                Log.e(TAG, "Error stopping background thread", e);
            }
        }
    }

    private void openCamera() {
        if (!isSurfaceAvailable || isCameraOpen) {
            Log.d(TAG, "Surface not available or camera already open, setting pending open");
            isCameraPendingOpen = true;
            return;
        }

        startBackgroundThread();
        CameraManager manager = (CameraManager) getSystemService(CAMERA_SERVICE);
        try {
            if (cameraId == null) {
                cameraId = manager.getCameraIdList()[0];
            }
            CameraCharacteristics characteristics = manager.getCameraCharacteristics(cameraId);
            Size[] previewSizes = characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP)
                    .getOutputSizes(SurfaceHolder.class);
            previewSize = chooseOptimalPreviewSize(previewSizes, cameraSurfaceView.getWidth(), cameraSurfaceView.getHeight());

            imageReader = ImageReader.newInstance(CAPTURE_WIDTH, CAPTURE_HEIGHT, android.graphics.ImageFormat.JPEG, 2);
            imageReader.setOnImageAvailableListener(reader -> {
                Image image = reader.acquireLatestImage();
                if (image != null) {
                    Bitmap bitmap = imageToBitmap(image);
                    image.close();
                    if (bitmap != null) {
                        processCapturedImage(bitmap);
                    }
                }
            }, backgroundHandler);

            if (ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {
                return;
            }
            synchronized (cameraOpenCloseLock) {
                isCameraOpen = true;
                manager.openCamera(cameraId, new CameraDevice.StateCallback() {
                    @Override
                    public void onOpened(@NonNull CameraDevice camera) {
                        cameraDevice = camera;
                        if (isSurfaceAvailable) {
                            createCameraPreviewSession();
                        } else {
                            Log.d(TAG, "Surface not available after camera opened, closing camera");
                            closeCamera();
                        }
                        synchronized (cameraOpenCloseLock) {
                            cameraOpenCloseLock.notify();
                        }
                    }

                    @Override
                    public void onDisconnected(@NonNull CameraDevice camera) {
                        synchronized (cameraOpenCloseLock) {
                            cameraOpenCloseLock.notify();
                        }
                        camera.close();
                        cameraDevice = null;
                        isCameraOpen = false;
                    }

                    @Override
                    public void onError(@NonNull CameraDevice camera, int error) {
                        synchronized (cameraOpenCloseLock) {
                            cameraOpenCloseLock.notify();
                        }
                        camera.close();
                        cameraDevice = null;
                        isCameraOpen = false;
                        Toast.makeText(MainActivity.this, "Camera error: " + error, Toast.LENGTH_LONG).show();
                    }
                }, backgroundHandler);
            }
        } catch (CameraAccessException e) {
            Log.e(TAG, "Cannot access camera", e);
            Toast.makeText(this, "Cannot access camera", Toast.LENGTH_LONG).show();
            isCameraOpen = false;
        }
    }

    private Size[] getPreviewSizes() {
        try {
            CameraManager manager = (CameraManager) getSystemService(CAMERA_SERVICE);
            CameraCharacteristics characteristics = manager.getCameraCharacteristics(cameraId);
            return characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP)
                    .getOutputSizes(SurfaceHolder.class);
        } catch (CameraAccessException e) {
            Log.e(TAG, "Error getting preview sizes", e);
            return new Size[]{new Size(1280, 720)};
        }
    }

    private Size chooseOptimalPreviewSize(Size[] choices, int viewWidth, int viewHeight) {
        if (choices == null || choices.length == 0) {
            Log.e(TAG, "No preview sizes available, using default");
            return new Size(1280, 720);
        }

        double targetRatio = (viewWidth > 0 && viewHeight > 0) ? (double) viewWidth / viewHeight : 4.0 / 3.0;

        Size optimalSize = null;
        double minDiff = Double.MAX_VALUE;
        int maxArea = 0;

        for (Size size : choices) {
            double ratio = (double) size.getWidth() / size.getHeight();
            int area = size.getWidth() * size.getHeight();
            double ratioDiff = Math.abs(ratio - targetRatio);
            if (ratioDiff < minDiff || (ratioDiff == minDiff && area > maxArea)) {
                optimalSize = size;
                minDiff = ratioDiff;
                maxArea = area;
            }
        }

        if (optimalSize == null) {
            optimalSize = choices[0];
        }

        Log.d(TAG, "Chosen preview size: " + optimalSize.getWidth() + "x" + optimalSize.getHeight() +
                ", targetRatio=" + targetRatio);
        return optimalSize;
    }

    private void createCameraPreviewSession() {
        if (!isSurfaceAvailable || cameraDevice == null || !isCameraOpen) {
            Log.d(TAG, "Cannot create preview session: Surface not available, cameraDevice is null, or camera is closed");
            return;
        }

        try {
            SurfaceHolder holder = cameraSurfaceView.getHolder();
            Surface surface = holder.getSurface();
            if (!surface.isValid()) {
                Log.d(TAG, "Surface is not valid, aborting preview session creation");
                return;
            }

            previewRequestBuilder = cameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
            previewRequestBuilder.addTarget(surface);

            List<Surface> surfaces = new ArrayList<>();
            surfaces.add(surface);
            surfaces.add(imageReader.getSurface());

            cameraDevice.createCaptureSession(surfaces, new CameraCaptureSession.StateCallback() {
                @Override
                public void onConfigured(@NonNull CameraCaptureSession session) {
                    if (cameraDevice == null || !isSurfaceAvailable || !isCameraOpen) {
                        Log.d(TAG, "Camera device closed, surface not available, or camera not open during session configuration");
                        session.close();
                        return;
                    }
                    cameraCaptureSession = session;
                    try {
                        previewRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);
                        cameraCaptureSession.setRepeatingRequest(previewRequestBuilder.build(), null, backgroundHandler);
                        Log.d(TAG, "Camera preview session started");
                    } catch (CameraAccessException e) {
                        Log.e(TAG, "Error setting up camera preview", e);
                    } catch (IllegalStateException e) {
                        Log.e(TAG, "Session already closed during setRepeatingRequest", e);
                    }
                }

                @Override
                public void onConfigureFailed(@NonNull CameraCaptureSession session) {
                    Toast.makeText(MainActivity.this, "Failed to configure camera preview", Toast.LENGTH_LONG).show();
                }
            }, backgroundHandler);
        } catch (CameraAccessException e) {
            Log.e(TAG, "Error creating camera preview session", e);
        }
    }

    private void closeCameraPreviewSession() {
        if (cameraCaptureSession != null) {
            cameraCaptureSession.close();
            cameraCaptureSession = null;
        }
    }

    private void closeCamera() {
        synchronized (cameraOpenCloseLock) {
            closeCameraPreviewSession();
            if (cameraDevice != null) {
                cameraDevice.close();
                cameraDevice = null;
            }
            if (imageReader != null) {
                imageReader.close();
                imageReader = null;
            }
            isCameraOpen = false;
        }
        stopBackgroundThread();
    }

    private void switchCamera() {
        CameraManager manager = (CameraManager) getSystemService(CAMERA_SERVICE);
        try {
            closeCamera();
            currentCameraIndex = (currentCameraIndex + 1) % cameraIds.length;
            cameraId = cameraIds[currentCameraIndex];
            if (isSurfaceAvailable && !isCameraOpen) {
                openCamera();
            } else {
                isCameraPendingOpen = true;
            }
        } catch (Exception e) {
            Log.e(TAG, "Error switching camera", e);
            Toast.makeText(this, "Error switching camera", Toast.LENGTH_LONG).show();
        }
    }

    private void captureImage() {
        if (cameraDevice == null || cameraCaptureSession == null) {
            Log.e(TAG, "Cannot capture image: camera not initialized");
            return;
        }

        try {
            CaptureRequest.Builder captureBuilder = cameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);
            captureBuilder.addTarget(imageReader.getSurface());
            captureBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);

            cameraCaptureSession.capture(captureBuilder.build(), new CameraCaptureSession.CaptureCallback() {
                @Override
                public void onCaptureCompleted(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull TotalCaptureResult result) {
                    Log.d(TAG, "Image captured successfully");
                }
            }, backgroundHandler);
        } catch (CameraAccessException e) {
            Log.e(TAG, "Error capturing image", e);
            Toast.makeText(this, "Error capturing image", Toast.LENGTH_LONG).show();
        }
    }

    private Bitmap imageToBitmap(Image image) {
        ByteBuffer buffer = image.getPlanes()[0].getBuffer();
        byte[] bytes = new byte[buffer.remaining()];
        buffer.get(bytes);
        return BitmapFactory.decodeByteArray(bytes, 0, bytes.length);
    }

    private void processCapturedImage(Bitmap bitmap) {
        // Упрощённая обработка без OpenCV: просто сохраняем изображение
        runOnUiThread(() -> {
            if (originalBitmap != null && !originalBitmap.isRecycled()) {
                originalBitmap.recycle();
            }
            originalBitmap = bitmap.copy(Bitmap.Config.ARGB_8888, true);
            resetTransformationsAndFit();
            updateImageDisplay();
        });
    }

    private void pickImage() {
        Intent intent = new Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI);
        startActivityForResult(intent, PICK_IMAGE_REQUEST);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if (requestCode == PICK_IMAGE_REQUEST && resultCode == RESULT_OK && data != null) {
            Uri imageUri = data.getData();
            try {
                if (originalBitmap != null && !originalBitmap.isRecycled()) {
                    originalBitmap.recycle();
                }
                originalBitmap = MediaStore.Images.Media.getBitmap(getContentResolver(), imageUri);
                resetTransformationsAndFit();
                layerVisibility = new boolean[20];
                Arrays.fill(layerVisibility, true);
                if (isPencilMode) {
                    processPencilEffect();
                }
                updateImageDisplay();
            } catch (IOException e) {
                Log.e(TAG, "Error loading image", e);
                Toast.makeText(this, "Error loading image", Toast.LENGTH_LONG).show();
            }
        }
    }

    private void resetTransformationsAndFit() {
        if (originalBitmap == null || imageView.getWidth() == 0 || imageView.getHeight() == 0) {
            matrix.reset();
            scaleFactor = 1.0f;
            rotationAngle = 0.0f;
            imageView.setImageMatrix(matrix);
            return;
        }

        matrix.reset();

        float viewWidth = imageView.getWidth();
        float viewHeight = imageView.getHeight();
        float bmpWidth = originalBitmap.getWidth();
        float bmpHeight = originalBitmap.getHeight();

        float scaleX = viewWidth / bmpWidth;
        float scaleY = viewHeight / bmpHeight;
        float initialScale = Math.min(scaleX, scaleY);

        float scaledBmpWidth = bmpWidth * initialScale;
        float scaledBmpHeight = bmpHeight * initialScale;
        float initialTranslateX = (viewWidth - scaledBmpWidth) / 2f;
        float initialTranslateY = (viewHeight - scaledBmpHeight) / 2f;

        matrix.postScale(initialScale, initialScale);
        matrix.postTranslate(initialTranslateX, initialTranslateY);

        imageView.post(() -> {
            imageView.setImageMatrix(matrix);
            imageView.invalidate();
            scaleFactor = initialScale;
            rotationAngle = 0.0f;
        });
    }

    private void applyTransformations() {
        imageView.setImageMatrix(matrix);
        imageView.invalidate();
        Log.d(TAG, "Transformations applied: scale=" + scaleFactor);
    }

    private void setImageAlpha(int progress) {
        float alpha = progress / 100.0f;
        imageView.setAlpha(alpha);
        imageView.invalidate();
        Log.d(TAG, "Image alpha set to: " + alpha);
    }

    private void processPencilEffect() {
        Log.d(TAG, "Processing pencil effect");
        if (originalBitmap == null) {
            Log.d(TAG, "Original bitmap is null, cannot process pencil effect");
            return;
        }

        if (pencilBitmap != null && !pencilBitmap.isRecycled()) {
            pencilBitmap.recycle();
            pencilBitmap = null;
        }
        if (layerBitmaps != null) {
            for (Bitmap layer : layerBitmaps) {
                if (layer != null && !layer.isRecycled()) {
                    layer.recycle();
                }
            }
            layerBitmaps = null;
        }

        try {
            pencilBitmap = Bitmap.createBitmap(originalBitmap.getWidth(), originalBitmap.getHeight(), Bitmap.Config.ARGB_8888);
            if (pencilBitmap == null) {
                Log.e(TAG, "Failed to create pencilBitmap");
                return;
            }
            Canvas canvas = new Canvas(pencilBitmap);
            Paint paint = new Paint();
            ColorMatrix colorMatrix = new ColorMatrix();
            colorMatrix.setSaturation(0); // Преобразование в чёрно-белое
            ColorMatrixColorFilter filter = new ColorMatrixColorFilter(colorMatrix);
            paint.setColorFilter(filter);
            canvas.drawBitmap(originalBitmap, 0, 0, paint);

            layerBitmaps = new Bitmap[20];
            for (int i = 0; i < 20; i++) {
                layerBitmaps[i] = Bitmap.createBitmap(originalBitmap.getWidth(), originalBitmap.getHeight(), Bitmap.Config.ARGB_8888);
                if (layerBitmaps[i] == null) {
                    Log.e(TAG, "Failed to create layerBitmap[" + i + "]");
                    return;
                }
                layerBitmaps[i].eraseColor(Color.TRANSPARENT);
            }

            int[] pixels = new int[originalBitmap.getWidth() * originalBitmap.getHeight()];
            pencilBitmap.getPixels(pixels, 0, originalBitmap.getWidth(), 0, 0, originalBitmap.getWidth(), originalBitmap.getHeight());

            for (int i = 0; i < pixels.length; i++) {
                int gray = Color.red(pixels[i]); // Простое преобразование в градации серого
                int layerIndex = getLayerIndex(gray);
                if (layerIndex >= 0 && layerIndex < 20 && layerBitmaps[layerIndex] != null) {
                    layerBitmaps[layerIndex].setPixel(i % originalBitmap.getWidth(), i / originalBitmap.getWidth(), pixels[i]);
                }
            }
            Log.d(TAG, "Pencil effect processed successfully");
        } catch (OutOfMemoryError e) {
            Log.e(TAG, "OutOfMemoryError in processPencilEffect", e);
            Toast.makeText(this, "Not enough memory for pencil effect", Toast.LENGTH_LONG).show();
            pencilBitmap = null;
            layerBitmaps = null;
        }
    }

    private int getLayerIndex(int grayValue) {
        return grayValue / (256 / 20);
    }

    private void updateImageDisplay() {
        Log.d(TAG, "updateImageDisplay: isPencilMode=" + isPencilMode + ", isImageVisible=" + isImageVisible);
        if (originalBitmap == null || !isImageVisible) {
            Log.d(TAG, "updateImageDisplay: originalBitmap is null or image is not visible");
            imageView.setImageBitmap(null);
            imageView.setVisibility(View.INVISIBLE);
            imageView.invalidate();
            return;
        }

        if (isPencilMode) {
            Log.d(TAG, "updateImageDisplay: Processing pencil mode");
            if (pencilBitmap == null || layerBitmaps == null) {
                processPencilEffect();
            }

            if (pencilBitmap == null || layerBitmaps == null) {
                Log.d(TAG, "updateImageDisplay: pencilBitmap or layerBitmaps is null");
                imageView.setImageBitmap(null);
                imageView.setVisibility(View.INVISIBLE);
                imageView.invalidate();
                return;
            }

            Bitmap resultBitmap = Bitmap.createBitmap(originalBitmap.getWidth(), originalBitmap.getHeight(), Bitmap.Config.ARGB_8888);
            if (resultBitmap == null) {
                Log.d(TAG, "updateImageDisplay: Failed to create resultBitmap");
                imageView.setImageBitmap(null);
                imageView.setVisibility(View.INVISIBLE);
                imageView.invalidate();
                return;
            }
            Canvas canvas = new Canvas(resultBitmap);
            canvas.drawColor(Color.TRANSPARENT);

            for (int i = 0; i < layerBitmaps.length; i++) {
                if (layerVisibility[i] && layerBitmaps[i] != null && !layerBitmaps[i].isRecycled()) {
                    canvas.drawBitmap(layerBitmaps[i], 0, 0, null);
                }
            }

            imageView.setImageBitmap(resultBitmap);
            setImageAlpha(transparencySeekBar.getProgress());
            imageView.setVisibility(View.VISIBLE);
            imageView.post(() -> {
                imageView.setImageMatrix(matrix);
                imageView.invalidate();
            });
            Log.d(TAG, "updateImageDisplay: Pencil mode applied");
        } else {
            Log.d(TAG, "updateImageDisplay: Displaying original bitmap");
            imageView.setImageBitmap(originalBitmap);
            setImageAlpha(transparencySeekBar.getProgress());
            imageView.setVisibility(View.VISIBLE);
            imageView.post(() -> {
                imageView.setImageMatrix(matrix);
                imageView.invalidate();
            });
            Log.d(TAG, "updateImageDisplay: Original bitmap displayed");
        }
    }

    private void showLayerSelectionDialog() {
        Dialog dialog = new Dialog(this);
        dialog.setContentView(R.layout.dialog_layer_selection);
        dialog.setTitle(R.string.layer_selection_title);

        RecyclerView recyclerView = dialog.findViewById(R.id.layerRecyclerView);
        recyclerView.setLayoutManager(new LinearLayoutManager(this));
        LayerAdapter adapter = new LayerAdapter(PENCIL_HARDNESS, layerVisibility, this);
        recyclerView.setAdapter(adapter);

        dialog.show();
    }

    @Override
    public void onLayerVisibilityChanged(int position, boolean isVisible) {
        layerVisibility[position] = isVisible;
        updateImageDisplay();
    }

    private void saveParameters() {
        try {
            File file = new File(getFilesDir(), "parameters.dat");
            FileOutputStream fos = new FileOutputStream(file);
            fos.write(Float.toString(scaleFactor).getBytes());
            fos.write("\n".getBytes());
            fos.write(Float.toString(rotationAngle).getBytes());
            fos.write("\n".getBytes());
            float[] matrixValues = new float[9];
            matrix.getValues(matrixValues);
            for (float value : matrixValues) {
                fos.write(Float.toString(value).getBytes());
                fos.write(" ".getBytes());
            }
            fos.write("\n".getBytes());
            fos.write(String.valueOf(isPencilMode).getBytes());
            fos.write("\n".getBytes());
            for (boolean visible : layerVisibility) {
                fos.write(String.valueOf(visible).getBytes());
                fos.write(" ".getBytes());
            }
            fos.close();
            Toast.makeText(this, "Parameters saved", Toast.LENGTH_SHORT).show();
        } catch (IOException e) {
            Log.e(TAG, "Error saving parameters", e);
            Toast.makeText(this, "Error saving parameters", Toast.LENGTH_LONG).show();
        }
    }

    private void loadParameters() {
        try {
            File file = new File(getFilesDir(), "parameters.dat");
            if (!file.exists()) {
                Toast.makeText(this, "No saved parameters found", Toast.LENGTH_SHORT).show();
                return;
            }
            FileInputStream fis = new FileInputStream(file);
            byte[] buffer = new byte[(int) file.length()];
            fis.read(buffer);
            fis.close();
            String[] lines = new String(buffer).split("\n");
            if (lines.length < 4) {
                Toast.makeText(this, "Invalid parameters file", Toast.LENGTH_LONG).show();
                return;
            }
            scaleFactor = Float.parseFloat(lines[0]);
            rotationAngle = Float.parseFloat(lines[1]);
            String[] matrixValues = lines[2].split(" ");
            float[] values = new float[9];
            for (int i = 0; i < 9; i++) {
                values[i] = Float.parseFloat(matrixValues[i]);
            }
            matrix.setValues(values);
            isPencilMode = Boolean.parseBoolean(lines[3]);
            pencilModeSwitch.setChecked(isPencilMode);
            String[] visibilityValues = lines[4].split(" ");
            for (int i = 0; i < layerVisibility.length; i++) {
                layerVisibility[i] = Boolean.parseBoolean(visibilityValues[i]);
            }
            applyTransformations();
            updateImageDisplay();
            Toast.makeText(this, "Parameters loaded", Toast.LENGTH_SHORT).show();
        } catch (IOException | NumberFormatException e) {
            Log.e(TAG, "Error loading parameters", e);
            Toast.makeText(this, "Error loading parameters", Toast.LENGTH_LONG).show();
        }
    }

    @Override
    protected void onResume() {
        super.onResume();
        if (isSurfaceAvailable && !isCameraOpen) {
            openCamera();
        } else {
            isCameraPendingOpen = true;
        }
    }

    @Override
    protected void onPause() {
        closeCamera();
        super.onPause();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        if (originalBitmap != null && !originalBitmap.isRecycled()) {
            originalBitmap.recycle();
            originalBitmap = null;
        }
        if (pencilBitmap != null && !pencilBitmap.isRecycled()) {
            pencilBitmap.recycle();
            pencilBitmap = null;
        }
        if (layerBitmaps != null) {
            for (Bitmap layer : layerBitmaps) {
                if (layer != null && !layer.isRecycled()) {
                    layer.recycle();
                }
            }
            layerBitmaps = null;
        }
    }

    @Override
    public void onConfigurationChanged(@NonNull Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        resetTransformationsAndFit();
        updateImageDisplay();
    }
}
EOL

# Очистка проекта
echo "Очистка проекта..."
./gradlew clean

# Пересборка проекта
echo "Пересборка проекта..."
./gradlew assembleDebug

echo "Исправление завершено!"


===== File: ./gradle-wrapper.properties =====
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.5-bin.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists


===== File: ./gradle.properties =====
android.useAndroidX=true


===== File: ./ic_launcher.png =====


===== File: ./remove_capture_button.sh =====
#!/bin/bash

echo "--- Начало удаления логики 'Capture Image' ---"

# --- Определяем пути к файлам ---
ACTIVITY_MAIN_LAYOUT="app/src/main/res/layout/activity_main.xml"
MAIN_ACTIVITY_JAVA="app/src/main/java/com/example/helloworld/MainActivity.java"
STRINGS_XML="app/src/main/res/values/strings.xml"

# --- Проверка существования файлов ---
if [ ! -f "$ACTIVITY_MAIN_LAYOUT" ]; then
  echo "ОШИБКА: Файл $ACTIVITY_MAIN_LAYOUT не найден!"
  exit 1
fi
if [ ! -f "$MAIN_ACTIVITY_JAVA" ]; then
  echo "ОШИБКА: Файл $MAIN_ACTIVITY_JAVA не найден!"
  exit 1
fi
if [ ! -f "$STRINGS_XML" ]; then
  echo "ОШИБКА: Файл $STRINGS_XML не найден!"
  exit 1
fi

# --- Шаг 1: Удаление Button из activity_main.xml ---
echo "1. Удаление кнопки 'captureButton' из $ACTIVITY_MAIN_LAYOUT..."
# Удаляем блок <Button> с id="@+id/captureButton" до закрывающего '/>'
sed -i '/android:id="@+id\/captureButton"/,/ \/>/d' "$ACTIVITY_MAIN_LAYOUT" || { echo "Ошибка при удалении кнопки из XML."; exit 1; }
echo "   Кнопка из XML удалена."

# --- Шаг 2: Удаление строки из strings.xml ---
echo "2. Удаление строки 'capture_image' из $STRINGS_XML..."
sed -i '/<string name="capture_image">/d' "$STRINGS_XML" || { echo "Ошибка при удалении строки."; exit 1; }
echo "   Строка удалена."

# --- Шаг 3: Удаление кода из MainActivity.java ---
echo "3. Модификация $MAIN_ACTIVITY_JAVA..."

# Удаление объявления переменной captureButton
echo "   - Удаление объявления captureButton..."
sed -i '/private Button captureButton;/d' "$MAIN_ACTIVITY_JAVA" || { echo "Ошибка при удалении объявления captureButton."; exit 1; }

# Удаление findViewById для captureButton
echo "   - Удаление findViewById(R.id.captureButton)..."
sed -i '/captureButton = findViewById(R.id.captureButton);/d' "$MAIN_ACTIVITY_JAVA" || { echo "Ошибка при удалении findViewById."; exit 1; }

# Удаление setOnClickListener для captureButton
echo "   - Удаление captureButton.setOnClickListener..."
sed -i '/captureButton.setOnClickListener(v -> captureImage());/d' "$MAIN_ACTIVITY_JAVA" || { echo "Ошибка при удалении setOnClickListener."; exit 1; }

# Удаление метода captureImage()
echo "   - Удаление метода captureImage()..."
# Удаляем блок от сигнатуры метода до закрывающей фигурной скобки на отдельной строке
sed -i '/private void captureImage() {/,/^\s*}/d' "$MAIN_ACTIVITY_JAVA" || { echo "Ошибка при удалении метода captureImage."; exit 1; }

# Удаление метода imageToBitmap()
echo "   - Удаление метода imageToBitmap()..."
sed -i '/private Bitmap imageToBitmap(Image image) {/,/^\s*}/d' "$MAIN_ACTIVITY_JAVA" || { echo "Ошибка при удалении метода imageToBitmap."; exit 1; }

# Удаление метода processCapturedImage()
echo "   - Удаление метода processCapturedImage()..."
# Указываем тип аргумента для большей точности
sed -i '/private void processCapturedImage(final Bitmap capturedBitmap) {/,/^\s*});\s*}/d' "$MAIN_ACTIVITY_JAVA" || { echo "Ошибка при удалении метода processCapturedImage."; exit 1; }

# Удаление объявления переменной imageReader
echo "   - Удаление объявления imageReader..."
sed -i '/private ImageReader imageReader;/d' "$MAIN_ACTIVITY_JAVA" || { echo "Ошибка при удалении объявления imageReader."; exit 1; }

# Удаление блока инициализации ImageReader в openCamera()
echo "   - Удаление инициализации imageReader в openCamera()..."
sed -i '/if (imageReader != null) imageReader.close();/,/}, backgroundHandler);/d' "$MAIN_ACTIVITY_JAVA" || { echo "Ошибка при удалении инициализации ImageReader."; exit 1; }


# Удаление добавления поверхности ImageReader в createCameraPreviewSession()
echo "   - Удаление surfaces.add(imageReader.getSurface())..."
# Используем # как разделитель в sed из-за слешей в паттерне
sed -i '\#surfaces.add(imageReader.getSurface());#d' "$MAIN_ACTIVITY_JAVA" || { echo "Ошибка при удалении surfaces.add(imageReader)."; exit 1; }
# Удаляем также комментарий, связанный с этим
sed -i '/\/\/ Добавляем поверхность ImageReader только если он есть/d' "$MAIN_ACTIVITY_JAVA" || true # Игнорируем ошибку, если комментарий уже удален

# Удаление закрытия ImageReader в closeCamera()
echo "   - Удаление закрытия imageReader в closeCamera()..."
# Удаляем блок if (imageReader != null) { ... }
sed -i '/if (imageReader != null) {/,/Log.d(TAG, "ImageReader closed.");/d' "$MAIN_ACTIVITY_JAVA" || { echo "Ошибка при удалении закрытия imageReader (блок)."; exit 1; }
sed -i '/imageReader = null;/d' "$MAIN_ACTIVITY_JAVA" # Удаляем присвоение null отдельно

# Удаление неиспользуемых импортов
echo "   - Удаление неиспользуемых импортов..."
sed -i '/import android.media.Image;/d' "$MAIN_ACTIVITY_JAVA" || true
sed -i '/import android.media.ImageReader;/d' "$MAIN_ACTIVITY_JAVA" || true
sed -i '/import java.nio.ByteBuffer;/d' "$MAIN_ACTIVITY_JAVA" || true
sed -i '/import android.hardware.camera2.TotalCaptureResult;/d' "$MAIN_ACTIVITY_JAVA" || true

# Удаление видимости captureButton в updateControlsVisibility
echo "   - Удаление captureButton.setVisibility в updateControlsVisibility..."
sed -i '/captureButton.setVisibility(visibility);/d' "$MAIN_ACTIVITY_JAVA" || { echo "Ошибка при удалении captureButton.setVisibility."; exit 1; }

echo "   Модификация MainActivity.java завершена."

echo "--- Удаление логики 'Capture Image' завершено ---"
echo "Пожалуйста, проверьте изменения и пересоберите проект."


